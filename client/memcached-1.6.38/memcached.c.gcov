        -:    0:Source:memcached.c
        -:    0:Graph:memcached.gcno
        -:    0:Data:memcached.gcda
        -:    0:Runs:451
        -:    1:/* -*- Mode: C; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*- */
        -:    2:/*
        -:    3: *  memcached - memory caching daemon
        -:    4: *
        -:    5: *       https://www.memcached.org/
        -:    6: *
        -:    7: *  Copyright 2003 Danga Interactive, Inc.  All rights reserved.
        -:    8: *
        -:    9: *  Use and distribution licensed under the BSD license.  See
        -:   10: *  the LICENSE file for full text.
        -:   11: *
        -:   12: *  Authors:
        -:   13: *      Anatoly Vorobey <mellon@pobox.com>
        -:   14: *      Brad Fitzpatrick <brad@danga.com>
        -:   15: */
        -:   16:#include "memcached.h"
        -:   17:#include "storage.h"
        -:   18:#include "authfile.h"
        -:   19:#include "restart.h"
        -:   20:#include "slabs_mover.h"
        -:   21:#include <sys/stat.h>
        -:   22:#include <sys/socket.h>
        -:   23:#include <sys/un.h>
        -:   24:#include <signal.h>
        -:   25:#include <sys/param.h>
        -:   26:#include <sys/resource.h>
        -:   27:#include <sys/uio.h>
        -:   28:#include <ctype.h>
        -:   29:#include <stdarg.h>
        -:   30:
        -:   31:/* some POSIX systems need the following definition
        -:   32: * to get mlockall flags out of sys/mman.h.  */
        -:   33:#ifndef _P1003_1B_VISIBLE
        -:   34:#define _P1003_1B_VISIBLE
        -:   35:#endif
        -:   36:#include <pwd.h>
        -:   37:#include <sys/mman.h>
        -:   38:#include <fcntl.h>
        -:   39:#include <netinet/tcp.h>
        -:   40:#include <arpa/inet.h>
        -:   41:#include <errno.h>
        -:   42:#include <stdlib.h>
        -:   43:#include <stdio.h>
        -:   44:#include <string.h>
        -:   45:#include <time.h>
        -:   46:#include <assert.h>
        -:   47:#include <sysexits.h>
        -:   48:#include <stddef.h>
        -:   49:
        -:   50:#ifdef HAVE_GETOPT_LONG
        -:   51:#include <getopt.h>
        -:   52:#endif
        -:   53:
        -:   54:#include "tls.h"
        -:   55:
        -:   56:#include "proto_text.h"
        -:   57:#include "proto_bin.h"
        -:   58:#include "proto_proxy.h"
        -:   59:
        -:   60:#if defined(__FreeBSD__)
        -:   61:#include <sys/sysctl.h>
        -:   62:#endif
        -:   63:
        -:   64:/*
        -:   65: * forward declarations
        -:   66: */
        -:   67:static void drive_machine(conn *c);
        -:   68:static int new_socket(struct addrinfo *ai);
        -:   69:static ssize_t tcp_read(conn *arg, void *buf, size_t count);
        -:   70:static ssize_t tcp_sendmsg(conn *arg, struct msghdr *msg, int flags);
        -:   71:static ssize_t tcp_write(conn *arg, void *buf, size_t count);
        -:   72:
        -:   73:enum try_read_result {
        -:   74:    READ_DATA_RECEIVED,
        -:   75:    READ_NO_DATA_RECEIVED,
        -:   76:    READ_ERROR,            /** an error occurred (on the socket) (or client closed connection) */
        -:   77:    READ_MEMORY_ERROR      /** failed to allocate more memory */
        -:   78:};
        -:   79:
        -:   80:static int try_read_command_negotiate(conn *c);
        -:   81:static int try_read_command_udp(conn *c);
        -:   82:
        -:   83:static enum try_read_result try_read_network(conn *c);
        -:   84:static enum try_read_result try_read_udp(conn *c);
        -:   85:
        -:   86:static int start_conn_timeout_thread(void);
        -:   87:
        -:   88:/* stats */
        -:   89:static void stats_init(void);
        -:   90:static void conn_to_str(const conn *c, char *addr, char *svr_addr);
        -:   91:
        -:   92:/* defaults */
        -:   93:static void settings_init(void);
        -:   94:
        -:   95:/* event handling, network IO */
        -:   96:static void event_handler(const evutil_socket_t fd, const short which, void *arg);
        -:   97:static void conn_close(conn *c);
        -:   98:static void conn_init(void);
        -:   99:static bool update_event(conn *c, const int new_flags);
        -:  100:static void complete_nread(conn *c);
        -:  101:
        -:  102:static void conn_free(conn *c);
        -:  103:
        -:  104:/** exported globals **/
        -:  105:struct stats stats;
        -:  106:struct stats_state stats_state;
        -:  107:struct settings settings;
        -:  108:time_t process_started;     /* when the process was started */
        -:  109:conn **conns;
        -:  110:
        -:  111:#ifdef EXTSTORE
        -:  112:/* hoping this is temporary; I'd prefer to cut globals, but will complete this
        -:  113: * battle another day.
        -:  114: */
        -:  115:void *ext_storage = NULL;
        -:  116:#endif
        -:  117:/** file scope variables **/
        -:  118:static conn *listen_conn = NULL;
        -:  119:static int max_fds;
        -:  120:static struct event_base *main_base;
        -:  121:
        -:  122:enum transmit_result {
        -:  123:    TRANSMIT_COMPLETE,   /** All done writing. */
        -:  124:    TRANSMIT_INCOMPLETE, /** More data remaining to write. */
        -:  125:    TRANSMIT_SOFT_ERROR, /** Can't write any more right now. */
        -:  126:    TRANSMIT_HARD_ERROR  /** Can't write (c->state is set to conn_closing) */
        -:  127:};
        -:  128:
        -:  129:/* Default methods to read from/ write to a socket */
   631902:  130:ssize_t tcp_read(conn *c, void *buf, size_t count) {
  631902*:  131:    assert (c != NULL);
   631902:  132:    return read(c->sfd, buf, count);
        -:  133:}
        -:  134:
   428447:  135:ssize_t tcp_sendmsg(conn *c, struct msghdr *msg, int flags) {
  428447*:  136:    assert (c != NULL);
   428447:  137:    return sendmsg(c->sfd, msg, flags);
        -:  138:}
        -:  139:
     4041:  140:ssize_t tcp_write(conn *c, void *buf, size_t count) {
    4041*:  141:    assert (c != NULL);
     4041:  142:    return write(c->sfd, buf, count);
        -:  143:}
        -:  144:
        -:  145:static enum transmit_result transmit(conn *c);
        -:  146:
        -:  147:/* This reduces the latency without adding lots of extra wiring to be able to
        -:  148: * notify the listener thread of when to listen again.
        -:  149: * Also, the clock timer could be broken out into its own thread and we
        -:  150: * can block the listener via a condition.
        -:  151: */
        -:  152:static volatile bool allow_new_conns = true;
        -:  153:static int stop_main_loop = NOT_STOP;
        -:  154:static struct event maxconnsevent;
    #####:  155:static void maxconns_handler(const evutil_socket_t fd, const short which, void *arg) {
    #####:  156:    struct timeval t = {.tv_sec = 0, .tv_usec = 10000};
        -:  157:
    #####:  158:    if (fd == -42 || allow_new_conns == false) {
        -:  159:        /* reschedule in 10ms if we need to keep polling */
    #####:  160:        evtimer_set(&maxconnsevent, maxconns_handler, 0);
    #####:  161:        event_base_set(main_base, &maxconnsevent);
    #####:  162:        evtimer_add(&maxconnsevent, &t);
        -:  163:    } else {
    #####:  164:        evtimer_del(&maxconnsevent);
    #####:  165:        accept_new_conns(true);
        -:  166:    }
    #####:  167:}
        -:  168:
        -:  169:/*
        -:  170: * given time value that's either unix time or delta from current unix time, return
        -:  171: * unix time. Use the fact that delta can't exceed one month (and real time value can't
        -:  172: * be that low).
        -:  173: */
   362109:  174:rel_time_t realtime(const time_t exptime) {
        -:  175:    /* no. of seconds in 30 days - largest possible delta exptime */
        -:  176:
   362109:  177:    if (exptime == 0) return 0; /* 0 means never expire */
        -:  178:
     2475:  179:    if (exptime > REALTIME_MAXDELTA) {
        -:  180:        /* if item expiration is at/before the server started, give it an
        -:  181:           expiration time of 1 second after the server started.
        -:  182:           (because 0 means don't expire).  without this, we'd
        -:  183:           underflow and wrap around to some large value way in the
        -:  184:           future, effectively making items expiring in the past
        -:  185:           really expiring never */
       13:  186:        if (exptime <= process_started)
        -:  187:            return (rel_time_t)1;
        8:  188:        return (rel_time_t)(exptime - process_started);
        -:  189:    } else {
     2462:  190:        return (rel_time_t)(exptime + current_time);
        -:  191:    }
        -:  192:}
        -:  193:
      123:  194:static void stats_init(void) {
      123:  195:    memset(&stats, 0, sizeof(struct stats));
      123:  196:    memset(&stats_state, 0, sizeof(struct stats_state));
      123:  197:    stats_state.accepting_conns = true; /* assuming we start in this state. */
        -:  198:
        -:  199:    /* make the time we started always be 2 seconds before we really
        -:  200:       did, so time(0) - time.started is never zero.  if so, things
        -:  201:       like 'settings.oldest_live' which act as booleans as well as
        -:  202:       values are now false in boolean context... */
      123:  203:    process_started = time(0) - ITEM_UPDATE_INTERVAL - 2;
      123:  204:    stats_prefix_init(settings.prefix_delimiter);
      123:  205:}
        -:  206:
        3:  207:void stats_reset(void) {
        3:  208:    STATS_LOCK();
        3:  209:    memset(&stats, 0, sizeof(struct stats));
        3:  210:    stats_prefix_clear();
        3:  211:    STATS_UNLOCK();
        3:  212:    threadlocal_stats_reset();
        3:  213:    item_stats_reset();
        3:  214:}
        -:  215:
      450:  216:static void settings_init(void) {
      450:  217:    settings.use_cas = true;
      450:  218:    settings.access = 0700;
      450:  219:    settings.port = 11211;
      450:  220:    settings.udpport = 0;
      450:  221:    ssl_init_settings();
        -:  222:    /* By default this string should be NULL for getaddrinfo() */
      450:  223:    settings.inter = NULL;
      450:  224:    settings.maxbytes = 64 * 1024 * 1024; /* default is 64MB */
      450:  225:    settings.maxconns = 1024;         /* to limit connections-related memory to about 5MB */
      450:  226:    settings.verbose = 0;
      450:  227:    settings.oldest_live = 0;
      450:  228:    settings.evict_to_free = 1;       /* push old items out of cache when memory runs out */
      450:  229:    settings.socketpath = NULL;       /* by default, not using a unix socket */
      450:  230:    settings.auth_file = NULL;        /* by default, not using ASCII authentication tokens */
      450:  231:    settings.factor = 1.25;
      450:  232:    settings.chunk_size = 48;         /* space for a modest key and value */
      450:  233:    settings.num_threads = 4;         /* N workers */
      450:  234:    settings.num_threads_per_udp = 0;
      450:  235:    settings.prefix_delimiter = ':';
      450:  236:    settings.detail_enabled = 0;
      450:  237:    settings.reqs_per_event = 20;
      450:  238:    settings.backlog = 1024;
      450:  239:    settings.binding_protocol = negotiating_prot;
      450:  240:    settings.item_size_max = 1024 * 1024; /* The famous 1MB upper limit. */
      450:  241:    settings.slab_page_size = 1024 * 1024; /* chunks are split from 1MB pages. */
      450:  242:    settings.slab_chunk_size_max = settings.slab_page_size / 2;
      450:  243:    settings.sasl = false;
      450:  244:    settings.maxconns_fast = true;
      450:  245:    settings.lru_crawler = false;
      450:  246:    settings.lru_crawler_sleep = 100;
      450:  247:    settings.lru_crawler_tocrawl = 0;
      450:  248:    settings.lru_maintainer_thread = false;
      450:  249:    settings.lru_segmented = true;
      450:  250:    settings.hot_lru_pct = 20;
      450:  251:    settings.warm_lru_pct = 40;
      450:  252:    settings.hot_max_factor = 0.2;
      450:  253:    settings.warm_max_factor = 2.0;
      450:  254:    settings.temp_lru = false;
      450:  255:    settings.temporary_ttl = 61;
      450:  256:    settings.idle_timeout = 0; /* disabled */
      450:  257:    settings.hashpower_init = 0;
      450:  258:    settings.slab_reassign = true;
      450:  259:    settings.slab_automove = 1;
      450:  260:    settings.slab_automove_version = 0;
      450:  261:    settings.slab_automove_ratio = 0.8;
      450:  262:    settings.slab_automove_window = 10;
      450:  263:    settings.shutdown_command = false;
      450:  264:    settings.tail_repair_time = TAIL_REPAIR_TIME_DEFAULT;
      450:  265:    settings.flush_enabled = true;
      450:  266:    settings.dump_enabled = true;
      450:  267:    settings.crawls_persleep = 1000;
      450:  268:    settings.logger_watcher_buf_size = LOGGER_WATCHER_BUF_SIZE;
      450:  269:    settings.logger_buf_size = LOGGER_BUF_SIZE;
      450:  270:    settings.drop_privileges = false;
      450:  271:    settings.watch_enabled = true;
      450:  272:    settings.read_buf_mem_limit = 0;
        -:  273:#ifdef MEMCACHED_DEBUG
      450:  274:    settings.relaxed_privileges = false;
        -:  275:#endif
      450:  276:    settings.num_napi_ids = 0;
      450:  277:    settings.memory_file = NULL;
        -:  278:#ifdef SOCK_COOKIE_ID
      450:  279:    settings.sock_cookie_id = 0;
        -:  280:#endif
      450:  281:}
        -:  282:
        -:  283:extern pthread_mutex_t conn_lock;
        -:  284:
        -:  285:/* Connection timeout thread bits */
        -:  286:static pthread_t conn_timeout_tid;
        -:  287:static int do_run_conn_timeout_thread;
        -:  288:static pthread_cond_t conn_timeout_cond = PTHREAD_COND_INITIALIZER;
        -:  289:static pthread_mutex_t conn_timeout_lock = PTHREAD_MUTEX_INITIALIZER;
        -:  290:
        -:  291:#define CONNS_PER_SLICE 100
        1:  292:static void *conn_timeout_thread(void *arg) {
        1:  293:    int i;
        1:  294:    conn *c;
        1:  295:    rel_time_t oldest_last_cmd;
        1:  296:    int sleep_time;
        1:  297:    int sleep_slice = max_fds / CONNS_PER_SLICE;
        1:  298:    if (sleep_slice == 0)
    #####:  299:        sleep_slice = CONNS_PER_SLICE;
        -:  300:
        1:  301:    useconds_t timeslice = 1000000 / sleep_slice;
        -:  302:
        1:  303:    mutex_lock(&conn_timeout_lock);
        4:  304:    while(do_run_conn_timeout_thread) {
        4:  305:        if (settings.verbose > 2)
    #####:  306:            fprintf(stderr, "idle timeout thread at top of connection list\n");
        -:  307:
        4:  308:        oldest_last_cmd = current_time;
        -:  309:
     4100:  310:        for (i = 0; i < max_fds; i++) {
     4096:  311:            if ((i % CONNS_PER_SLICE) == 0) {
       44:  312:                if (settings.verbose > 2)
    #####:  313:                    fprintf(stderr, "idle timeout thread sleeping for %ulus\n",
        -:  314:                        (unsigned int)timeslice);
       44:  315:                usleep(timeslice);
        -:  316:            }
        -:  317:
     4096:  318:            if (!conns[i])
     4073:  319:                continue;
        -:  320:
       23:  321:            c = conns[i];
        -:  322:
       23:  323:            if (!IS_TCP(c->transport))
       16:  324:                continue;
        -:  325:
        7:  326:            if (c->state != conn_new_cmd && c->state != conn_read)
        5:  327:                continue;
        -:  328:
        2:  329:            if ((current_time - c->last_cmd_time) > settings.idle_timeout) {
        1:  330:                timeout_conn(c);
        -:  331:            } else {
        1:  332:                if (c->last_cmd_time < oldest_last_cmd)
     4096:  333:                    oldest_last_cmd = c->last_cmd_time;
        -:  334:            }
        -:  335:        }
        -:  336:
        -:  337:        /* This is the soonest we could have another connection time out */
        4:  338:        sleep_time = settings.idle_timeout - (current_time - oldest_last_cmd) + 1;
        4:  339:        if (sleep_time <= 0)
        -:  340:            sleep_time = 1;
        -:  341:
        4:  342:        if (settings.verbose > 2)
    #####:  343:            fprintf(stderr,
        -:  344:                    "idle timeout thread finished pass, sleeping for %ds\n",
        -:  345:                    sleep_time);
        -:  346:
        4:  347:        struct timeval now;
        4:  348:        struct timespec to_sleep;
        4:  349:        gettimeofday(&now, NULL);
        4:  350:        to_sleep.tv_sec = now.tv_sec + sleep_time;
        4:  351:        to_sleep.tv_nsec = 0;
        -:  352:
        4:  353:        pthread_cond_timedwait(&conn_timeout_cond, &conn_timeout_lock, &to_sleep);
        -:  354:    }
        -:  355:
    #####:  356:    mutex_unlock(&conn_timeout_lock);
    #####:  357:    return NULL;
        -:  358:}
        -:  359:
        1:  360:static int start_conn_timeout_thread(void) {
        1:  361:    int ret;
        -:  362:
        1:  363:    if (settings.idle_timeout == 0)
        -:  364:        return -1;
        -:  365:
        1:  366:    do_run_conn_timeout_thread = 1;
        1:  367:    if ((ret = pthread_create(&conn_timeout_tid, NULL,
        -:  368:        conn_timeout_thread, NULL)) != 0) {
    #####:  369:        fprintf(stderr, "Can't create idle connection timeout thread: %s\n",
        -:  370:            strerror(ret));
    #####:  371:        return -1;
        -:  372:    }
        1:  373:    thread_setname(conn_timeout_tid, "mc-idletimeout");
        -:  374:
        1:  375:    return 0;
        -:  376:}
        -:  377:
        2:  378:int stop_conn_timeout_thread(void) {
        2:  379:    if (!do_run_conn_timeout_thread)
        -:  380:        return -1;
    #####:  381:    mutex_lock(&conn_timeout_lock);
    #####:  382:    do_run_conn_timeout_thread = 0;
    #####:  383:    pthread_cond_signal(&conn_timeout_cond);
    #####:  384:    mutex_unlock(&conn_timeout_lock);
    #####:  385:    pthread_join(conn_timeout_tid, NULL);
    #####:  386:    return 0;
        -:  387:}
        -:  388:
        -:  389:/*
        -:  390: * read buffer cache helper functions
        -:  391: */
   502189:  392:static void rbuf_release(conn *c) {
   502189:  393:    if (c->rbuf != NULL && c->rbytes == 0 && !IS_UDP(c->transport)) {
   496331:  394:        if (c->rbuf_malloced) {
        3:  395:            free(c->rbuf);
        3:  396:            c->rbuf_malloced = false;
        -:  397:        } else {
   496328:  398:            do_cache_free(c->thread->rbuf_cache, c->rbuf);
        -:  399:        }
   496331:  400:        c->rsize = 0;
   496331:  401:        c->rbuf = NULL;
   496331:  402:        c->rcurr = NULL;
        -:  403:    }
   502189:  404:}
        -:  405:
   500022:  406:static bool rbuf_alloc(conn *c) {
   500022:  407:    if (c->rbuf == NULL) {
   496331:  408:        c->rbuf = do_cache_alloc(c->thread->rbuf_cache);
   496331:  409:        if (!c->rbuf) {
    #####:  410:            THR_STATS_LOCK(c->thread);
    #####:  411:            c->thread->stats.read_buf_oom++;
    #####:  412:            THR_STATS_UNLOCK(c->thread);
    #####:  413:            return false;
        -:  414:        }
   496331:  415:        c->rsize = READ_BUFFER_SIZE;
   496331:  416:        c->rcurr = c->rbuf;
        -:  417:    }
        -:  418:    return true;
        -:  419:}
        -:  420:
        -:  421:// Just for handling huge ASCII multigets.
        -:  422:// The previous system was essentially the same; realloc'ing until big enough,
        -:  423:// then realloc'ing back down after the request finished.
        3:  424:bool rbuf_switch_to_malloc(conn *c) {
        -:  425:    // Might as well start with x2 and work from there.
        3:  426:    size_t size = c->rsize * 2;
        3:  427:    char *tmp = malloc(size);
        3:  428:    if (!tmp)
        -:  429:        return false;
        -:  430:
        3:  431:    memcpy(tmp, c->rcurr, c->rbytes);
        3:  432:    do_cache_free(c->thread->rbuf_cache, c->rbuf);
        -:  433:
        3:  434:    c->rcurr = c->rbuf = tmp;
        3:  435:    c->rsize = size;
        3:  436:    c->rbuf_malloced = true;
        3:  437:    return true;
        -:  438:}
        -:  439:
        -:  440:/*
        -:  441: * Initializes the connections array. We don't actually allocate connection
        -:  442: * structures until they're needed, so as to avoid wasting memory when the
        -:  443: * maximum connection count is much higher than the actual number of
        -:  444: * connections.
        -:  445: *
        -:  446: * This does end up wasting a few pointers' worth of memory for FDs that are
        -:  447: * used for things other than connections, but that's worth it in exchange for
        -:  448: * being able to directly index the conns array by FD.
        -:  449: */
      123:  450:static void conn_init(void) {
        -:  451:    /* We're unlikely to see an FD much higher than maxconns. */
      123:  452:    int next_fd = dup(1);
      123:  453:    if (next_fd < 0) {
    #####:  454:        perror("Failed to duplicate file descriptor\n");
    #####:  455:        exit(1);
        -:  456:    }
      123:  457:    int headroom = 10;      /* account for extra unexpected open FDs */
      123:  458:    struct rlimit rl;
        -:  459:
      123:  460:    max_fds = settings.maxconns + headroom + next_fd;
        -:  461:
        -:  462:    /* But if possible, get the actual highest FD we can possibly ever see. */
      123:  463:    if (getrlimit(RLIMIT_NOFILE, &rl) == 0) {
      123:  464:        max_fds = rl.rlim_max;
        -:  465:    } else {
    #####:  466:        fprintf(stderr, "Failed to query maximum file descriptor; "
        -:  467:                        "falling back to maxconns\n");
        -:  468:    }
        -:  469:
      123:  470:    close(next_fd);
        -:  471:
      123:  472:    if ((conns = calloc(max_fds, sizeof(conn *))) == NULL) {
    #####:  473:        fprintf(stderr, "Failed to allocate connection structures\n");
        -:  474:        /* This is unrecoverable so bail out early. */
    #####:  475:        exit(1);
        -:  476:    }
      123:  477:}
        -:  478:
     344*:  479:static const char *prot_text(enum protocol prot) {
     344*:  480:    char *rv = "unknown";
     344*:  481:    switch(prot) {
       2*:  482:        case ascii_prot:
       2*:  483:            rv = "ascii";
       2*:  484:            break;
       1*:  485:        case binary_prot:
       1*:  486:            rv = "binary";
       1*:  487:            break;
     341*:  488:        case negotiating_prot:
     341*:  489:            rv = "auto-negotiate";
     341*:  490:            break;
        -:  491:#ifdef PROXY
        -:  492:        case proxy_prot:
        -:  493:            rv = "proxy";
        -:  494:            break;
        -:  495:#endif
        -:  496:    }
     344*:  497:    return rv;
        -:  498:}
        -:  499:
        1:  500:void conn_close_idle(conn *c) {
        1:  501:    if (settings.idle_timeout > 0 &&
        1:  502:        (current_time - c->last_cmd_time) > settings.idle_timeout) {
        1:  503:        if (c->state != conn_new_cmd && c->state != conn_read) {
    #####:  504:            if (settings.verbose > 1)
    #####:  505:                fprintf(stderr,
        -:  506:                    "fd %d wants to timeout, but isn't in read state", c->sfd);
    #####:  507:            return;
        -:  508:        }
        -:  509:
        1:  510:        if (settings.verbose > 1)
    #####:  511:            fprintf(stderr, "Closing idle fd %d\n", c->sfd);
        -:  512:
        1:  513:        pthread_mutex_lock(&c->thread->stats.mutex);
        1:  514:        c->thread->stats.idle_kicks++;
        1:  515:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -:  516:
        1:  517:        c->close_reason = IDLE_TIMEOUT_CLOSE;
        -:  518:
        1:  519:        conn_set_state(c, conn_closing);
        1:  520:        drive_machine(c);
        -:  521:    }
        -:  522:}
        -:  523:
        3:  524:static void _conn_event_readd(conn *c) {
        3:  525:    c->ev_flags = EV_READ | EV_PERSIST;
        3:  526:    event_set(&c->event, c->sfd, c->ev_flags, event_handler, (void *)c);
        3:  527:    event_base_set(c->thread->base, &c->event);
        -:  528:
        -:  529:    // TODO: call conn_cleanup/fail/etc
        3:  530:    if (event_add(&c->event, 0) == -1) {
    #####:  531:        perror("event_add");
        -:  532:    }
        3:  533:}
        -:  534:
        -:  535:/* bring conn back from a sidethread. could have had its event base moved. */
     1606:  536:void conn_worker_readd(conn *c) {
    1606*:  537:    assert(c->resps_suspended == 0); // TODO: remove assert.
        -:  538:
     1606:  539:    switch (c->state) {
       11:  540:        case conn_closing:
       11:  541:            drive_machine(c);
       11:  542:            break;
        1:  543:        case conn_io_pending:
        -:  544:            // The event listener was removed as more data showed up while
        -:  545:            // waiting for the async response.
        1:  546:            _conn_event_readd(c);
        -:  547:            // Explicit fall-through.
     1593:  548:        case conn_io_queue:
     1593:  549:            conn_set_state(c, conn_io_resume);
        -:  550:            // schedule the event, which just runs drive_machine outside of
        -:  551:            // any recursion here.
     1593:  552:            event_active(&c->event, 0, 0);
     1593:  553:            break;
        -:  554:        case conn_write:
        -:  555:        case conn_mwrite:
        -:  556:        case conn_read:
        -:  557:        case conn_parse_cmd:
        -:  558:            // No-ops if we weren't in a suspended state to begin with
        -:  559:            // TODO: which other states for this?
        -:  560:            break;
        2:  561:        default:
        2:  562:            event_del(&c->event);
        2:  563:            _conn_event_readd(c);
        2:  564:            conn_set_state(c, conn_new_cmd);
        -:  565:    }
        -:  566:
     1606:  567:}
        -:  568:
      564:  569:void thread_io_queue_add(LIBEVENT_THREAD *t, int type, void *ctx, io_queue_stack_cb cb) {
      564:  570:    io_queue_t *q = t->io_queues;
      612:  571:    while (q->type != IO_QUEUE_NONE) {
       48:  572:        q++;
        -:  573:    }
      564:  574:    q->type = type;
      564:  575:    q->ctx = ctx;
      564:  576:    q->submit_cb = cb;
      564:  577:    STAILQ_INIT(&q->stack);
      564:  578:    return;
        -:  579:}
        -:  580:
     1602:  581:io_queue_t *thread_io_queue_get(LIBEVENT_THREAD *t, int type) {
     1602:  582:    io_queue_t *q = t->io_queues;
     1602:  583:    while (q->type != IO_QUEUE_NONE) {
     1602:  584:        if (q->type == type) {
     1602:  585:            return q;
        -:  586:        }
    #####:  587:        q++;
        -:  588:    }
        -:  589:    return NULL;
        -:  590:}
        -:  591:
   522692:  592:void thread_io_queue_submit(LIBEVENT_THREAD *t) {
   522692:  593:    t->conns_tosubmit = 0;
   592668:  594:    for (io_queue_t *q = t->io_queues; q->type != IO_QUEUE_NONE; q++) {
        -:  595:        // submission callback must consume the queue
    69976:  596:        if (!STAILQ_EMPTY(&q->stack)) {
     1593:  597:            q->submit_cb(q);
    1593*:  598:            assert(STAILQ_EMPTY(&q->stack));
        -:  599:        }
        -:  600:    }
   522692:  601:}
        -:  602:
        -:  603:// called to return a single IO object to the original worker thread.
     1595:  604:void conn_io_queue_return(io_pending_t *io) {
     1595:  605:    io->return_cb(io);
     1595:  606:}
        -:  607:
     2341:  608:conn *conn_new(const int sfd, enum conn_states init_state,
        -:  609:                const int event_flags,
        -:  610:                const int read_buffer_size, enum network_transport transport,
        -:  611:                struct event_base *base, void *ssl, uint64_t conntag,
        -:  612:                enum protocol bproto) {
     2341:  613:    conn *c;
        -:  614:
    2341*:  615:    assert(sfd >= 0 && sfd < max_fds);
     2341:  616:    c = conns[sfd];
        -:  617:
     2341:  618:    if (NULL == c) {
     2329:  619:        if (!(c = (conn *)calloc(1, sizeof(conn)))) {
    #####:  620:            STATS_LOCK();
    #####:  621:            stats.malloc_fails++;
    #####:  622:            STATS_UNLOCK();
    #####:  623:            fprintf(stderr, "Failed to allocate connection object\n");
    #####:  624:            return NULL;
        -:  625:        }
     2329:  626:        MEMCACHED_CONN_CREATE(c);
     2329:  627:        c->read = NULL;
     2329:  628:        c->sendmsg = NULL;
     2329:  629:        c->write = NULL;
     2329:  630:        c->rbuf = NULL;
        -:  631:
     2329:  632:        c->rsize = read_buffer_size;
        -:  633:
        -:  634:        // UDP connections use a persistent static buffer.
     2329:  635:        if (c->rsize) {
      205:  636:            c->rbuf = (char *)malloc((size_t)c->rsize);
        -:  637:        }
        -:  638:
     2329:  639:        if (c->rsize && c->rbuf == NULL) {
    #####:  640:            conn_free(c);
    #####:  641:            STATS_LOCK();
    #####:  642:            stats.malloc_fails++;
    #####:  643:            STATS_UNLOCK();
    #####:  644:            fprintf(stderr, "Failed to allocate buffers for connection\n");
    #####:  645:            return NULL;
        -:  646:        }
        -:  647:
        -:  648:
     2329:  649:        STATS_LOCK();
     2329:  650:        stats_state.conn_structs++;
     2329:  651:        STATS_UNLOCK();
        -:  652:
     2329:  653:        c->sfd = sfd;
     2329:  654:        conns[sfd] = c;
        -:  655:    }
        -:  656:
     2341:  657:    c->transport = transport;
     2341:  658:    c->protocol = bproto;
     2341:  659:    c->tag = conntag;
        -:  660:
        -:  661:    /* unix socket mode doesn't need this, so zeroed out.  but why
        -:  662:     * is this done for every command?  presumably for UDP
        -:  663:     * mode.  */
     2341:  664:    if (!settings.socketpath) {
      124:  665:        c->request_addr_size = sizeof(c->request_addr);
        -:  666:    } else {
     2217:  667:        c->request_addr_size = 0;
        -:  668:    }
        -:  669:
     2341:  670:    if (transport == tcp_transport && init_state == conn_new_cmd) {
       20:  671:        if (getpeername(sfd, (struct sockaddr *) &c->request_addr,
        -:  672:                        &c->request_addr_size)) {
    #####:  673:            perror("getpeername");
    #####:  674:            memset(&c->request_addr, 0, sizeof(c->request_addr));
        -:  675:        }
        -:  676:    }
        -:  677:
     2341:  678:    if (init_state == conn_new_cmd) {
     2136:  679:        LOGGER_LOG(NULL, LOG_CONNEVENTS, LOGGER_CONNECTION_NEW, NULL,
        -:  680:                &c->request_addr, c->request_addr_size, c->transport, 0, sfd);
        -:  681:    }
        -:  682:
     2341:  683:    if (settings.verbose > 1) {
        6:  684:        if (init_state == conn_listening) {
        6:  685:            fprintf(stderr, "<%d server listening (%s)\n", sfd,
        -:  686:                prot_text(c->protocol));
        3:  687:        } else if (IS_UDP(transport)) {
    #####:  688:            fprintf(stderr, "<%d server listening (udp)\n", sfd);
        3:  689:        } else if (c->protocol == negotiating_prot) {
        1:  690:            fprintf(stderr, "<%d new auto-negotiating client connection\n",
        -:  691:                    sfd);
        2:  692:        } else if (c->protocol == ascii_prot) {
        1:  693:            fprintf(stderr, "<%d new ascii client connection.\n", sfd);
        1:  694:        } else if (c->protocol == binary_prot) {
        1:  695:            fprintf(stderr, "<%d new binary client connection.\n", sfd);
        -:  696:#ifdef PROXY
        -:  697:        } else if (c->protocol == proxy_prot) {
        -:  698:            fprintf(stderr, "<%d new proxy client connection.\n", sfd);
        -:  699:#endif
        -:  700:        } else {
    #####:  701:            fprintf(stderr, "<%d new unknown (%d) client connection\n",
        -:  702:                sfd, c->protocol);
    #####:  703:            assert(false);
        -:  704:        }
        -:  705:    }
        -:  706:
     2341:  707:    c->state = init_state;
     2341:  708:    c->rlbytes = 0;
     2341:  709:    c->cmd = -1;
     2341:  710:    c->rbytes = 0;
     2341:  711:    c->rcurr = c->rbuf;
     2341:  712:    c->ritem = 0;
     2341:  713:    c->rbuf_malloced = false;
     2341:  714:    c->item_malloced = false;
     2341:  715:    c->sasl_started = false;
     2341:  716:    c->set_stale = false;
     2341:  717:    c->mset_res = false;
     2341:  718:    c->close_after_write = false;
     2341:  719:    c->last_cmd_time = current_time; /* initialize for idle kicker */
    2341*:  720:    assert(c->resps_suspended == 0);
        -:  721:
     2341:  722:    c->item = 0;
     2341:  723:    c->ssl = NULL;
        -:  724:#ifdef TLS
        -:  725:    c->ssl_wbuf = NULL;
        -:  726:#endif
        -:  727:
     2341:  728:    c->noreply = false;
        -:  729:
     2341:  730:    if (ssl) {
        -:  731:        // musn't get here without ssl enabled.
    #####:  732:        assert(settings.ssl_enabled);
    #####:  733:        ssl_init_conn(c, ssl);
    #####:  734:        c->ssl_enabled = true;
        -:  735:    } else {
     2341:  736:        c->read = tcp_read;
     2341:  737:        c->sendmsg = tcp_sendmsg;
     2341:  738:        c->write = tcp_write;
     2341:  739:        c->ssl_enabled = false;
        -:  740:    }
        -:  741:
     2341:  742:    if (IS_UDP(transport)) {
       72:  743:        c->try_read_command = try_read_command_udp;
        -:  744:    } else {
     2269:  745:        switch (c->protocol) {
        9:  746:            case ascii_prot:
        9:  747:                if (settings.auth_file == NULL) {
        4:  748:                    c->authenticated = true;
        4:  749:                    c->try_read_command = try_read_command_ascii;
        -:  750:                } else {
        5:  751:                    c->authenticated = false;
        5:  752:                    c->try_read_command = try_read_command_asciiauth;
        -:  753:                }
        -:  754:                break;
        6:  755:            case binary_prot:
        -:  756:                // binprot handles its own authentication via SASL parsing.
        6:  757:                c->authenticated = false;
        6:  758:                c->try_read_command = try_read_command_binary;
        6:  759:                break;
     2254:  760:            case negotiating_prot:
     2254:  761:                c->try_read_command = try_read_command_negotiate;
     2254:  762:                break;
        -:  763:#ifdef PROXY
        -:  764:            case proxy_prot:
        -:  765:                c->try_read_command = try_read_command_proxy;
        -:  766:                break;
        -:  767:#endif
        -:  768:        }
        -:  769:    }
        -:  770:
     2341:  771:    event_set(&c->event, sfd, event_flags, event_handler, (void *)c);
     2341:  772:    event_base_set(base, &c->event);
     2341:  773:    c->ev_flags = event_flags;
        -:  774:
     2341:  775:    if (event_add(&c->event, 0) == -1) {
    #####:  776:        perror("event_add");
    #####:  777:        return NULL;
        -:  778:    }
        -:  779:
     2341:  780:    STATS_LOCK();
     2341:  781:    stats_state.curr_conns++;
     2341:  782:    stats.total_conns++;
     2341:  783:    STATS_UNLOCK();
        -:  784:
     2341:  785:    MEMCACHED_CONN_ALLOCATE(c->sfd);
        -:  786:
     2341:  787:    return c;
        -:  788:}
        -:  789:
   508015:  790:void conn_release_items(conn *c) {
  508015*:  791:    assert(c != NULL);
        -:  792:
   508015:  793:    if (c->item) {
        2:  794:        if (c->item_malloced) {
    #####:  795:            free(c->item);
    #####:  796:            c->item_malloced = false;
        -:  797:        } else {
        2:  798:            item_remove(c->item);
        -:  799:        }
        2:  800:        c->item = 0;
        -:  801:    }
        -:  802:
        -:  803:    // Cull any unsent responses.
   508015:  804:    if (c->resp_head) {
        -:  805:        mc_resp *resp = c->resp_head;
        -:  806:        // r_f() handles the chain maintenance.
      122:  807:        while (resp) {
        -:  808:            // temporary by default. hide behind a debug flag in the future:
        -:  809:            // double free detection. Transmit loops can drop out early, but
        -:  810:            // here we could infinite loop.
       94:  811:            if (resp->free) {
    #####:  812:                fprintf(stderr, "ERROR: double free detected during conn_release_items(): [%d] [%s]\n",
    #####:  813:                        c->sfd, c->protocol == binary_prot ? "binary" : "ascii");
        -:  814:                // Since this is a critical failure, just leak the memory.
        -:  815:                // If these errors are seen, an abort() can be used instead.
    #####:  816:                c->resp_head = NULL;
    #####:  817:                c->resp = NULL;
    #####:  818:                break;
        -:  819:            }
       94:  820:            resp = resp_finish(c, resp);
        -:  821:        }
        -:  822:    }
   508015:  823:}
        -:  824:
     2137:  825:static void conn_cleanup(conn *c) {
    2137*:  826:    assert(c != NULL);
        -:  827:
     2137:  828:    conn_release_items(c);
        -:  829:#ifdef PROXY
        -:  830:    if (c->proxy_rctx) {
        -:  831:        proxy_cleanup_conn(c);
        -:  832:    }
        -:  833:#endif
     2137:  834:    if (c->sasl_conn) {
    #####:  835:        assert(settings.sasl);
    #####:  836:        sasl_dispose(&c->sasl_conn);
    #####:  837:        c->sasl_conn = NULL;
        -:  838:    }
        -:  839:
     2137:  840:    if (IS_UDP(c->transport)) {
    #####:  841:        conn_set_state(c, conn_read);
        -:  842:    }
     2137:  843:}
        -:  844:
        -:  845:/*
        -:  846: * Frees a connection.
        -:  847: */
    #####:  848:void conn_free(conn *c) {
    #####:  849:    if (c) {
    #####:  850:        assert(c != NULL);
    #####:  851:        assert(c->sfd >= 0 && c->sfd < max_fds);
        -:  852:
    #####:  853:        MEMCACHED_CONN_DESTROY(c);
    #####:  854:        conns[c->sfd] = NULL;
    #####:  855:        if (c->rbuf)
    #####:  856:            free(c->rbuf);
        -:  857:#ifdef TLS
        -:  858:        if (c->ssl_wbuf)
        -:  859:            c->ssl_wbuf = NULL;
        -:  860:#endif
        -:  861:
    #####:  862:        free(c);
        -:  863:    }
    #####:  864:}
        -:  865:
     2137:  866:static void conn_close(conn *c) {
    2137*:  867:    assert(c != NULL);
        -:  868:
     2137:  869:    if (c->thread) {
    2135*:  870:        LOGGER_LOG(c->thread->l, LOG_CONNEVENTS, LOGGER_CONNECTION_CLOSE, NULL,
        -:  871:                &c->request_addr, c->request_addr_size, c->transport,
        -:  872:                c->close_reason, c->sfd);
        -:  873:    }
        -:  874:
        -:  875:    /* delete the event, the socket and the conn */
     2137:  876:    event_del(&c->event);
        -:  877:
     2137:  878:    if (settings.verbose > 1)
        3:  879:        fprintf(stderr, "<%d connection closed.\n", c->sfd);
        -:  880:
     2137:  881:    conn_cleanup(c);
        -:  882:
        -:  883:    // force release of read buffer.
     2137:  884:    if (c->thread) {
     2135:  885:        c->rbytes = 0;
     2135:  886:        rbuf_release(c);
        -:  887:    }
        -:  888:
     2137:  889:    MEMCACHED_CONN_RELEASE(c->sfd);
     2137:  890:    conn_set_state(c, conn_closed);
     2137:  891:    if (c->ssl_enabled) {
     2137:  892:        ssl_conn_close(c->ssl);
        -:  893:    }
     2137:  894:    close(c->sfd);
     2137:  895:    c->close_reason = 0;
     2137:  896:    pthread_mutex_lock(&conn_lock);
     2137:  897:    allow_new_conns = true;
     2137:  898:    pthread_mutex_unlock(&conn_lock);
        -:  899:
     2137:  900:    STATS_LOCK();
     2137:  901:    stats_state.curr_conns--;
     2137:  902:    STATS_UNLOCK();
        -:  903:
     2137:  904:    return;
        -:  905:}
        -:  906:
        -:  907:// Since some connections might be off on side threads and some are managed as
        -:  908:// listeners we need to walk through them all from a central point.
        -:  909:// Must be called with all worker threads hung or in the process of closing.
        2:  910:void conn_close_all(void) {
        2:  911:    int i;
     2050:  912:    for (i = 0; i < max_fds; i++) {
     2048:  913:        if (conns[i] && conns[i]->state != conn_closed) {
        3:  914:            conn_close(conns[i]);
        -:  915:        }
        -:  916:    }
        2:  917:}
        -:  918:
        -:  919:/**
        -:  920: * Convert a state name to a human readable form.
        -:  921: */
       16:  922:static const char *state_text(enum conn_states state) {
       16:  923:    const char* const statenames[] = { "conn_listening",
        -:  924:                                       "conn_new_cmd",
        -:  925:                                       "conn_waiting",
        -:  926:                                       "conn_read",
        -:  927:                                       "conn_parse_cmd",
        -:  928:                                       "conn_write",
        -:  929:                                       "conn_nread",
        -:  930:                                       "conn_swallow",
        -:  931:                                       "conn_closing",
        -:  932:                                       "conn_mwrite",
        -:  933:                                       "conn_closed",
        -:  934:                                       "conn_watch",
        -:  935:                                       "conn_io_queue",
        -:  936:                                       "conn_io_resume",
        -:  937:                                       "conn_io_pending" };
       16:  938:    return statenames[state];
        -:  939:}
        -:  940:
        -:  941:/*
        -:  942: * Sets a connection's current state in the state machine. Any special
        -:  943: * processing that needs to happen on certain state transitions can
        -:  944: * happen here.
        -:  945: */
  3670306:  946:void conn_set_state(conn *c, enum conn_states state) {
 3670306*:  947:    assert(c != NULL);
 3670306*:  948:    assert(state >= conn_listening && state < conn_max_state);
        -:  949:
  3670306:  950:    if (state != c->state) {
  3670305:  951:        if (settings.verbose > 2) {
    #####:  952:            fprintf(stderr, "%d: going from %s to %s\n",
        -:  953:                    c->sfd, state_text(c->state),
        -:  954:                    state_text(state));
        -:  955:        }
        -:  956:
  3670305:  957:        if (state == conn_write || state == conn_mwrite) {
  3670305:  958:            MEMCACHED_PROCESS_COMMAND_END(c->sfd, c->resp->wbuf, c->resp->wbytes);
        -:  959:        }
  3670305:  960:        c->state = state;
        -:  961:    }
  3670306:  962:}
        -:  963:
        -:  964:/*
        -:  965: * response object helper functions
        -:  966: */
   495628:  967:void resp_reset(mc_resp *resp) {
   495628:  968:    if (resp->item) {
    #####:  969:        item_remove(resp->item);
    #####:  970:        resp->item = NULL;
        -:  971:    }
   495628:  972:    if (resp->write_and_free) {
        -:  973:#ifdef PROXY
        -:  974:        if (resp->proxy_res) {
        -:  975:            LIBEVENT_THREAD *t = resp->bundle->thread;
        -:  976:            pthread_mutex_lock(&t->proxy_limit_lock);
        -:  977:            t->proxy_buffer_memory_used -= resp->wbytes;
        -:  978:            pthread_mutex_unlock(&t->proxy_limit_lock);
        -:  979:        }
        -:  980:#endif
    #####:  981:        free(resp->write_and_free);
    #####:  982:        resp->write_and_free = NULL;
        -:  983:    }
   495628:  984:    resp->wbytes = 0;
   495628:  985:    resp->tosend = 0;
   495628:  986:    resp->iovcnt = 0;
   495628:  987:    resp->chunked_data_iov = 0;
   495628:  988:    resp->chunked_total = 0;
   495628:  989:    resp->skip = false;
   495628:  990:}
        -:  991:
   548946:  992:void resp_add_iov(mc_resp *resp, const void *buf, int len) {
  548946*:  993:    assert(resp->iovcnt < MC_RESP_IOVCOUNT);
   548946:  994:    int x = resp->iovcnt;
   548946:  995:    resp->iov[x].iov_base = (void *)buf;
   548946:  996:    resp->iov[x].iov_len = len;
   548946:  997:    resp->iovcnt++;
   548946:  998:    resp->tosend += len;
   548946:  999:}
        -: 1000:
        -: 1001:// Notes that an IOV should be handled as a chunked item header.
        -: 1002:// TODO: I'm hoping this isn't a permanent abstraction while I learn what the
        -: 1003:// API should be.
    18975: 1004:void resp_add_chunked_iov(mc_resp *resp, const void *buf, int len) {
    18975: 1005:    resp->chunked_data_iov = resp->iovcnt;
    18975: 1006:    resp->chunked_total = len;
    18975: 1007:    resp_add_iov(resp, buf, len);
    18975: 1008:}
        -: 1009:
        -: 1010:// resp_allocate and resp_free are a wrapper around read buffers which makes
        -: 1011:// read buffers the only network memory to track.
        -: 1012:// Normally this would be too excessive. In this case it allows end users to
        -: 1013:// track a single memory limit for ephemeral connection buffers.
        -: 1014:// Fancy bit twiddling tricks are avoided to help keep this straightforward.
   662766: 1015:static mc_resp* resp_allocate(conn *c) {
   662766: 1016:    LIBEVENT_THREAD *th = c->thread;
   662766: 1017:    mc_resp *resp = NULL;
   662766: 1018:    mc_resp_bundle *b = th->open_bundle;
        -: 1019:
   662766: 1020:    if (b != NULL) {
  656277*: 1021:        for (int i = 0; i < MAX_RESP_PER_BUNDLE; i++) {
        -: 1022:            // loop around starting from the most likely to be free
   656277: 1023:            int x = (i + b->next_check) % MAX_RESP_PER_BUNDLE;
   656277: 1024:            if (b->r[x].free) {
   656277: 1025:                resp = &b->r[x];
   656277: 1026:                b->next_check = x+1;
   656277: 1027:                break;
        -: 1028:            }
        -: 1029:        }
        -: 1030:
   656277: 1031:        if (resp != NULL) {
   656277: 1032:            b->refcount++;
   656277: 1033:            memset(resp, 0, sizeof(*resp));
   656277: 1034:            resp->free = false; // redundant, for clarity.
   656277: 1035:            resp->bundle = b;
   656277: 1036:            if (b->refcount == MAX_RESP_PER_BUNDLE) {
    6368*: 1037:                assert(b->prev == NULL);
        -: 1038:                // We only allocate off the head. Assign new head.
     6368: 1039:                th->open_bundle = b->next;
        -: 1040:                // Remove ourselves from the list.
     6368: 1041:                if (b->next) {
    #####: 1042:                    b->next->prev = 0;
    #####: 1043:                    b->next = 0;
        -: 1044:                }
        -: 1045:            }
        -: 1046:        }
        -: 1047:    }
        -: 1048:
        -: 1049:    if (resp == NULL) {
    6489*: 1050:        assert(th->open_bundle == NULL);
     6489: 1051:        b = do_cache_alloc(th->rbuf_cache);
     6489: 1052:        if (b) {
     6487: 1053:            THR_STATS_LOCK(th);
     6487: 1054:            th->stats.response_obj_bytes += READ_BUFFER_SIZE;
     6487: 1055:            THR_STATS_UNLOCK(th);
     6487: 1056:            b->next_check = 1;
     6487: 1057:            b->refcount = 1;
    90818: 1058:            for (int i = 0; i < MAX_RESP_PER_BUNDLE; i++) {
    84331: 1059:                b->r[i].free = true;
        -: 1060:            }
     6487: 1061:            b->next = 0;
     6487: 1062:            b->prev = 0;
     6487: 1063:            b->thread = th;
     6487: 1064:            th->open_bundle = b;
     6487: 1065:            resp = &b->r[0];
     6487: 1066:            memset(resp, 0, sizeof(*resp));
     6487: 1067:            resp->free = false; // redundant. for clarity.
     6487: 1068:            resp->bundle = b;
        -: 1069:        } else {
        -: 1070:            return NULL;
        -: 1071:        }
        -: 1072:    }
        -: 1073:
        -: 1074:    return resp;
        -: 1075:}
        -: 1076:
   662764: 1077:void resp_free(LIBEVENT_THREAD *th, mc_resp *resp) {
   662764: 1078:    mc_resp_bundle *b = resp->bundle;
        -: 1079:
   662764: 1080:    resp->free = true;
   662764: 1081:    b->refcount--;
   662764: 1082:    if (b->refcount == 0) {
   512257: 1083:        if (b == th->open_bundle && b->next == 0) {
        -: 1084:            // This is the final bundle. Just hold and reuse to skip init loop
  505900*: 1085:            assert(b->prev == 0);
   505900: 1086:            b->next_check = 0;
        -: 1087:        } else {
        -: 1088:            // Assert that we're either in the list or at the head.
    6357*: 1089:            assert((b->next || b->prev) || b == th->open_bundle);
        -: 1090:
        -: 1091:            // unlink from list.
     6357: 1092:            mc_resp_bundle **head = &th->open_bundle;
     6357: 1093:            if (*head == b) *head = b->next;
        -: 1094:            // Not tracking the tail.
    6357*: 1095:            assert(b->next != b && b->prev != b);
        -: 1096:
     6357: 1097:            if (b->next) b->next->prev = b->prev;
    6357*: 1098:            if (b->prev) b->prev->next = b->next;
        -: 1099:
        -: 1100:            // Now completely done with this buffer.
     6357: 1101:            do_cache_free(th->rbuf_cache, b);
     6357: 1102:            THR_STATS_LOCK(th);
     6357: 1103:            th->stats.response_obj_bytes -= READ_BUFFER_SIZE;
     6357: 1104:            THR_STATS_UNLOCK(th);
        -: 1105:        }
        -: 1106:    } else {
   150507: 1107:        mc_resp_bundle **head = &th->open_bundle;
        -: 1108:        // NOTE: since we're not tracking tail, latest free ends up in head.
   150507: 1109:        if (b == th->open_bundle || (b->prev || b->next)) {
        -: 1110:            // If we're already linked, leave it in place to save CPU.
        -: 1111:        } else {
        -: 1112:            // Non-zero refcount, need to link into the freelist.
     6368: 1113:            b->prev = 0;
     6368: 1114:            b->next = *head;
     6368: 1115:            if (b->next) b->next->prev = b;
     6368: 1116:            *head = b;
        -: 1117:        }
        -: 1118:
        -: 1119:    }
   662764: 1120:    THR_STATS_LOCK(th);
   662764: 1121:    th->stats.response_obj_count--;
   662764: 1122:    THR_STATS_UNLOCK(th);
   662764: 1123:}
        -: 1124:
   662766: 1125:bool resp_start(conn *c) {
   662766: 1126:    mc_resp *resp = resp_allocate(c);
   662766: 1127:    if (!resp) {
        2: 1128:        THR_STATS_LOCK(c->thread);
        2: 1129:        c->thread->stats.response_obj_oom++;
        2: 1130:        THR_STATS_UNLOCK(c->thread);
        2: 1131:        return false;
        -: 1132:    }
        -: 1133:
        -: 1134:    // handling the stats counters here to simplify testing
   662764: 1135:    THR_STATS_LOCK(c->thread);
   662764: 1136:    c->thread->stats.response_obj_count++;
   662764: 1137:    THR_STATS_UNLOCK(c->thread);
        -: 1138:
   662764: 1139:    if (!c->resp_head) {
   505902: 1140:        c->resp_head = resp;
        -: 1141:    }
   662764: 1142:    if (!c->resp) {
   505902: 1143:        c->resp = resp;
        -: 1144:    } else {
   156862: 1145:        c->resp->next = resp;
   156862: 1146:        c->resp = resp;
        -: 1147:    }
   662764: 1148:    if (IS_UDP(c->transport)) {
        -: 1149:        // need to hold on to some data for async responses.
       18: 1150:        c->resp->request_id = c->request_id;
       18: 1151:        c->resp->request_addr = c->request_addr;
       18: 1152:        c->resp->request_addr_size = c->request_addr_size;
        -: 1153:    }
        -: 1154:    return true;
        -: 1155:}
        -: 1156:
    #####: 1157:mc_resp *resp_start_unlinked(conn *c) {
    #####: 1158:    mc_resp *resp = resp_allocate(c);
    #####: 1159:    if (!resp) {
    #####: 1160:        THR_STATS_LOCK(c->thread);
    #####: 1161:        c->thread->stats.response_obj_oom++;
    #####: 1162:        THR_STATS_UNLOCK(c->thread);
    #####: 1163:        return false;
        -: 1164:    }
        -: 1165:
        -: 1166:    // handling the stats counters here to simplify testing
    #####: 1167:    THR_STATS_LOCK(c->thread);
    #####: 1168:    c->thread->stats.response_obj_count++;
    #####: 1169:    THR_STATS_UNLOCK(c->thread);
        -: 1170:
    #####: 1171:    if (IS_UDP(c->transport)) {
        -: 1172:        // need to hold on to some data for async responses.
    #####: 1173:        c->resp->request_id = c->request_id;
    #####: 1174:        c->resp->request_addr = c->request_addr;
    #####: 1175:        c->resp->request_addr_size = c->request_addr_size;
        -: 1176:    }
        -: 1177:
        -: 1178:    return resp;
        -: 1179:}
        -: 1180:
        -: 1181:// returns next response in chain.
   662764: 1182:mc_resp* resp_finish(conn *c, mc_resp *resp) {
   662764: 1183:    mc_resp *next = resp->next;
   662764: 1184:    if (resp->item) {
        -: 1185:        // TODO: cache hash value in resp obj?
    57601: 1186:        item_remove(resp->item);
    57601: 1187:        resp->item = NULL;
        -: 1188:    }
   662764: 1189:    if (resp->write_and_free) {
        -: 1190:#ifdef PROXY
        -: 1191:        if (resp->proxy_res) {
        -: 1192:            LIBEVENT_THREAD *t = resp->bundle->thread;
        -: 1193:            pthread_mutex_lock(&t->proxy_limit_lock);
        -: 1194:            t->proxy_buffer_memory_used -= resp->wbytes;
        -: 1195:            pthread_mutex_unlock(&t->proxy_limit_lock);
        -: 1196:        }
        -: 1197:#endif
    10141: 1198:        free(resp->write_and_free);
        -: 1199:    }
   662764: 1200:    if (resp->io_pending) {
     1598: 1201:        io_pending_t *io = resp->io_pending;
        -: 1202:        // If we had a pending IO, tell it to internally clean up then return
        -: 1203:        // the main object back to our thread cache.
     1598: 1204:        io->finalize_cb(io);
     1598: 1205:        do_cache_free(c->thread->io_cache, io);
     1598: 1206:        resp->io_pending = NULL;
        -: 1207:    }
   662764: 1208:    if (c->resp_head == resp) {
   662764: 1209:        c->resp_head = next;
        -: 1210:    }
   662764: 1211:    if (c->resp == resp) {
   505902: 1212:        c->resp = NULL;
        -: 1213:    }
   662764: 1214:    resp_free(c->thread, resp);
   662764: 1215:    return next;
        -: 1216:}
        -: 1217:
        -: 1218:// tells if connection has a depth of response objects to process.
       14: 1219:bool resp_has_stack(conn *c) {
       14: 1220:    return c->resp_head->next != NULL ? true : false;
        -: 1221:}
        -: 1222:
   479292: 1223:void out_string(conn *c, const char *str) {
   479292: 1224:    size_t len;
  479292*: 1225:    assert(c != NULL);
   479292: 1226:    mc_resp *resp = c->resp;
        -: 1227:
        -: 1228:    // if response was original filled with something, but we're now writing
        -: 1229:    // out an error or similar, have to reset the object first.
        -: 1230:    // TODO: since this is often redundant with allocation, how many callers
        -: 1231:    // are actually requiring it be reset? Can we fast test by just looking at
        -: 1232:    // tosend and reset if nonzero?
   479292: 1233:    resp_reset(resp);
        -: 1234:
   479292: 1235:    if (c->noreply) {
        -: 1236:        // TODO: just invalidate the response since nothing's been attempted
        -: 1237:        // to send yet?
   193654: 1238:        resp->skip = true;
   193654: 1239:        if (settings.verbose > 1)
    #####: 1240:            fprintf(stderr, ">%d NOREPLY %s\n", c->sfd, str);
   193654: 1241:        conn_set_state(c, conn_new_cmd);
   193654: 1242:        return;
        -: 1243:    }
        -: 1244:
   285638: 1245:    if (settings.verbose > 1)
    #####: 1246:        fprintf(stderr, ">%d %s\n", c->sfd, str);
        -: 1247:
        -: 1248:    // Fill response object with static string.
        -: 1249:
   285638: 1250:    len = strlen(str);
   285638: 1251:    if ((len + 2) > WRITE_BUFFER_SIZE) {
        -: 1252:        /* ought to be always enough. just fail for simplicity */
    #####: 1253:        str = "SERVER_ERROR output line too long";
    #####: 1254:        len = strlen(str);
        -: 1255:    }
        -: 1256:
   285638: 1257:    memcpy(resp->wbuf, str, len);
   285638: 1258:    memcpy(resp->wbuf + len, "\r\n", 2);
   285638: 1259:    resp_add_iov(resp, resp->wbuf, len + 2);
        -: 1260:
   285638: 1261:    conn_set_state(c, conn_new_cmd);
   285638: 1262:    return;
        -: 1263:}
        -: 1264:
        -: 1265:// For metaget-style ASCII commands. Ignores noreply, ensuring clients see
        -: 1266:// protocol level errors.
        4: 1267:void out_errstring(conn *c, const char *str) {
        4: 1268:    c->noreply = false;
        4: 1269:    out_string(c, str);
        4: 1270:}
        -: 1271:
        -: 1272:/*
        -: 1273: * Outputs a protocol-specific "out of memory" error. For ASCII clients,
        -: 1274: * this is equivalent to out_string().
        -: 1275: */
        7: 1276:void out_of_memory(conn *c, char *ascii_error) {
        7: 1277:    const static char error_prefix[] = "SERVER_ERROR ";
        7: 1278:    const static int error_prefix_len = sizeof(error_prefix) - 1;
        -: 1279:
        7: 1280:    if (c->protocol == binary_prot) {
        -: 1281:        /* Strip off the generic error prefix; it's irrelevant in binary */
    #####: 1282:        if (!strncmp(ascii_error, error_prefix, error_prefix_len)) {
    #####: 1283:            ascii_error += error_prefix_len;
        -: 1284:        }
    #####: 1285:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, ascii_error, 0);
        -: 1286:    } else {
        7: 1287:        out_string(c, ascii_error);
        -: 1288:    }
        7: 1289:}
        -: 1290:
     3517: 1291:static void append_bin_stats(const char *key, const uint16_t klen,
        -: 1292:                             const char *val, const uint32_t vlen,
        -: 1293:                             conn *c) {
     3517: 1294:    char *buf = c->stats.buffer + c->stats.offset;
     3517: 1295:    uint32_t bodylen = klen + vlen;
     3517: 1296:    protocol_binary_response_header header = {
        -: 1297:        .response.magic = (uint8_t)PROTOCOL_BINARY_RES,
        -: 1298:        .response.opcode = PROTOCOL_BINARY_CMD_STAT,
     3517: 1299:        .response.keylen = (uint16_t)htons(klen),
        -: 1300:        .response.datatype = (uint8_t)PROTOCOL_BINARY_RAW_BYTES,
     3517: 1301:        .response.bodylen = htonl(bodylen),
     3517: 1302:        .response.opaque = c->opaque
        -: 1303:    };
        -: 1304:
     3517: 1305:    memcpy(buf, header.bytes, sizeof(header.response));
     3517: 1306:    buf += sizeof(header.response);
        -: 1307:
     3517: 1308:    if (klen > 0) {
     3471: 1309:        memcpy(buf, key, klen);
     3471: 1310:        buf += klen;
        -: 1311:
     3471: 1312:        if (vlen > 0) {
     3471: 1313:            memcpy(buf, val, vlen);
        -: 1314:        }
        -: 1315:    }
        -: 1316:
     3517: 1317:    c->stats.offset += sizeof(header.response) + bodylen;
     3517: 1318:}
        -: 1319:
   873401: 1320:static void append_ascii_stats(const char *key, const uint16_t klen,
        -: 1321:                               const char *val, const uint32_t vlen,
        -: 1322:                               conn *c) {
   873401: 1323:    char *pos = c->stats.buffer + c->stats.offset;
   873401: 1324:    uint32_t nbytes = 0;
   873401: 1325:    int remaining = c->stats.size - c->stats.offset;
   873401: 1326:    int room = remaining - 1;
        -: 1327:
   873401: 1328:    if (klen == 0 && vlen == 0) {
    10085: 1329:        nbytes = snprintf(pos, room, "END\r\n");
   863316: 1330:    } else if (vlen == 0) {
    #####: 1331:        nbytes = snprintf(pos, room, "STAT %s\r\n", key);
        -: 1332:    } else {
   863316: 1333:        nbytes = snprintf(pos, room, "STAT %s %s\r\n", key, val);
        -: 1334:    }
        -: 1335:
   873401: 1336:    c->stats.offset += nbytes;
   873401: 1337:}
        -: 1338:
   876918: 1339:static bool grow_stats_buf(conn *c, size_t needed) {
   876918: 1340:    size_t nsize = c->stats.size;
   876918: 1341:    size_t available = nsize - c->stats.offset;
   876918: 1342:    bool rv = true;
        -: 1343:
        -: 1344:    /* Special case: No buffer -- need to allocate fresh */
   876918: 1345:    if (c->stats.buffer == NULL) {
    10131: 1346:        nsize = 1024;
    10131: 1347:        available = c->stats.size = c->stats.offset = 0;
        -: 1348:    }
        -: 1349:
   894987: 1350:    while (needed > available) {
   18069*: 1351:        assert(nsize > 0);
    18069: 1352:        nsize = nsize << 1;
    18069: 1353:        available = nsize - c->stats.offset;
        -: 1354:    }
        -: 1355:
   876918: 1356:    if (nsize != c->stats.size) {
    18069: 1357:        char *ptr = realloc(c->stats.buffer, nsize);
    18069: 1358:        if (ptr) {
    18069: 1359:            c->stats.buffer = ptr;
    18069: 1360:            c->stats.size = nsize;
        -: 1361:        } else {
    #####: 1362:            STATS_LOCK();
    #####: 1363:            stats.malloc_fails++;
    #####: 1364:            STATS_UNLOCK();
    #####: 1365:            rv = false;
        -: 1366:        }
        -: 1367:    }
        -: 1368:
   876918: 1369:    return rv;
        -: 1370:}
        -: 1371:
   876918: 1372:void append_stats(const char *key, const uint16_t klen,
        -: 1373:                  const char *val, const uint32_t vlen,
        -: 1374:                  const void *cookie)
        -: 1375:{
        -: 1376:    /* value without a key is invalid */
   876918: 1377:    if (klen == 0 && vlen > 0) {
        -: 1378:        return;
        -: 1379:    }
        -: 1380:
   876918: 1381:    conn *c = (conn*)cookie;
        -: 1382:
   876918: 1383:    if (c->protocol == binary_prot) {
     3517: 1384:        size_t needed = vlen + klen + sizeof(protocol_binary_response_header);
     3517: 1385:        if (!grow_stats_buf(c, needed)) {
        -: 1386:            return;
        -: 1387:        }
     3517: 1388:        append_bin_stats(key, klen, val, vlen, c);
        -: 1389:    } else {
   873401: 1390:        size_t needed = vlen + klen + 10; // 10 == "STAT = \r\n"
   873401: 1391:        if (!grow_stats_buf(c, needed)) {
        -: 1392:            return;
        -: 1393:        }
   873401: 1394:        append_ascii_stats(key, klen, val, vlen, c);
        -: 1395:    }
        -: 1396:
  876918*: 1397:    assert(c->stats.offset <= c->stats.size);
        -: 1398:}
        -: 1399:
  1141935: 1400:static void reset_cmd_handler(conn *c) {
  1141935: 1401:    c->cmd = -1;
  1141935: 1402:    c->substate = bin_no_state;
  1141935: 1403:    if (c->item != NULL) {
        -: 1404:        // TODO: Any other way to get here?
        -: 1405:        // SASL auth was mistakenly using it. Nothing else should?
    #####: 1406:        if (c->item_malloced) {
    #####: 1407:            free(c->item);
    #####: 1408:            c->item_malloced = false;
        -: 1409:        } else {
    #####: 1410:            item_remove(c->item);
        -: 1411:        }
    #####: 1412:        c->item = NULL;
        -: 1413:    }
  1141935: 1414:    if (c->rbytes > 0) {
   152712: 1415:        conn_set_state(c, conn_parse_cmd);
   989223: 1416:    } else if (c->resp_head) {
   492871: 1417:        conn_set_state(c, conn_mwrite);
        -: 1418:    } else {
   496352: 1419:        conn_set_state(c, conn_waiting);
        -: 1420:    }
  1141935: 1421:}
        -: 1422:
   359975: 1423:static void complete_nread(conn *c) {
  359975*: 1424:    assert(c != NULL);
        -: 1425:#ifdef PROXY
        -: 1426:    assert(c->protocol == ascii_prot
        -: 1427:           || c->protocol == binary_prot
        -: 1428:           || c->protocol == proxy_prot);
        -: 1429:#else
  359975*: 1430:    assert(c->protocol == ascii_prot
        -: 1431:           || c->protocol == binary_prot);
        -: 1432:#endif
   359975: 1433:    if (c->protocol == ascii_prot) {
   334896: 1434:        complete_nread_ascii(c);
    25079: 1435:    } else if (c->protocol == binary_prot) {
    25079: 1436:        complete_nread_binary(c);
        -: 1437:#ifdef PROXY
        -: 1438:    } else if (c->protocol == proxy_prot) {
        -: 1439:        complete_nread_proxy(c);
        -: 1440:#endif
        -: 1441:    }
   359975: 1442:}
        -: 1443:
        -: 1444:/* Destination must always be chunked */
        -: 1445:/* This should be part of item.c */
    27032: 1446:static int _store_item_copy_chunks(item *d_it, item *s_it, const int len) {
    27032: 1447:    item_chunk *dch = (item_chunk *) ITEM_schunk(d_it);
        -: 1448:    /* Advance dch until we find free space */
    77099: 1449:    while (dch->size == dch->used) {
    77099: 1450:        if (dch->next) {
        -: 1451:            dch = dch->next;
        -: 1452:        } else {
        -: 1453:            break;
        -: 1454:        }
        -: 1455:    }
        -: 1456:
    27032: 1457:    if (s_it->it_flags & ITEM_CHUNKED) {
    13516: 1458:        int remain = len;
    13516: 1459:        item_chunk *sch = (item_chunk *) ITEM_schunk(s_it);
    13516: 1460:        int copied = 0;
        -: 1461:        /* Fills dch's to capacity, not straight copy sch in case data is
        -: 1462:         * being added or removed (ie append/prepend)
        -: 1463:         */
   136671: 1464:        while (sch && dch && remain) {
  123155*: 1465:            assert(dch->used <= dch->size);
   123155: 1466:            int todo = (dch->size - dch->used < sch->used - copied)
        -: 1467:                ? dch->size - dch->used : sch->used - copied;
   123155: 1468:            if (remain < todo)
        -: 1469:                todo = remain;
   123155: 1470:            memcpy(dch->data + dch->used, sch->data + copied, todo);
   123155: 1471:            dch->used += todo;
   123155: 1472:            copied += todo;
   123155: 1473:            remain -= todo;
  123155*: 1474:            assert(dch->used <= dch->size);
   123155: 1475:            if (dch->size == dch->used) {
    73103: 1476:                item_chunk *tch = do_item_alloc_chunk(dch, remain);
    73103: 1477:                if (tch) {
        -: 1478:                    dch = tch;
        -: 1479:                } else {
        -: 1480:                    return -1;
        -: 1481:                }
        -: 1482:            }
  123155*: 1483:            assert(copied <= sch->used);
   123155: 1484:            if (copied == sch->used) {
    93361: 1485:                copied = 0;
    93361: 1486:                sch = sch->next;
        -: 1487:            }
        -: 1488:        }
        -: 1489:        /* assert that the destination had enough space for the source */
   13516*: 1490:        assert(remain == 0);
        -: 1491:    } else {
        -: 1492:        int done = 0;
        -: 1493:        /* Fill dch's via a non-chunked item. */
    40548: 1494:        while (len > done && dch) {
    27032: 1495:            int todo = (dch->size - dch->used < len - done)
        -: 1496:                ? dch->size - dch->used : len - done;
        -: 1497:            //assert(dch->size - dch->used != 0);
    27032: 1498:            memcpy(dch->data + dch->used, ITEM_data(s_it) + done, todo);
    27032: 1499:            done += todo;
    27032: 1500:            dch->used += todo;
   27032*: 1501:            assert(dch->used <= dch->size);
    27032: 1502:            if (dch->size == dch->used) {
    27032: 1503:                item_chunk *tch = do_item_alloc_chunk(dch, len - done);
    27032: 1504:                if (tch) {
        -: 1505:                    dch = tch;
        -: 1506:                } else {
        -: 1507:                    return -1;
        -: 1508:                }
        -: 1509:            }
        -: 1510:        }
   13516*: 1511:        assert(len == done);
        -: 1512:    }
        -: 1513:    return 0;
        -: 1514:}
        -: 1515:
    16016: 1516:static int _store_item_copy_data(int comm, item *old_it, item *new_it, item *add_it) {
    16016: 1517:    if (comm == NREAD_APPEND || comm == NREAD_APPENDVIV) {
     8009: 1518:        if (new_it->it_flags & ITEM_CHUNKED) {
    13516: 1519:            if (_store_item_copy_chunks(new_it, old_it, old_it->nbytes - 2) == -1 ||
     6758: 1520:                _store_item_copy_chunks(new_it, add_it, add_it->nbytes) == -1) {
    #####: 1521:                return -1;
        -: 1522:            }
        -: 1523:        } else {
     1251: 1524:            memcpy(ITEM_data(new_it), ITEM_data(old_it), old_it->nbytes);
     1251: 1525:            memcpy(ITEM_data(new_it) + old_it->nbytes - 2 /* CRLF */, ITEM_data(add_it), add_it->nbytes);
        -: 1526:        }
        -: 1527:    } else {
        -: 1528:        /* NREAD_PREPEND */
     8007: 1529:        if (new_it->it_flags & ITEM_CHUNKED) {
    13516: 1530:            if (_store_item_copy_chunks(new_it, add_it, add_it->nbytes - 2) == -1 ||
     6758: 1531:                _store_item_copy_chunks(new_it, old_it, old_it->nbytes) == -1) {
    #####: 1532:                return -1;
        -: 1533:            }
        -: 1534:        } else {
     1249: 1535:            memcpy(ITEM_data(new_it), ITEM_data(add_it), add_it->nbytes);
     1249: 1536:            memcpy(ITEM_data(new_it) + add_it->nbytes - 2 /* CRLF */, ITEM_data(old_it), old_it->nbytes);
        -: 1537:        }
        -: 1538:    }
        -: 1539:    return 0;
        -: 1540:}
        -: 1541:
        -: 1542:/*
        -: 1543: * Stores an item in the cache according to the semantics of one of the set
        -: 1544: * commands. Protected by the item lock.
        -: 1545: *
        -: 1546: * Returns the state of storage.
        -: 1547: */
   360042: 1548:enum store_item_type do_store_item(item *it, int comm, LIBEVENT_THREAD *t, const uint32_t hv, int *nbytes, uint64_t *cas, uint64_t cas_in, bool cas_stale) {
   360042: 1549:    char *key = ITEM_key(it);
   360042: 1550:    item *old_it = do_item_get(key, it->nkey, hv, t, DONT_UPDATE);
   360042: 1551:    enum store_item_type stored = NOT_STORED;
        -: 1552:
   360042: 1553:    enum cas_result { CAS_NONE, CAS_MATCH, CAS_BADVAL, CAS_STALE, CAS_MISS };
        -: 1554:
   360042: 1555:    item *new_it = NULL;
   360042: 1556:    client_flags_t flags;
        -: 1557:
        -: 1558:    /* Do the CAS test up front so we can apply to all store modes */
   360042: 1559:    enum cas_result cas_res = CAS_NONE;
        -: 1560:
   360042: 1561:    bool do_store = false;
   360042: 1562:    if (old_it != NULL) {
        -: 1563:        // Most of the CAS work requires something to compare to.
    36518: 1564:        uint64_t it_cas = ITEM_get_cas(it);
    36518: 1565:        uint64_t old_cas = ITEM_get_cas(old_it);
    36518: 1566:        if (it_cas == 0) {
        -: 1567:            cas_res = CAS_NONE;
       23: 1568:        } else if (it_cas == old_cas) {
        -: 1569:            cas_res = CAS_MATCH;
       10: 1570:        } else if (cas_stale && it_cas < old_cas) {
        -: 1571:            cas_res = CAS_STALE;
        -: 1572:        } else {
        9: 1573:            cas_res = CAS_BADVAL;
        -: 1574:        }
        -: 1575:
    36518: 1576:        switch (comm) {
      648: 1577:            case NREAD_ADD:
        -: 1578:                /* add only adds a nonexistent item, but promote to head of LRU */
      648: 1579:                do_item_update(old_it);
      648: 1580:                break;
       23: 1581:            case NREAD_CAS:
       23: 1582:                if (cas_res == CAS_MATCH) {
        -: 1583:                    // cas validates
        -: 1584:                    // it and old_it may belong to different classes.
        -: 1585:                    // I'm updating the stats for the one that's getting pushed out
       12: 1586:                    pthread_mutex_lock(&t->stats.mutex);
       12: 1587:                    t->stats.slab_stats[ITEM_clsid(old_it)].cas_hits++;
       12: 1588:                    pthread_mutex_unlock(&t->stats.mutex);
       12: 1589:                    do_store = true;
       11: 1590:                } else if (cas_res == CAS_STALE) {
        -: 1591:                    // if we're allowed to set a stale value, CAS must be lower than
        -: 1592:                    // the current item's CAS.
        -: 1593:                    // This replaces the value, but should preserve TTL, and stale
        -: 1594:                    // item marker bit + token sent if exists.
        1: 1595:                    it->exptime = old_it->exptime;
        1: 1596:                    it->it_flags |= ITEM_STALE;
        1: 1597:                    if (old_it->it_flags & ITEM_TOKEN_SENT) {
        1: 1598:                        it->it_flags |= ITEM_TOKEN_SENT;
        -: 1599:                    }
        -: 1600:
        1: 1601:                    pthread_mutex_lock(&t->stats.mutex);
        1: 1602:                    t->stats.slab_stats[ITEM_clsid(old_it)].cas_hits++;
        1: 1603:                    pthread_mutex_unlock(&t->stats.mutex);
        1: 1604:                    do_store = true;
        -: 1605:                } else {
        -: 1606:                    // NONE or BADVAL are the same for CAS cmd
       10: 1607:                    pthread_mutex_lock(&t->stats.mutex);
       10: 1608:                    t->stats.slab_stats[ITEM_clsid(old_it)].cas_badval++;
       10: 1609:                    pthread_mutex_unlock(&t->stats.mutex);
        -: 1610:
       10: 1611:                    if (settings.verbose > 1) {
    #####: 1612:                        fprintf(stderr, "CAS:  failure: expected %llu, got %llu\n",
    #####: 1613:                                (unsigned long long)ITEM_get_cas(old_it),
    #####: 1614:                                (unsigned long long)ITEM_get_cas(it));
        -: 1615:                    }
        -: 1616:                    stored = EXISTS;
        -: 1617:                }
        -: 1618:                break;
    16018: 1619:            case NREAD_APPEND:
        -: 1620:            case NREAD_PREPEND:
        -: 1621:            case NREAD_APPENDVIV:
        -: 1622:            case NREAD_PREPENDVIV:
    16018: 1623:                if (cas_res != CAS_NONE && cas_res != CAS_MATCH) {
        -: 1624:                    stored = EXISTS;
        -: 1625:                    break;
        -: 1626:                }
        -: 1627:#ifdef EXTSTORE
    16018: 1628:                if ((old_it->it_flags & ITEM_HDR) != 0) {
        -: 1629:                    /* block append/prepend from working with extstore-d items.
        -: 1630:                     * leave response code to NOT_STORED default */
        -: 1631:                    break;
        -: 1632:                }
        -: 1633:#endif
        -: 1634:                /* we have it and old_it here - alloc memory to hold both */
    16016: 1635:                FLAGS_CONV(old_it, flags);
    16016: 1636:                new_it = do_item_alloc(key, it->nkey, flags, old_it->exptime, it->nbytes + old_it->nbytes - 2 /* CRLF */);
        -: 1637:
        -: 1638:                // OOM trying to copy.
    16016: 1639:                if (new_it == NULL)
        -: 1640:                    break;
        -: 1641:                /* copy data from it and old_it to new_it */
    16016: 1642:                if (_store_item_copy_data(comm, old_it, new_it, it) == -1) {
        -: 1643:                    // failed data copy
        -: 1644:                    break;
        -: 1645:                } else {
        -: 1646:                    // refcount of new_it is 1 here. will end up 2 after link.
        -: 1647:                    // it's original ref is managed outside of this function
    16016: 1648:                    it = new_it;
    16016: 1649:                    do_store = true;
        -: 1650:                    // Upstream final object size for meta
    16016: 1651:                    if (nbytes != NULL) {
    16008: 1652:                        *nbytes = it->nbytes;
        -: 1653:                    }
        -: 1654:                }
        -: 1655:                break;
        -: 1656:            case NREAD_REPLACE:
        -: 1657:            case NREAD_SET:
    19841: 1658:                do_store = true;
        -: 1659:                break;
        -: 1660:        }
        -: 1661:
    36518: 1662:        if (do_store) {
    35858: 1663:            STORAGE_delete(t->storage, old_it);
    35858: 1664:            item_replace(old_it, it, hv, cas_in);
    35858: 1665:            stored = STORED;
        -: 1666:        }
        -: 1667:
    36518: 1668:        do_item_remove(old_it);         /* release our reference */
    36518: 1669:        if (new_it != NULL) {
        -: 1670:            // append/prepend end up with an extra reference for new_it.
    16016: 1671:            do_item_remove(new_it);
        -: 1672:        }
        -: 1673:    } else {
        -: 1674:        /* No pre-existing item to replace or compare to. */
   323524: 1675:        if (ITEM_get_cas(it) != 0) {
        -: 1676:            /* Asked for a CAS match but nothing to compare it to. */
        -: 1677:            cas_res = CAS_MISS;
        -: 1678:        }
        -: 1679:
   323524: 1680:        switch (comm) {
        -: 1681:            case NREAD_ADD:
        -: 1682:            case NREAD_SET:
        -: 1683:            case NREAD_APPENDVIV:
        -: 1684:            case NREAD_PREPENDVIV:
   323417: 1685:                do_store = true;
   323417: 1686:                break;
        3: 1687:            case NREAD_CAS:
        -: 1688:                // LRU expired
        3: 1689:                stored = NOT_FOUND;
        3: 1690:                pthread_mutex_lock(&t->stats.mutex);
        3: 1691:                t->stats.cas_misses++;
        3: 1692:                pthread_mutex_unlock(&t->stats.mutex);
        3: 1693:                break;
        -: 1694:            case NREAD_REPLACE:
        -: 1695:            case NREAD_APPEND:
        -: 1696:            case NREAD_PREPEND:
        -: 1697:                /* Requires an existing item. */
        -: 1698:                break;
        -: 1699:        }
        -: 1700:
        3: 1701:        if (do_store) {
   323417: 1702:            do_item_link(it, hv, cas_in);
   323417: 1703:            stored = STORED;
        -: 1704:        }
        -: 1705:    }
        -: 1706:
   360042: 1707:    if (stored == STORED && cas != NULL) {
   359269: 1708:        *cas = ITEM_get_cas(it);
        -: 1709:    }
  360042*: 1710:    LOGGER_LOG(t->l, LOG_MUTATIONS, LOGGER_ITEM_STORE, NULL,
        -: 1711:            stored, comm, ITEM_key(it), it->nkey, it->nbytes, it->exptime,
        -: 1712:            ITEM_clsid(it), t->cur_sfd);
        -: 1713:
   360042: 1714:    return stored;
        -: 1715:}
        -: 1716:
        -: 1717:/* set up a connection to write a buffer then free it, used for stats */
    10141: 1718:void write_and_free(conn *c, char *buf, int bytes) {
    10141: 1719:    if (buf) {
    10141: 1720:        mc_resp *resp = c->resp;
    10141: 1721:        resp->write_and_free = buf;
    10141: 1722:        resp_add_iov(resp, buf, bytes);
    10141: 1723:        conn_set_state(c, conn_new_cmd);
        -: 1724:    } else {
    #####: 1725:        out_of_memory(c, "SERVER_ERROR out of memory writing stats");
        -: 1726:    }
    10141: 1727:}
        -: 1728:
   752913: 1729:void append_stat(const char *name, ADD_STAT add_stats, conn *c,
        -: 1730:                 const char *fmt, ...) {
   752913: 1731:    char val_str[STAT_VAL_LEN];
   752913: 1732:    int vlen;
   752913: 1733:    va_list ap;
        -: 1734:
  752913*: 1735:    assert(name);
  752913*: 1736:    assert(add_stats);
  752913*: 1737:    assert(c);
  752913*: 1738:    assert(fmt);
        -: 1739:
   752913: 1740:    va_start(ap, fmt);
   752913: 1741:    vlen = vsnprintf(val_str, sizeof(val_str) - 1, fmt, ap);
   752913: 1742:    va_end(ap);
        -: 1743:
   752913: 1744:    add_stats(name, strlen(name), val_str, vlen, c);
   752913: 1745:}
        -: 1746:
        -: 1747:/* return server specific stats only */
     7937: 1748:void server_stats(ADD_STAT add_stats, void *c) {
     7937: 1749:    pid_t pid = getpid();
     7937: 1750:    rel_time_t now = current_time;
        -: 1751:
     7937: 1752:    struct thread_stats thread_stats;
     7937: 1753:    threadlocal_stats_aggregate(&thread_stats);
     7937: 1754:    struct slab_stats slab_stats;
     7937: 1755:    slab_stats_aggregate(&thread_stats, &slab_stats);
        -: 1756:#ifndef WIN32
     7937: 1757:    struct rusage usage;
     7937: 1758:    getrusage(RUSAGE_SELF, &usage);
        -: 1759:#endif /* !WIN32 */
        -: 1760:
     7937: 1761:    STATS_LOCK();
        -: 1762:
     7937: 1763:    APPEND_STAT("pid", "%lu", (long)pid);
     7937: 1764:    APPEND_STAT("uptime", "%u", now - ITEM_UPDATE_INTERVAL);
     7937: 1765:    APPEND_STAT("time", "%ld", now + (long)process_started);
     7937: 1766:    APPEND_STAT("version", "%s", VERSION);
     7937: 1767:    APPEND_STAT("libevent", "%s", event_get_version());
     7937: 1768:    APPEND_STAT("pointer_size", "%d", (int)(8 * sizeof(void *)));
        -: 1769:
        -: 1770:#ifndef WIN32
     7937: 1771:    append_stat("rusage_user", add_stats, c, "%ld.%06ld",
     7937: 1772:                (long)usage.ru_utime.tv_sec,
     7937: 1773:                (long)usage.ru_utime.tv_usec);
     7937: 1774:    append_stat("rusage_system", add_stats, c, "%ld.%06ld",
     7937: 1775:                (long)usage.ru_stime.tv_sec,
     7937: 1776:                (long)usage.ru_stime.tv_usec);
        -: 1777:#endif /* !WIN32 */
        -: 1778:
     7937: 1779:    APPEND_STAT("max_connections", "%d", settings.maxconns);
     7937: 1780:    APPEND_STAT("curr_connections", "%llu", (unsigned long long)stats_state.curr_conns - 1);
     7937: 1781:    APPEND_STAT("total_connections", "%llu", (unsigned long long)stats.total_conns);
     7937: 1782:    if (settings.maxconns_fast) {
     7926: 1783:        APPEND_STAT("rejected_connections", "%llu", (unsigned long long)stats.rejected_conns);
        -: 1784:    }
     7937: 1785:    APPEND_STAT("connection_structures", "%u", stats_state.conn_structs);
     7937: 1786:    APPEND_STAT("response_obj_oom", "%llu", (unsigned long long)thread_stats.response_obj_oom);
     7937: 1787:    APPEND_STAT("response_obj_count", "%llu", (unsigned long long)thread_stats.response_obj_count);
     7937: 1788:    APPEND_STAT("response_obj_bytes", "%llu", (unsigned long long)thread_stats.response_obj_bytes);
     7937: 1789:    APPEND_STAT("read_buf_count", "%llu", (unsigned long long)thread_stats.read_buf_count);
     7937: 1790:    APPEND_STAT("read_buf_bytes", "%llu", (unsigned long long)thread_stats.read_buf_bytes);
     7937: 1791:    APPEND_STAT("read_buf_bytes_free", "%llu", (unsigned long long)thread_stats.read_buf_bytes_free);
     7937: 1792:    APPEND_STAT("read_buf_oom", "%llu", (unsigned long long)thread_stats.read_buf_oom);
     7937: 1793:    APPEND_STAT("reserved_fds", "%u", stats_state.reserved_fds);
        -: 1794:#ifdef PROXY
        -: 1795:    if (settings.proxy_enabled) {
        -: 1796:        APPEND_STAT("proxy_conn_requests", "%llu", (unsigned long long)thread_stats.proxy_conn_requests);
        -: 1797:        APPEND_STAT("proxy_conn_errors", "%llu", (unsigned long long)thread_stats.proxy_conn_errors);
        -: 1798:        APPEND_STAT("proxy_conn_oom", "%llu", (unsigned long long)thread_stats.proxy_conn_oom);
        -: 1799:        APPEND_STAT("proxy_req_active", "%llu", (unsigned long long)thread_stats.proxy_req_active);
        -: 1800:    }
        -: 1801:#endif
     7937: 1802:    APPEND_STAT("cmd_get", "%llu", (unsigned long long)thread_stats.get_cmds);
     7937: 1803:    APPEND_STAT("cmd_set", "%llu", (unsigned long long)slab_stats.set_cmds);
     7937: 1804:    APPEND_STAT("cmd_flush", "%llu", (unsigned long long)thread_stats.flush_cmds);
     7937: 1805:    APPEND_STAT("cmd_touch", "%llu", (unsigned long long)thread_stats.touch_cmds);
     7937: 1806:    APPEND_STAT("cmd_meta", "%llu", (unsigned long long)thread_stats.meta_cmds);
     7937: 1807:    APPEND_STAT("get_hits", "%llu", (unsigned long long)slab_stats.get_hits);
     7937: 1808:    APPEND_STAT("get_misses", "%llu", (unsigned long long)thread_stats.get_misses);
     7937: 1809:    APPEND_STAT("get_expired", "%llu", (unsigned long long)thread_stats.get_expired);
     7937: 1810:    APPEND_STAT("get_flushed", "%llu", (unsigned long long)thread_stats.get_flushed);
        -: 1811:#ifdef EXTSTORE
     7937: 1812:    if (ext_storage) {
     1059: 1813:        APPEND_STAT("get_extstore", "%llu", (unsigned long long)thread_stats.get_extstore);
     1059: 1814:        APPEND_STAT("get_aborted_extstore", "%llu", (unsigned long long)thread_stats.get_aborted_extstore);
     1059: 1815:        APPEND_STAT("get_oom_extstore", "%llu", (unsigned long long)thread_stats.get_oom_extstore);
     1059: 1816:        APPEND_STAT("recache_from_extstore", "%llu", (unsigned long long)thread_stats.recache_from_extstore);
     1059: 1817:        APPEND_STAT("miss_from_extstore", "%llu", (unsigned long long)thread_stats.miss_from_extstore);
     1059: 1818:        APPEND_STAT("badcrc_from_extstore", "%llu", (unsigned long long)thread_stats.badcrc_from_extstore);
        -: 1819:    }
        -: 1820:#endif
     7937: 1821:    APPEND_STAT("delete_misses", "%llu", (unsigned long long)thread_stats.delete_misses);
     7937: 1822:    APPEND_STAT("delete_hits", "%llu", (unsigned long long)slab_stats.delete_hits);
     7937: 1823:    APPEND_STAT("incr_misses", "%llu", (unsigned long long)thread_stats.incr_misses);
     7937: 1824:    APPEND_STAT("incr_hits", "%llu", (unsigned long long)slab_stats.incr_hits);
     7937: 1825:    APPEND_STAT("decr_misses", "%llu", (unsigned long long)thread_stats.decr_misses);
     7937: 1826:    APPEND_STAT("decr_hits", "%llu", (unsigned long long)slab_stats.decr_hits);
     7937: 1827:    APPEND_STAT("cas_misses", "%llu", (unsigned long long)thread_stats.cas_misses);
     7937: 1828:    APPEND_STAT("cas_hits", "%llu", (unsigned long long)slab_stats.cas_hits);
     7937: 1829:    APPEND_STAT("cas_badval", "%llu", (unsigned long long)slab_stats.cas_badval);
     7937: 1830:    APPEND_STAT("touch_hits", "%llu", (unsigned long long)slab_stats.touch_hits);
     7937: 1831:    APPEND_STAT("touch_misses", "%llu", (unsigned long long)thread_stats.touch_misses);
     7937: 1832:    APPEND_STAT("store_too_large", "%llu", (unsigned long long)thread_stats.store_too_large);
     7937: 1833:    APPEND_STAT("store_no_memory", "%llu", (unsigned long long)thread_stats.store_no_memory);
     7937: 1834:    APPEND_STAT("auth_cmds", "%llu", (unsigned long long)thread_stats.auth_cmds);
     7937: 1835:    APPEND_STAT("auth_errors", "%llu", (unsigned long long)thread_stats.auth_errors);
     7937: 1836:    if (settings.idle_timeout) {
        9: 1837:        APPEND_STAT("idle_kicks", "%llu", (unsigned long long)thread_stats.idle_kicks);
        -: 1838:    }
     7937: 1839:    APPEND_STAT("bytes_read", "%llu", (unsigned long long)thread_stats.bytes_read);
     7937: 1840:    APPEND_STAT("bytes_written", "%llu", (unsigned long long)thread_stats.bytes_written);
     7937: 1841:    APPEND_STAT("limit_maxbytes", "%llu", (unsigned long long)settings.maxbytes);
     7937: 1842:    APPEND_STAT("accepting_conns", "%u", stats_state.accepting_conns);
     7937: 1843:    APPEND_STAT("listen_disabled_num", "%llu", (unsigned long long)stats.listen_disabled_num);
     7937: 1844:    APPEND_STAT("time_in_listen_disabled_us", "%llu", stats.time_in_listen_disabled_us);
     7937: 1845:    APPEND_STAT("threads", "%d", settings.num_threads);
     7937: 1846:    APPEND_STAT("conn_yields", "%llu", (unsigned long long)thread_stats.conn_yields);
     7937: 1847:    APPEND_STAT("hash_power_level", "%u", stats_state.hash_power_level);
     7937: 1848:    APPEND_STAT("hash_bytes", "%llu", (unsigned long long)stats_state.hash_bytes);
     7937: 1849:    APPEND_STAT("hash_is_expanding", "%u", stats_state.hash_is_expanding);
     7937: 1850:    if (settings.slab_reassign) {
     7926: 1851:        APPEND_STAT("slab_reassign_rescues", "%llu", stats.slab_reassign_rescues);
     7926: 1852:        APPEND_STAT("slab_reassign_chunk_rescues", "%llu", stats.slab_reassign_chunk_rescues);
     7926: 1853:        APPEND_STAT("slab_reassign_inline_reclaim", "%llu", stats.slab_reassign_inline_reclaim);
     7926: 1854:        APPEND_STAT("slab_reassign_busy_items", "%llu", stats.slab_reassign_busy_items);
     7926: 1855:        APPEND_STAT("slab_reassign_busy_deletes", "%llu", stats.slab_reassign_busy_deletes);
     7926: 1856:        APPEND_STAT("slab_reassign_busy_nomem", "%llu", stats.slab_reassign_busy_nomem);
     7926: 1857:        APPEND_STAT("slab_reassign_running", "%u", stats_state.slab_reassign_running);
     7926: 1858:        APPEND_STAT("slabs_moved", "%llu", stats.slabs_moved);
        -: 1859:    }
     7937: 1860:    if (settings.lru_crawler) {
     3847: 1861:        APPEND_STAT("lru_crawler_running", "%u", stats_state.lru_crawler_running);
     3847: 1862:        APPEND_STAT("lru_crawler_starts", "%u", stats.lru_crawler_starts);
        -: 1863:    }
     7937: 1864:    if (settings.lru_maintainer_thread) {
     7910: 1865:        APPEND_STAT("lru_maintainer_juggles", "%llu", (unsigned long long)stats.lru_maintainer_juggles);
        -: 1866:    }
     7937: 1867:    APPEND_STAT("malloc_fails", "%llu",
     7937: 1868:                (unsigned long long)stats.malloc_fails);
     7937: 1869:    APPEND_STAT("log_worker_dropped", "%llu", (unsigned long long)stats.log_worker_dropped);
     7937: 1870:    APPEND_STAT("log_worker_written", "%llu", (unsigned long long)stats.log_worker_written);
     7937: 1871:    APPEND_STAT("log_watcher_skipped", "%llu", (unsigned long long)stats.log_watcher_skipped);
     7937: 1872:    APPEND_STAT("log_watcher_sent", "%llu", (unsigned long long)stats.log_watcher_sent);
     7937: 1873:    APPEND_STAT("log_watchers", "%llu", (unsigned long long)stats_state.log_watchers);
     7937: 1874:    STATS_UNLOCK();
        -: 1875:#ifdef EXTSTORE
     7937: 1876:    storage_stats(add_stats, c);
        -: 1877:#endif
        -: 1878:#ifdef PROXY
        -: 1879:    proxy_stats(settings.proxy_ctx, add_stats, c);
        -: 1880:#endif
        -: 1881:#ifdef TLS
        -: 1882:    if (settings.ssl_enabled) {
        -: 1883:        if (settings.ssl_session_cache) {
        -: 1884:            APPEND_STAT("ssl_new_sessions", "%llu", (unsigned long long)stats.ssl_new_sessions);
        -: 1885:        }
        -: 1886:        APPEND_STAT("ssl_handshake_errors", "%llu", (unsigned long long)stats.ssl_handshake_errors);
        -: 1887:        APPEND_STAT("ssl_proto_errors", "%llu", (unsigned long long)stats.ssl_proto_errors);
        -: 1888:        APPEND_STAT("time_since_server_cert_refresh", "%u", now - settings.ssl_last_cert_refresh_time);
        -: 1889:    }
        -: 1890:#endif
     7937: 1891:    APPEND_STAT("unexpected_napi_ids", "%llu", (unsigned long long)stats.unexpected_napi_ids);
     7937: 1892:    APPEND_STAT("round_robin_fallback", "%llu", (unsigned long long)stats.round_robin_fallback);
     7937: 1893:}
        -: 1894:
       22: 1895:void process_stat_settings(ADD_STAT add_stats, void *c) {
      22*: 1896:    assert(add_stats);
       22: 1897:    APPEND_STAT("maxbytes", "%llu", (unsigned long long)settings.maxbytes);
       22: 1898:    APPEND_STAT("maxconns", "%d", settings.maxconns);
       22: 1899:    APPEND_STAT("tcpport", "%d", settings.port);
       22: 1900:    APPEND_STAT("udpport", "%d", settings.udpport);
       22: 1901:    APPEND_STAT("inter", "%s", settings.inter ? settings.inter : "NULL");
       22: 1902:    APPEND_STAT("verbosity", "%d", settings.verbose);
       22: 1903:    APPEND_STAT("oldest", "%lu", (unsigned long)settings.oldest_live);
       22: 1904:    APPEND_STAT("evictions", "%s", settings.evict_to_free ? "on" : "off");
       44: 1905:    APPEND_STAT("domain_socket", "%s",
       22: 1906:                settings.socketpath ? settings.socketpath : "NULL");
       22: 1907:    APPEND_STAT("umask", "%o", settings.access);
       44: 1908:    APPEND_STAT("shutdown_command", "%s",
       22: 1909:                settings.shutdown_command ? "yes" : "no");
       22: 1910:    APPEND_STAT("growth_factor", "%.2f", settings.factor);
       22: 1911:    APPEND_STAT("chunk_size", "%d", settings.chunk_size);
       22: 1912:    APPEND_STAT("num_threads", "%d", settings.num_threads);
       22: 1913:    APPEND_STAT("num_threads_per_udp", "%d", settings.num_threads_per_udp);
       22: 1914:    APPEND_STAT("stat_key_prefix", "%c", settings.prefix_delimiter);
       43: 1915:    APPEND_STAT("detail_enabled", "%s",
       22: 1916:                settings.detail_enabled ? "yes" : "no");
       22: 1917:    APPEND_STAT("reqs_per_event", "%d", settings.reqs_per_event);
       23: 1918:    APPEND_STAT("cas_enabled", "%s", settings.use_cas ? "yes" : "no");
       22: 1919:    APPEND_STAT("tcp_backlog", "%d", settings.backlog);
       44: 1920:    APPEND_STAT("binding_protocol", "%s",
       22: 1921:                prot_text(settings.binding_protocol));
       44: 1922:    APPEND_STAT("auth_enabled_sasl", "%s", settings.sasl ? "yes" : "no");
       22: 1923:    APPEND_STAT("auth_enabled_ascii", "%s", settings.auth_file ? settings.auth_file : "no");
       22: 1924:    APPEND_STAT("item_size_max", "%d", settings.item_size_max);
       26: 1925:    APPEND_STAT("maxconns_fast", "%s", settings.maxconns_fast ? "yes" : "no");
       22: 1926:    APPEND_STAT("hashpower_init", "%d", settings.hashpower_init);
       26: 1927:    APPEND_STAT("slab_reassign", "%s", settings.slab_reassign ? "yes" : "no");
       22: 1928:    APPEND_STAT("slab_automove", "%d", settings.slab_automove);
       22: 1929:    APPEND_STAT("slab_automove_ratio", "%.2f", settings.slab_automove_ratio);
       22: 1930:    APPEND_STAT("slab_automove_window", "%u", settings.slab_automove_window);
       22: 1931:    APPEND_STAT("slab_chunk_max", "%d", settings.slab_chunk_size_max);
       27: 1932:    APPEND_STAT("lru_crawler", "%s", settings.lru_crawler ? "yes" : "no");
       22: 1933:    APPEND_STAT("lru_crawler_sleep", "%d", settings.lru_crawler_sleep);
       22: 1934:    APPEND_STAT("lru_crawler_tocrawl", "%lu", (unsigned long)settings.lru_crawler_tocrawl);
       22: 1935:    APPEND_STAT("tail_repair_time", "%d", settings.tail_repair_time);
       22: 1936:    APPEND_STAT("flush_enabled", "%s", settings.flush_enabled ? "yes" : "no");
       22: 1937:    APPEND_STAT("dump_enabled", "%s", settings.dump_enabled ? "yes" : "no");
       22: 1938:    APPEND_STAT("hash_algorithm", "%s", settings.hash_algorithm);
       27: 1939:    APPEND_STAT("lru_maintainer_thread", "%s", settings.lru_maintainer_thread ? "yes" : "no");
       27: 1940:    APPEND_STAT("lru_segmented", "%s", settings.lru_segmented ? "yes" : "no");
       22: 1941:    APPEND_STAT("hot_lru_pct", "%d", settings.hot_lru_pct);
       22: 1942:    APPEND_STAT("warm_lru_pct", "%d", settings.warm_lru_pct);
       22: 1943:    APPEND_STAT("hot_max_factor", "%.2f", settings.hot_max_factor);
       22: 1944:    APPEND_STAT("warm_max_factor", "%.2f", settings.warm_max_factor);
       43: 1945:    APPEND_STAT("temp_lru", "%s", settings.temp_lru ? "yes" : "no");
       22: 1946:    APPEND_STAT("temporary_ttl", "%u", settings.temporary_ttl);
       22: 1947:    APPEND_STAT("idle_timeout", "%d", settings.idle_timeout);
       22: 1948:    APPEND_STAT("watcher_logbuf_size", "%u", settings.logger_watcher_buf_size);
       22: 1949:    APPEND_STAT("worker_logbuf_size", "%u", settings.logger_buf_size);
       22: 1950:    APPEND_STAT("read_buf_mem_limit", "%u", settings.read_buf_mem_limit);
       44: 1951:    APPEND_STAT("track_sizes", "%s", item_stats_sizes_status() ? "yes" : "no");
       22: 1952:    APPEND_STAT("inline_ascii_response", "%s", "no"); // setting is dead, cannot be yes.
        -: 1953:#ifdef HAVE_DROP_PRIVILEGES
        -: 1954:    APPEND_STAT("drop_privileges", "%s", settings.drop_privileges ? "yes" : "no");
        -: 1955:#endif
        -: 1956:#ifdef EXTSTORE
       22: 1957:    APPEND_STAT("ext_item_size", "%u", settings.ext_item_size);
       22: 1958:    APPEND_STAT("ext_item_age", "%u", settings.ext_item_age);
       22: 1959:    APPEND_STAT("ext_low_ttl", "%u", settings.ext_low_ttl);
       22: 1960:    APPEND_STAT("ext_recache_rate", "%u", settings.ext_recache_rate);
       22: 1961:    APPEND_STAT("ext_wbuf_size", "%u", settings.ext_wbuf_size);
       22: 1962:    APPEND_STAT("ext_compact_under", "%u", settings.ext_compact_under);
       22: 1963:    APPEND_STAT("ext_drop_under", "%u", settings.ext_drop_under);
       22: 1964:    APPEND_STAT("ext_max_sleep", "%u", settings.ext_max_sleep);
       22: 1965:    APPEND_STAT("ext_max_frag", "%.2f", settings.ext_max_frag);
       22: 1966:    APPEND_STAT("slab_automove_freeratio", "%.3f", settings.slab_automove_freeratio);
       44: 1967:    APPEND_STAT("ext_drop_unread", "%s", settings.ext_drop_unread ? "yes" : "no");
        -: 1968:#endif
        -: 1969:#ifdef TLS
        -: 1970:    APPEND_STAT("ssl_enabled", "%s", settings.ssl_enabled ? "yes" : "no");
        -: 1971:    APPEND_STAT("ssl_chain_cert", "%s", settings.ssl_chain_cert);
        -: 1972:    APPEND_STAT("ssl_key", "%s", settings.ssl_key);
        -: 1973:    APPEND_STAT("ssl_verify_mode", "%d", settings.ssl_verify_mode);
        -: 1974:    APPEND_STAT("ssl_keyformat", "%d", settings.ssl_keyformat);
        -: 1975:    APPEND_STAT("ssl_ciphers", "%s", settings.ssl_ciphers ? settings.ssl_ciphers : "NULL");
        -: 1976:    APPEND_STAT("ssl_ca_cert", "%s", settings.ssl_ca_cert ? settings.ssl_ca_cert : "NULL");
        -: 1977:    APPEND_STAT("ssl_wbuf_size", "%u", settings.ssl_wbuf_size);
        -: 1978:    APPEND_STAT("ssl_session_cache", "%s", settings.ssl_session_cache ? "yes" : "no");
        -: 1979:    APPEND_STAT("ssl_kernel_tls", "%s", settings.ssl_kernel_tls ? "yes" : "no");
        -: 1980:    APPEND_STAT("ssl_min_version", "%s", ssl_proto_text(settings.ssl_min_version));
        -: 1981:#endif
        -: 1982:#ifdef PROXY
        -: 1983:    APPEND_STAT("proxy_enabled", "%s", settings.proxy_enabled ? "yes" : "no");
        -: 1984:    APPEND_STAT("proxy_uring_enabled", "%s", settings.proxy_uring ? "yes" : "no");
        -: 1985:#endif
       22: 1986:    APPEND_STAT("num_napi_ids", "%s", settings.num_napi_ids);
       22: 1987:    APPEND_STAT("memory_file", "%s", settings.memory_file);
       22: 1988:    APPEND_STAT("client_flags_size", "%d", sizeof(client_flags_t));
       22: 1989:}
        -: 1990:
     2191: 1991:static int nz_strcmp(int nzlength, const char *nz, const char *z) {
     2191: 1992:    int zlength=strlen(z);
     2191: 1993:    return (zlength == nzlength) && (strncmp(nz, z, zlength) == 0) ? 0 : -1;
        -: 1994:}
        -: 1995:
    10096: 1996:bool get_stats(const char *stat_type, int nkey, ADD_STAT add_stats, void *c) {
    10096: 1997:    bool ret = true;
        -: 1998:
    10096: 1999:    if (add_stats != NULL) {
    10096: 2000:        if (!stat_type) {
        -: 2001:            /* prepare general statistics for the engine */
     7937: 2002:            STATS_LOCK();
     7937: 2003:            APPEND_STAT("bytes", "%llu", (unsigned long long)stats_state.curr_bytes);
     7937: 2004:            APPEND_STAT("curr_items", "%llu", (unsigned long long)stats_state.curr_items);
     7937: 2005:            APPEND_STAT("total_items", "%llu", (unsigned long long)stats.total_items);
     7937: 2006:            STATS_UNLOCK();
     7937: 2007:            APPEND_STAT("slab_global_page_pool", "%u", global_page_pool_size(NULL));
     7937: 2008:            item_stats_totals(add_stats, c);
     2159: 2009:        } else if (nz_strcmp(nkey, stat_type, "items") == 0) {
     2127: 2010:            item_stats(add_stats, c);
       32: 2011:        } else if (nz_strcmp(nkey, stat_type, "slabs") == 0) {
       32: 2012:            slabs_stats(add_stats, c);
    #####: 2013:        } else if (nz_strcmp(nkey, stat_type, "sizes") == 0) {
    #####: 2014:            item_stats_sizes(add_stats, c);
        -: 2015:        } else {
        -: 2016:            ret = false;
        -: 2017:        }
        -: 2018:    } else {
        -: 2019:        ret = false;
        -: 2020:    }
        -: 2021:
    10096: 2022:    return ret;
        -: 2023:}
        -: 2024:
       24: 2025:static inline void get_conn_text(const conn *c, const int af,
        -: 2026:                char* addr, struct sockaddr *sock_addr) {
       24: 2027:    char addr_text[MAXPATHLEN];
       24: 2028:    addr_text[0] = '\0';
       24: 2029:    const char *protoname = "?";
       24: 2030:    unsigned short port = 0;
        -: 2031:
       24: 2032:    switch (af) {
        9: 2033:        case AF_INET:
        9: 2034:            (void) inet_ntop(af,
        9: 2035:                    &((struct sockaddr_in *)sock_addr)->sin_addr,
        -: 2036:                    addr_text,
        -: 2037:                    sizeof(addr_text) - 1);
        9: 2038:            port = ntohs(((struct sockaddr_in *)sock_addr)->sin_port);
        9: 2039:            protoname = IS_UDP(c->transport) ? "udp" : "tcp";
        -: 2040:            break;
        -: 2041:
    #####: 2042:        case AF_INET6:
    #####: 2043:            addr_text[0] = '[';
    #####: 2044:            addr_text[1] = '\0';
    #####: 2045:            if (inet_ntop(af,
    #####: 2046:                    &((struct sockaddr_in6 *)sock_addr)->sin6_addr,
        -: 2047:                    addr_text + 1,
        -: 2048:                    sizeof(addr_text) - 2)) {
    #####: 2049:                strncat(addr_text, "]", 2);
        -: 2050:            }
    #####: 2051:            port = ntohs(((struct sockaddr_in6 *)sock_addr)->sin6_port);
    #####: 2052:            protoname = IS_UDP(c->transport) ? "udp6" : "tcp6";
        -: 2053:            break;
        -: 2054:
        -: 2055:#ifndef DISABLE_UNIX_SOCKET
        -: 2056:        case AF_UNIX:
        -: 2057:        {
        9: 2058:            size_t pathlen = 0;
        -: 2059:            // this strncpy call originally could piss off an address
        -: 2060:            // sanitizer; we supplied the size of the dest buf as a limiter,
        -: 2061:            // but optimized versions of strncpy could read past the end of
        -: 2062:            // *src while looking for a null terminator. Since buf and
        -: 2063:            // sun_path here are both on the stack they could even overlap,
        -: 2064:            // which is "undefined". In all OSS versions of strncpy I could
        -: 2065:            // find this has no effect; it'll still only copy until the first null
        -: 2066:            // terminator is found. Thus it's possible to get the OS to
        -: 2067:            // examine past the end of sun_path but it's unclear to me if this
        -: 2068:            // can cause any actual problem.
        -: 2069:            //
        -: 2070:            // We need a safe_strncpy util function but I'll punt on figuring
        -: 2071:            // that out for now.
        9: 2072:            pathlen = sizeof(((struct sockaddr_un *)sock_addr)->sun_path);
        9: 2073:            if (MAXPATHLEN <= pathlen) {
        -: 2074:                pathlen = MAXPATHLEN - 1;
        -: 2075:            }
        9: 2076:            strncpy(addr_text,
        9: 2077:                    ((struct sockaddr_un *)sock_addr)->sun_path,
        -: 2078:                    pathlen);
        9: 2079:            addr_text[pathlen] = '\0';
        9: 2080:            protoname = "unix";
        -: 2081:        }
        9: 2082:            break;
        -: 2083:#endif /* #ifndef DISABLE_UNIX_SOCKET */
        -: 2084:    }
        -: 2085:
       24: 2086:    if (strlen(addr_text) < 2) {
        -: 2087:        /* Most likely this is a connected UNIX-domain client which
        -: 2088:         * has no peer socket address, but there's no portable way
        -: 2089:         * to tell for sure.
        -: 2090:         */
        6: 2091:        snprintf(addr_text, MAXPATHLEN, "<AF %d>", af);
        -: 2092:    }
        -: 2093:
       24: 2094:    if (port) {
        9: 2095:        snprintf(addr, MAXPATHLEN + 11, "%s:%s:%u", protoname, addr_text, port);
        -: 2096:    } else {
       15: 2097:        snprintf(addr, MAXPATHLEN + 11, "%s:%s", protoname, addr_text);
        -: 2098:    }
       24: 2099:}
        -: 2100:
       16: 2101:static void conn_to_str(const conn *c, char *addr, char *svr_addr) {
       16: 2102:    if (!c) {
    #####: 2103:        memcpy(addr, "<null>", 6);
       16: 2104:    } else if (c->state == conn_closed) {
    #####: 2105:        memcpy(addr, "<closed>", 8);
        -: 2106:    } else {
       16: 2107:        struct sockaddr_in6 local_addr;
       16: 2108:        struct sockaddr *sock_addr = (void *)&c->request_addr;
        -: 2109:
        -: 2110:        /* For listen ports and idle UDP ports, show listen address */
       16: 2111:        if (c->state == conn_listening ||
       12: 2112:                (IS_UDP(c->transport) &&
        -: 2113:                 c->state == conn_read)) {
        8: 2114:            memset(&local_addr, 0, sizeof(local_addr));
        8: 2115:            socklen_t local_addr_len = sizeof(local_addr);
        -: 2116:
        8: 2117:            if (getsockname(c->sfd,
        -: 2118:                        (struct sockaddr *)&local_addr,
        -: 2119:                        &local_addr_len) == 0) {
        8: 2120:                sock_addr = (struct sockaddr *)&local_addr;
        -: 2121:            }
        -: 2122:        }
       16: 2123:        get_conn_text(c, sock_addr->sa_family, addr, sock_addr);
        -: 2124:
       16: 2125:        if (c->state != conn_listening && !(IS_UDP(c->transport) &&
        -: 2126:                 c->state == conn_read)) {
        8: 2127:            struct sockaddr_storage svr_sock_addr;
        8: 2128:            memset(&svr_sock_addr, 0, sizeof(svr_sock_addr));
        8: 2129:            socklen_t svr_addr_len = sizeof(svr_sock_addr);
        8: 2130:            getsockname(c->sfd, (struct sockaddr *)&svr_sock_addr, &svr_addr_len);
        8: 2131:            get_conn_text(c, svr_sock_addr.ss_family, svr_addr, (struct sockaddr *)&svr_sock_addr);
        -: 2132:        }
        -: 2133:    }
       16: 2134:}
        -: 2135:
        4: 2136:void process_stats_conns(ADD_STAT add_stats, void *c) {
        4: 2137:    int i;
        4: 2138:    char key_str[STAT_KEY_LEN];
        4: 2139:    char val_str[STAT_VAL_LEN];
        4: 2140:    size_t extras_len = sizeof(":unix:") + sizeof("65535");
        4: 2141:    char addr[MAXPATHLEN + extras_len];
        4: 2142:    char svr_addr[MAXPATHLEN + extras_len];
        4: 2143:    memset(addr, 0, sizeof(addr));
        4: 2144:    memset(svr_addr, 0, sizeof(svr_addr));
        4: 2145:    int klen = 0, vlen = 0;
        -: 2146:
       4*: 2147:    assert(add_stats);
        -: 2148:
     4100: 2149:    for (i = 0; i < max_fds; i++) {
     4096: 2150:        if (conns[i]) {
        -: 2151:            /* This is safe to do unlocked because conns are never freed; the
        -: 2152:             * worst that'll happen will be a minor inconsistency in the
        -: 2153:             * output -- not worth the complexity of the locking that'd be
        -: 2154:             * required to prevent it.
        -: 2155:             */
       16: 2156:            if (IS_UDP(conns[i]->transport)) {
        4: 2157:                APPEND_NUM_STAT(i, "UDP", "%s", "UDP");
        -: 2158:            }
       16: 2159:            if (conns[i]->state != conn_closed) {
       16: 2160:                conn *sc = conns[i];
       16: 2161:                conn_to_str(sc, addr, svr_addr);
        -: 2162:
       16: 2163:                APPEND_NUM_STAT(i, "addr", "%s", addr);
       16: 2164:                if (sc->state != conn_listening &&
       12: 2165:                    !(IS_UDP(sc->transport) && sc->state == conn_read)) {
        8: 2166:                    APPEND_NUM_STAT(i, "listen_addr", "%s", svr_addr);
        -: 2167:                }
       16: 2168:                APPEND_NUM_STAT(i, "state", "%s",
       16: 2169:                        state_text(sc->state));
       16: 2170:                if (sc->resps_suspended) {
    #####: 2171:                    APPEND_NUM_STAT(i, "resps_waiting", "%d", sc->resps_suspended);
        -: 2172:                }
       16: 2173:                APPEND_NUM_STAT(i, "secs_since_last_cmd", "%d",
     4096: 2174:                        current_time - sc->last_cmd_time);
        -: 2175:            }
        -: 2176:        }
        -: 2177:    }
        4: 2178:}
        -: 2179:
        -: 2180:#define IT_REFCOUNT_LIMIT 60000
   135223: 2181:item* limited_get(const char *key, size_t nkey, LIBEVENT_THREAD *t, uint32_t exptime, bool should_touch, bool do_update, bool *overflow) {
   135223: 2182:    item *it;
   135223: 2183:    if (should_touch) {
        8: 2184:        it = item_touch(key, nkey, exptime, t);
        -: 2185:    } else {
   135215: 2186:        it = item_get(key, nkey, t, do_update);
        -: 2187:    }
   135223: 2188:    if (it && it->refcount > IT_REFCOUNT_LIMIT) {
    #####: 2189:        item_remove(it);
    #####: 2190:        it = NULL;
    #####: 2191:        *overflow = true;
        -: 2192:    } else {
   135223: 2193:        *overflow = false;
        -: 2194:    }
   135223: 2195:    return it;
        -: 2196:}
        -: 2197:
        -: 2198:// Semantics are different than limited_get; since the item is returned
        -: 2199:// locked, caller can directly change what it needs.
        -: 2200:// though it might eventually be a better interface to sink it all into
        -: 2201:// items.c.
       15: 2202:item* limited_get_locked(const char *key, size_t nkey, LIBEVENT_THREAD *t, bool do_update, uint32_t *hv, bool *overflow) {
       15: 2203:    item *it;
       15: 2204:    it = item_get_locked(key, nkey, t, do_update, hv);
       15: 2205:    if (it && it->refcount > IT_REFCOUNT_LIMIT) {
    #####: 2206:        do_item_remove(it);
    #####: 2207:        it = NULL;
    #####: 2208:        item_unlock(*hv);
    #####: 2209:        *overflow = true;
        -: 2210:    } else {
       15: 2211:        *overflow = false;
        -: 2212:    }
       15: 2213:    return it;
        -: 2214:}
        -: 2215:
        -: 2216:/*
        -: 2217: * adds a delta value to a numeric item.
        -: 2218: *
        -: 2219: * c     connection requesting the operation
        -: 2220: * it    item to adjust
        -: 2221: * incr  true to increment value, false to decrement
        -: 2222: * delta amount to adjust value by
        -: 2223: * buf   buffer for response string
        -: 2224: *
        -: 2225: * returns a response string to send back to the client.
        -: 2226: */
      411: 2227:enum delta_result_type do_add_delta(LIBEVENT_THREAD *t, const char *key, const size_t nkey,
        -: 2228:                                    const bool incr, const int64_t delta,
        -: 2229:                                    char *buf, uint64_t *cas,
        -: 2230:                                    const uint32_t hv,
        -: 2231:                                    item **it_ret) {
      411: 2232:    char *ptr;
      411: 2233:    uint64_t value;
      411: 2234:    int res;
      411: 2235:    item *it;
        -: 2236:
      411: 2237:    it = do_item_get(key, nkey, hv, t, DONT_UPDATE);
      411: 2238:    if (!it) {
        -: 2239:        return DELTA_ITEM_NOT_FOUND;
        -: 2240:    }
        -: 2241:
        -: 2242:    /* Can't delta zero byte values. 2-byte are the "\r\n" */
        -: 2243:    /* Also can't delta for chunked items. Too large to be a number */
        -: 2244:#ifdef EXTSTORE
      340: 2245:    if (it->nbytes <= 2 || (it->it_flags & (ITEM_CHUNKED|ITEM_HDR)) != 0) {
        -: 2246:#else
        -: 2247:    if (it->nbytes <= 2 || (it->it_flags & (ITEM_CHUNKED)) != 0) {
        -: 2248:#endif
        1: 2249:        do_item_remove(it);
        1: 2250:        return NON_NUMERIC;
        -: 2251:    }
        -: 2252:
      339: 2253:    if (cas != NULL && *cas != 0 && ITEM_get_cas(it) != *cas) {
        1: 2254:        do_item_remove(it);
        1: 2255:        return DELTA_ITEM_CAS_MISMATCH;
        -: 2256:    }
        -: 2257:
      338: 2258:    ptr = ITEM_data(it);
        -: 2259:
      338: 2260:    if (!safe_strtoull(ptr, &value)) {
        4: 2261:        do_item_remove(it);
        4: 2262:        return NON_NUMERIC;
        -: 2263:    }
        -: 2264:
      334: 2265:    if (incr) {
      300: 2266:        value += delta;
        -: 2267:        //MEMCACHED_COMMAND_INCR(c->sfd, ITEM_key(it), it->nkey, value);
        -: 2268:    } else {
       34: 2269:        if(delta > value) {
        5: 2270:            value = 0;
        -: 2271:        } else {
       29: 2272:            value -= delta;
        -: 2273:        }
        -: 2274:        //MEMCACHED_COMMAND_DECR(c->sfd, ITEM_key(it), it->nkey, value);
        -: 2275:    }
        -: 2276:
      334: 2277:    pthread_mutex_lock(&t->stats.mutex);
      334: 2278:    if (incr) {
      300: 2279:        t->stats.slab_stats[ITEM_clsid(it)].incr_hits++;
        -: 2280:    } else {
       34: 2281:        t->stats.slab_stats[ITEM_clsid(it)].decr_hits++;
        -: 2282:    }
      334: 2283:    pthread_mutex_unlock(&t->stats.mutex);
        -: 2284:
      334: 2285:    itoa_u64(value, buf);
      334: 2286:    res = strlen(buf);
        -: 2287:    /* refcount == 2 means we are the only ones holding the item, and it is
        -: 2288:     * linked. We hold the item's lock in this function, so refcount cannot
        -: 2289:     * increase. */
      334: 2290:    if (res + 2 <= it->nbytes && it->refcount == 2) { /* replace in-place */
        -: 2291:        /* When changing the value without replacing the item, we
        -: 2292:           need to update the CAS on the existing item. */
        -: 2293:        /* We also need to fiddle it in the sizes tracker in case the tracking
        -: 2294:         * was enabled at runtime, since it relies on the CAS value to know
        -: 2295:         * whether to remove an item or not. */
       80: 2296:        item_stats_sizes_remove(it);
       80: 2297:        ITEM_set_cas(it, (settings.use_cas) ? get_cas_id() : 0);
       80: 2298:        item_stats_sizes_add(it);
       80: 2299:        memcpy(ITEM_data(it), buf, res);
       80: 2300:        memset(ITEM_data(it) + res, ' ', it->nbytes - res - 2);
       80: 2301:        do_item_update(it);
      254: 2302:    } else if (it->refcount > 1) {
      254: 2303:        item *new_it;
      254: 2304:        client_flags_t flags;
     254*: 2305:        FLAGS_CONV(it, flags);
      254: 2306:        new_it = do_item_alloc(ITEM_key(it), it->nkey, flags, it->exptime, res + 2);
      254: 2307:        if (new_it == 0) {
    #####: 2308:            do_item_remove(it);
    #####: 2309:            return EOM;
        -: 2310:        }
      254: 2311:        memcpy(ITEM_data(new_it), buf, res);
      254: 2312:        memcpy(ITEM_data(new_it) + res, "\r\n", 2);
      254: 2313:        item_replace(it, new_it, hv, (settings.use_cas) ? get_cas_id() : 0);
        -: 2314:        // Overwrite the older item's CAS with our new CAS since we're
        -: 2315:        // returning the CAS of the old item below.
      254: 2316:        ITEM_set_cas(it, (settings.use_cas) ? ITEM_get_cas(new_it) : 0);
      254: 2317:        do_item_remove(new_it);       /* release our reference */
        -: 2318:    } else {
        -: 2319:        /* Should never get here. This means we somehow fetched an unlinked
        -: 2320:         * item. TODO: Add a counter? */
    #####: 2321:        if (settings.verbose) {
    #####: 2322:            fprintf(stderr, "Tried to do incr/decr on invalid item\n");
        -: 2323:        }
    #####: 2324:        if (it->refcount == 1)
    #####: 2325:            do_item_remove(it);
    #####: 2326:        return DELTA_ITEM_NOT_FOUND;
        -: 2327:    }
        -: 2328:
      334: 2329:    if (cas) {
       67: 2330:        *cas = ITEM_get_cas(it);    /* swap the incoming CAS value */
        -: 2331:    }
      334: 2332:    if (it_ret != NULL) {
       10: 2333:        *it_ret = it;
        -: 2334:    } else {
      324: 2335:        do_item_remove(it);         /* release our reference */
        -: 2336:    }
        -: 2337:    return OK;
        -: 2338:}
        -: 2339:
      130: 2340:static int try_read_command_negotiate(conn *c) {
     130*: 2341:    assert(c != NULL);
     130*: 2342:    assert(c->protocol == negotiating_prot);
     130*: 2343:    assert(c->rcurr <= (c->rbuf + c->rsize));
     130*: 2344:    assert(c->rbytes > 0);
        -: 2345:
      130: 2346:    if ((unsigned char)c->rbuf[0] == (unsigned char)PROTOCOL_BINARY_REQ) {
        9: 2347:        c->protocol = binary_prot;
        9: 2348:        c->try_read_command = try_read_command_binary;
        -: 2349:    } else {
        -: 2350:        // authentication doesn't work with negotiated protocol.
      121: 2351:        c->protocol = ascii_prot;
      121: 2352:        c->try_read_command = try_read_command_ascii;
        -: 2353:    }
        -: 2354:
      130: 2355:    if (settings.verbose > 1) {
    #####: 2356:        fprintf(stderr, "%d: Client using the %s protocol\n", c->sfd,
        -: 2357:                prot_text(c->protocol));
        -: 2358:    }
        -: 2359:
      130: 2360:    return c->try_read_command(c);
        -: 2361:}
        -: 2362:
       18: 2363:static int try_read_command_udp(conn *c) {
      18*: 2364:    assert(c != NULL);
      18*: 2365:    assert(c->rcurr <= (c->rbuf + c->rsize));
      18*: 2366:    assert(c->rbytes > 0);
        -: 2367:
       18: 2368:    if ((unsigned char)c->rbuf[0] == (unsigned char)PROTOCOL_BINARY_REQ) {
        7: 2369:        c->protocol = binary_prot;
        7: 2370:        return try_read_command_binary(c);
        -: 2371:    } else {
       11: 2372:        c->protocol = ascii_prot;
       11: 2373:        return try_read_command_ascii(c);
        -: 2374:    }
        -: 2375:}
        -: 2376:
        -: 2377:/*
        -: 2378: * read a UDP request.
        -: 2379: */
       29: 2380:static enum try_read_result try_read_udp(conn *c) {
       29: 2381:    int res;
        -: 2382:
      29*: 2383:    assert(c != NULL);
        -: 2384:
       29: 2385:    c->request_addr_size = sizeof(c->request_addr);
       58: 2386:    res = recvfrom(c->sfd, c->rbuf, c->rsize,
       29: 2387:                   0, (struct sockaddr *)&c->request_addr,
        -: 2388:                   &c->request_addr_size);
       29: 2389:    if (res > 8) {
       18: 2390:        unsigned char *buf = (unsigned char *)c->rbuf;
       18: 2391:        pthread_mutex_lock(&c->thread->stats.mutex);
       18: 2392:        c->thread->stats.bytes_read += res;
       18: 2393:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 2394:
        -: 2395:        /* Beginning of UDP packet is the request ID; save it. */
       18: 2396:        c->request_id = buf[0] * 256 + buf[1];
        -: 2397:
        -: 2398:        /* If this is a multi-packet request, drop it. */
       18: 2399:        if (buf[4] != 0 || buf[5] != 1) {
        -: 2400:            return READ_NO_DATA_RECEIVED;
        -: 2401:        }
        -: 2402:
        -: 2403:        /* Don't care about any of the rest of the header. */
       18: 2404:        res -= 8;
       18: 2405:        memmove(c->rbuf, c->rbuf + 8, res);
        -: 2406:
       18: 2407:        c->rbytes = res;
       18: 2408:        c->rcurr = c->rbuf;
       18: 2409:        return READ_DATA_RECEIVED;
        -: 2410:    }
        -: 2411:    return READ_NO_DATA_RECEIVED;
        -: 2412:}
        -: 2413:
        -: 2414:/*
        -: 2415: * read from network as much as we can, handle buffer overflow and connection
        -: 2416: * close.
        -: 2417: * before reading, move the remaining incomplete fragment of a command
        -: 2418: * (if any) to the beginning of the buffer.
        -: 2419: *
        -: 2420: * To protect us from someone flooding a connection with bogus data causing
        -: 2421: * the connection to eat up all available memory, break out and start looking
        -: 2422: * at the data I've got after a number of reallocs...
        -: 2423: *
        -: 2424: * @return enum try_read_result
        -: 2425: */
   500022: 2426:static enum try_read_result try_read_network(conn *c) {
   500022: 2427:    enum try_read_result gotdata = READ_NO_DATA_RECEIVED;
   500022: 2428:    int res;
   500022: 2429:    int num_allocs = 0;
  500022*: 2430:    assert(c != NULL);
        -: 2431:
   500022: 2432:    if (c->rcurr != c->rbuf) {
     3686: 2433:        if (c->rbytes > 0) /* otherwise there's nothing to copy */
     3686: 2434:            memmove(c->rbuf, c->rcurr, c->rbytes);
     3686: 2435:        c->rcurr = c->rbuf;
        -: 2436:    }
        -: 2437:
   500025: 2438:    while (1) {
        -: 2439:        // TODO: move to rbuf_* func?
   500025: 2440:        if (c->rbytes >= c->rsize && c->rbuf_malloced) {
        3: 2441:            if (num_allocs == 4) {
    #####: 2442:                return gotdata;
        -: 2443:            }
        3: 2444:            ++num_allocs;
        3: 2445:            char *new_rbuf = realloc(c->rbuf, c->rsize * 2);
        3: 2446:            if (!new_rbuf) {
    #####: 2447:                STATS_LOCK();
    #####: 2448:                stats.malloc_fails++;
    #####: 2449:                STATS_UNLOCK();
    #####: 2450:                if (settings.verbose > 0) {
    #####: 2451:                    fprintf(stderr, "Couldn't realloc input buffer\n");
        -: 2452:                }
    #####: 2453:                c->rbytes = 0; /* ignore what we read */
    #####: 2454:                out_of_memory(c, "SERVER_ERROR out of memory reading request");
    #####: 2455:                c->close_after_write = true;
    #####: 2456:                return READ_MEMORY_ERROR;
        -: 2457:            }
        3: 2458:            c->rcurr = c->rbuf = new_rbuf;
        3: 2459:            c->rsize *= 2;
        -: 2460:        }
        -: 2461:
   500025: 2462:        int avail = c->rsize - c->rbytes;
   500025: 2463:        res = c->read(c, c->rbuf + c->rbytes, avail);
   500025: 2464:        if (res > 0) {
   497927: 2465:            pthread_mutex_lock(&c->thread->stats.mutex);
   497927: 2466:            c->thread->stats.bytes_read += res;
   497927: 2467:            pthread_mutex_unlock(&c->thread->stats.mutex);
   497927: 2468:            gotdata = READ_DATA_RECEIVED;
   497927: 2469:            c->rbytes += res;
   497927: 2470:            if (res == avail && c->rbuf_malloced) {
        -: 2471:                // Resize rbuf and try a few times if huge ascii multiget.
        3: 2472:                continue;
        -: 2473:            } else {
        -: 2474:                break;
        -: 2475:            }
        -: 2476:        }
     2098: 2477:        if (res == 0) {
     2097: 2478:            c->close_reason = NORMAL_CLOSE;
     2097: 2479:            return READ_ERROR;
        -: 2480:        }
        1: 2481:        if (res == -1) {
        1: 2482:            if (errno == EAGAIN || errno == EWOULDBLOCK) {
        -: 2483:                break;
        -: 2484:            }
        -: 2485:            return READ_ERROR;
        -: 2486:        }
        -: 2487:    }
        -: 2488:    return gotdata;
        -: 2489:}
        -: 2490:
   517109: 2491:static bool update_event(conn *c, const int new_flags) {
  517109*: 2492:    assert(c != NULL);
        -: 2493:
   517109: 2494:    struct event_base *base = c->event.ev_base;
   517109: 2495:    if (c->ev_flags == new_flags)
        -: 2496:        return true;
     1651: 2497:    if (event_del(&c->event) == -1) return false;
     1651: 2498:    event_set(&c->event, c->sfd, new_flags, event_handler, (void *)c);
     1651: 2499:    event_base_set(base, &c->event);
     1651: 2500:    c->ev_flags = new_flags;
     1651: 2501:    if (event_add(&c->event, 0) == -1) return false;
        -: 2502:    return true;
        -: 2503:}
        -: 2504:
        -: 2505:/*
        -: 2506: * Sets whether we are listening for new connections or not.
        -: 2507: */
    #####: 2508:void do_accept_new_conns(const bool do_accept) {
    #####: 2509:    conn *next;
        -: 2510:
    #####: 2511:    for (next = listen_conn; next; next = next->next) {
    #####: 2512:        if (do_accept) {
    #####: 2513:            update_event(next, EV_READ | EV_PERSIST);
    #####: 2514:            if (listen(next->sfd, settings.backlog) != 0) {
    #####: 2515:                perror("listen");
        -: 2516:            }
        -: 2517:        }
        -: 2518:        else {
    #####: 2519:            update_event(next, 0);
    #####: 2520:            if (listen(next->sfd, 0) != 0) {
    #####: 2521:                perror("listen");
        -: 2522:            }
        -: 2523:        }
        -: 2524:    }
        -: 2525:
    #####: 2526:    if (do_accept) {
    #####: 2527:        struct timeval maxconns_exited;
    #####: 2528:        uint64_t elapsed_us;
    #####: 2529:        gettimeofday(&maxconns_exited,NULL);
    #####: 2530:        STATS_LOCK();
    #####: 2531:        elapsed_us =
    #####: 2532:            (maxconns_exited.tv_sec - stats.maxconns_entered.tv_sec) * 1000000
    #####: 2533:            + (maxconns_exited.tv_usec - stats.maxconns_entered.tv_usec);
    #####: 2534:        stats.time_in_listen_disabled_us += elapsed_us;
    #####: 2535:        stats_state.accepting_conns = true;
    #####: 2536:        STATS_UNLOCK();
        -: 2537:    } else {
    #####: 2538:        STATS_LOCK();
    #####: 2539:        stats_state.accepting_conns = false;
    #####: 2540:        gettimeofday(&stats.maxconns_entered,NULL);
    #####: 2541:        stats.listen_disabled_num++;
    #####: 2542:        STATS_UNLOCK();
    #####: 2543:        allow_new_conns = false;
    #####: 2544:        maxconns_handler(-42, 0, 0);
        -: 2545:    }
    #####: 2546:}
        -: 2547:
        -: 2548:#define TRANSMIT_ONE_RESP true
        -: 2549:#define TRANSMIT_ALL_RESP false
   506607: 2550:static int _transmit_pre(conn *c, struct iovec *iovs, int iovused, bool one_resp) {
   506607: 2551:    mc_resp *resp = c->resp_head;
  1171000: 2552:    while (resp && iovused + resp->iovcnt < IOV_MAX-1) {
   664425: 2553:        if (resp->skip) {
        -: 2554:            // Don't actually unchain the resp obj here since it's singly-linked.
        -: 2555:            // Just let the post function handle it linearly.
   193661: 2556:            resp = resp->next;
   193661: 2557:            continue;
        -: 2558:        }
   470764: 2559:        if (resp->chunked_data_iov) {
        -: 2560:            // Handle chunked items specially.
        -: 2561:            // They spend much more time in send so we can be a bit wasteful
        -: 2562:            // in rebuilding iovecs for them.
    19406: 2563:            item_chunk *ch = (item_chunk *)ITEM_schunk((item *)resp->iov[resp->chunked_data_iov].iov_base);
    19406: 2564:            int x;
    77624: 2565:            for (x = 0; x < resp->iovcnt; x++) {
        -: 2566:                // This iov is tracking how far we've copied so far.
    58218: 2567:                if (x == resp->chunked_data_iov) {
    19406: 2568:                    int done = resp->chunked_total - resp->iov[x].iov_len;
        -: 2569:                    // Start from the len to allow binprot to cut the \r\n
    19406: 2570:                    int todo = resp->iov[x].iov_len;
   158985: 2571:                    while (ch && todo > 0 && iovused < IOV_MAX-1) {
   139579: 2572:                        int skip = 0;
   139579: 2573:                        if (!ch->used) {
    32926: 2574:                            ch = ch->next;
    32926: 2575:                            continue;
        -: 2576:                        }
        -: 2577:                        // Skip parts we've already sent.
   106653: 2578:                        if (done >= ch->used) {
     5875: 2579:                            done -= ch->used;
     5875: 2580:                            ch = ch->next;
     5875: 2581:                            continue;
   100778: 2582:                        } else if (done) {
        -: 2583:                            skip = done;
        -: 2584:                            done = 0;
        -: 2585:                        }
   100778: 2586:                        iovs[iovused].iov_base = ch->data + skip;
        -: 2587:                        // Stupid binary protocol makes this go negative.
   100778: 2588:                        iovs[iovused].iov_len = ch->used - skip > todo ? todo : ch->used - skip;
   100778: 2589:                        iovused++;
   100778: 2590:                        todo -= ch->used - skip;
   100778: 2591:                        ch = ch->next;
        -: 2592:                    }
        -: 2593:                } else {
    38812: 2594:                    iovs[iovused].iov_base = resp->iov[x].iov_base;
    38812: 2595:                    iovs[iovused].iov_len = resp->iov[x].iov_len;
    38812: 2596:                    iovused++;
        -: 2597:                }
    58218: 2598:                if (iovused >= IOV_MAX-1)
        -: 2599:                    break;
        -: 2600:            }
        -: 2601:        } else {
   451358: 2602:            memcpy(&iovs[iovused], resp->iov, sizeof(struct iovec)*resp->iovcnt);
   451358: 2603:            iovused += resp->iovcnt;
        -: 2604:        }
        -: 2605:
        -: 2606:        // done looking at first response, walk down the chain.
   470764: 2607:        resp = resp->next;
        -: 2608:        // used for UDP mode: UDP cannot send multiple responses per packet.
   470764: 2609:        if (one_resp)
        -: 2610:            break;
        -: 2611:    }
   506607: 2612:    return iovused;
        -: 2613:}
        -: 2614:
        -: 2615:/*
        -: 2616: * Decrements and completes responses based on how much data was transmitted.
        -: 2617: * Takes the connection and current result bytes.
        -: 2618: */
   506273: 2619:static void _transmit_post(conn *c, ssize_t res) {
        -: 2620:    // We've written some of the data. Remove the completed
        -: 2621:    // responses from the list of pending writes.
   506273: 2622:    mc_resp *resp = c->resp_head;
  1168943: 2623:    while (resp) {
   663069: 2624:        int x;
   663069: 2625:        if (resp->skip) {
   193661: 2626:            resp = resp_finish(c, resp);
   193661: 2627:            continue;
        -: 2628:        }
        -: 2629:
        -: 2630:        // fastpath check. all small responses should cut here.
   469408: 2631:        if (res >= resp->tosend) {
   469009: 2632:            res -= resp->tosend;
   469009: 2633:            resp = resp_finish(c, resp);
   469009: 2634:            continue;
        -: 2635:        }
        -: 2636:
        -: 2637:        // it's fine to re-check iov's that were zeroed out before.
      873: 2638:        for (x = 0; x < resp->iovcnt; x++) {
      873: 2639:            struct iovec *iov = &resp->iov[x];
      873: 2640:            if (res >= iov->iov_len) {
      474: 2641:                resp->tosend -= iov->iov_len;
      474: 2642:                res -= iov->iov_len;
      474: 2643:                iov->iov_len = 0;
        -: 2644:            } else {
        -: 2645:                // Dumb special case for chunked items. Currently tracking
        -: 2646:                // where to inject the chunked item via iov_base.
        -: 2647:                // Extra not-great since chunked items can't be the first
        -: 2648:                // index, so we have to check for non-zero c_d_iov first.
      399: 2649:                if (!resp->chunked_data_iov || x != resp->chunked_data_iov) {
      171: 2650:                    iov->iov_base = (char *)iov->iov_base + res;
        -: 2651:                }
      399: 2652:                iov->iov_len -= res;
      399: 2653:                resp->tosend -= res;
      399: 2654:                res = 0;
      399: 2655:                break;
        -: 2656:            }
        -: 2657:        }
        -: 2658:
        -: 2659:        // are we done with this response object?
      399: 2660:        if (resp->tosend == 0) {
    #####: 2661:            resp = resp_finish(c, resp);
        -: 2662:        } else {
        -: 2663:            // Jammed up here. This is the new head.
        -: 2664:            break;
        -: 2665:        }
        -: 2666:    }
   506273: 2667:}
        -: 2668:
        -: 2669:/*
        -: 2670: * Transmit the next chunk of data from our list of msgbuf structures.
        -: 2671: *
        -: 2672: * Returns:
        -: 2673: *   TRANSMIT_COMPLETE   All done writing.
        -: 2674: *   TRANSMIT_INCOMPLETE More data remaining to write.
        -: 2675: *   TRANSMIT_SOFT_ERROR Can't write any more right now.
        -: 2676: *   TRANSMIT_HARD_ERROR Can't write (c->state is set to conn_closing)
        -: 2677: */
   506575: 2678:static enum transmit_result transmit(conn *c) {
  506575*: 2679:    assert(c != NULL);
   506575: 2680:    struct iovec iovs[IOV_MAX];
   506575: 2681:    struct msghdr msg;
   506575: 2682:    int iovused = 0;
        -: 2683:
        -: 2684:    // init the msg.
   506575: 2685:    memset(&msg, 0, sizeof(struct msghdr));
   506575: 2686:    msg.msg_iov = iovs;
        -: 2687:
   506575: 2688:    iovused = _transmit_pre(c, iovs, iovused, TRANSMIT_ALL_RESP);
   506575: 2689:    if (iovused == 0) {
        -: 2690:        // Avoid the syscall if we're only handling a noreply.
        -: 2691:        // Return the response object.
    78128: 2692:        _transmit_post(c, 0);
    78128: 2693:        return TRANSMIT_COMPLETE;
        -: 2694:    }
        -: 2695:
        -: 2696:    // Alright, send.
   428447: 2697:    ssize_t res;
   428447: 2698:    msg.msg_iovlen = iovused;
   428447: 2699:    res = c->sendmsg(c, &msg, 0);
   428447: 2700:    if (res >= 0) {
   428113: 2701:        pthread_mutex_lock(&c->thread->stats.mutex);
   428113: 2702:        c->thread->stats.bytes_written += res;
   428113: 2703:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 2704:
        -: 2705:        // Decrement any partial IOV's and complete any finished resp's.
   428113: 2706:        _transmit_post(c, res);
        -: 2707:
   428113: 2708:        if (c->resp_head) {
        -: 2709:            return TRANSMIT_INCOMPLETE;
        -: 2710:        } else {
        -: 2711:            return TRANSMIT_COMPLETE;
        -: 2712:        }
        -: 2713:    }
        -: 2714:
      334: 2715:    if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {
      332: 2716:        if (!update_event(c, EV_WRITE | EV_PERSIST)) {
    #####: 2717:            if (settings.verbose > 0)
    #####: 2718:                fprintf(stderr, "Couldn't update event\n");
    #####: 2719:            conn_set_state(c, conn_closing);
    #####: 2720:            return TRANSMIT_HARD_ERROR;
        -: 2721:        }
        -: 2722:        return TRANSMIT_SOFT_ERROR;
        -: 2723:    }
        -: 2724:    /* if res == -1 and error is not EAGAIN or EWOULDBLOCK,
        -: 2725:       we have a real error, on which we close the connection */
        2: 2726:    if (settings.verbose > 0)
    #####: 2727:        perror("Failed to write, and not due to blocking");
        -: 2728:
        2: 2729:    conn_set_state(c, conn_closing);
        2: 2730:    return TRANSMIT_HARD_ERROR;
        -: 2731:}
        -: 2732:
       32: 2733:static void build_udp_header(unsigned char *hdr, mc_resp *resp) {
        -: 2734:    // We need to communicate the total number of packets
        -: 2735:    // If this isn't set, it's the first time this response is building a udp
        -: 2736:    // header, so "tosend" must be static.
       32: 2737:    if (!resp->udp_total) {
       18: 2738:        uint32_t total;
       18: 2739:        total = resp->tosend / UDP_DATA_SIZE;
       18: 2740:        if (resp->tosend % UDP_DATA_SIZE)
       18: 2741:            total++;
        -: 2742:        // The spec doesn't really say what we should do here. It's _probably_
        -: 2743:        // better to bail out?
       18: 2744:        if (total > USHRT_MAX) {
        -: 2745:            total = USHRT_MAX;
        -: 2746:        }
       18: 2747:        resp->udp_total = total;
        -: 2748:    }
        -: 2749:
        -: 2750:    // TODO: why wasn't this hto*'s and casts?
        -: 2751:    // this ends up sending UDP hdr data specifically in host byte order.
       32: 2752:    *hdr++ = resp->request_id / 256;
       32: 2753:    *hdr++ = resp->request_id % 256;
       32: 2754:    *hdr++ = resp->udp_sequence / 256;
       32: 2755:    *hdr++ = resp->udp_sequence % 256;
       32: 2756:    *hdr++ = resp->udp_total / 256;
       32: 2757:    *hdr++ = resp->udp_total % 256;
       32: 2758:    *hdr++ = 0;
       32: 2759:    *hdr++ = 0;
       32: 2760:    resp->udp_sequence++;
       32: 2761:}
        -: 2762:
        -: 2763:/*
        -: 2764: * UDP specific transmit function. Uses its own function rather than check
        -: 2765: * IS_UDP() five times. If we ever implement sendmmsg or similar support they
        -: 2766: * will diverge even more.
        -: 2767: * Does not use TLS.
        -: 2768: *
        -: 2769: * Returns:
        -: 2770: *   TRANSMIT_COMPLETE   All done writing.
        -: 2771: *   TRANSMIT_INCOMPLETE More data remaining to write.
        -: 2772: *   TRANSMIT_SOFT_ERROR Can't write any more right now.
        -: 2773: *   TRANSMIT_HARD_ERROR Can't write (c->state is set to conn_closing)
        -: 2774: */
       32: 2775:static enum transmit_result transmit_udp(conn *c) {
      32*: 2776:    assert(c != NULL);
       32: 2777:    struct iovec iovs[IOV_MAX];
       32: 2778:    struct msghdr msg;
       32: 2779:    mc_resp *resp;
       32: 2780:    int iovused = 0;
       32: 2781:    unsigned char udp_hdr[UDP_HEADER_SIZE];
        -: 2782:
        -: 2783:    // We only send one UDP packet per call (ugh), so we can only operate on a
        -: 2784:    // single response at a time.
       32: 2785:    resp = c->resp_head;
        -: 2786:
       32: 2787:    if (!resp) {
        -: 2788:        return TRANSMIT_COMPLETE;
        -: 2789:    }
        -: 2790:
       32: 2791:    if (resp->skip) {
    #####: 2792:        resp = resp_finish(c, resp);
    #####: 2793:        return TRANSMIT_INCOMPLETE;
        -: 2794:    }
        -: 2795:
        -: 2796:    // clear the message and initialize it.
       32: 2797:    memset(&msg, 0, sizeof(struct msghdr));
       32: 2798:    msg.msg_iov = iovs;
        -: 2799:
        -: 2800:    // the UDP source to return to.
       32: 2801:    msg.msg_name = &resp->request_addr;
       32: 2802:    msg.msg_namelen = resp->request_addr_size;
        -: 2803:
        -: 2804:    // First IOV is the custom UDP header.
       32: 2805:    iovs[0].iov_base = (void *)udp_hdr;
       32: 2806:    iovs[0].iov_len = UDP_HEADER_SIZE;
       32: 2807:    build_udp_header(udp_hdr, resp);
       32: 2808:    iovused++;
        -: 2809:
        -: 2810:    // Fill the IOV's the standard way.
        -: 2811:    // TODO: might get a small speedup if we let it break early with a length
        -: 2812:    // limit.
       32: 2813:    iovused = _transmit_pre(c, iovs, iovused, TRANSMIT_ONE_RESP);
        -: 2814:
        -: 2815:    // Clip the IOV's to the max UDP packet size.
        -: 2816:    // If we add support for send_mmsg, this can be where we split msg's.
        -: 2817:    {
       32: 2818:        int x = 0;
       32: 2819:        int len = 0;
      143: 2820:        for (x = 0; x < iovused; x++) {
       93: 2821:            if (len + iovs[x].iov_len >= UDP_MAX_PAYLOAD_SIZE) {
       14: 2822:                iovs[x].iov_len = UDP_MAX_PAYLOAD_SIZE - len;
       14: 2823:                x++;
       14: 2824:                break;
        -: 2825:            } else {
       79: 2826:                len += iovs[x].iov_len;
        -: 2827:            }
        -: 2828:        }
       32: 2829:        iovused = x;
        -: 2830:    }
        -: 2831:
       32: 2832:    ssize_t res;
       32: 2833:    msg.msg_iovlen = iovused;
        -: 2834:    // NOTE: uses system sendmsg since we have no support for indirect UDP.
       32: 2835:    res = sendmsg(c->sfd, &msg, 0);
       32: 2836:    if (res >= 0) {
       32: 2837:        pthread_mutex_lock(&c->thread->stats.mutex);
       32: 2838:        c->thread->stats.bytes_written += res;
       32: 2839:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 2840:
        -: 2841:        // Ignore the header size from forwarding the IOV's
       32: 2842:        res -= UDP_HEADER_SIZE;
        -: 2843:
        -: 2844:        // Decrement any partial IOV's and complete any finished resp's.
       32: 2845:        _transmit_post(c, res);
        -: 2846:
       32: 2847:        if (c->resp_head) {
        -: 2848:            return TRANSMIT_INCOMPLETE;
        -: 2849:        } else {
        -: 2850:            return TRANSMIT_COMPLETE;
        -: 2851:        }
        -: 2852:    }
        -: 2853:
    #####: 2854:    if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {
    #####: 2855:        if (!update_event(c, EV_WRITE | EV_PERSIST)) {
    #####: 2856:            if (settings.verbose > 0)
    #####: 2857:                fprintf(stderr, "Couldn't update event\n");
    #####: 2858:            conn_set_state(c, conn_closing);
    #####: 2859:            return TRANSMIT_HARD_ERROR;
        -: 2860:        }
        -: 2861:        return TRANSMIT_SOFT_ERROR;
        -: 2862:    }
        -: 2863:    /* if res == -1 and error is not EAGAIN or EWOULDBLOCK,
        -: 2864:       we have a real error, on which we close the connection */
    #####: 2865:    if (settings.verbose > 0)
    #####: 2866:        perror("Failed to write, and not due to blocking");
        -: 2867:
    #####: 2868:    conn_set_state(c, conn_read);
    #####: 2869:    return TRANSMIT_HARD_ERROR;
        -: 2870:}
        -: 2871:
        -: 2872:
        -: 2873:/* Does a looped read to fill data chunks */
        -: 2874:/* TODO: restrict number of times this can loop.
        -: 2875: * Also, benchmark using readv's.
        -: 2876: */
    10365: 2877:static int read_into_chunked_item(conn *c) {
    10365: 2878:    int total = 0;
    10365: 2879:    int res;
   10365*: 2880:    assert(c->rcurr != c->ritem);
        -: 2881:
   104898: 2882:    while (c->rlbytes > 0) {
    99916: 2883:        item_chunk *ch = (item_chunk *)c->ritem;
    99916: 2884:        if (ch->size == ch->used) {
        -: 2885:            // FIXME: ch->next is currently always 0. remove this?
    42020: 2886:            if (ch->next) {
    #####: 2887:                c->ritem = (char *) ch->next;
        -: 2888:            } else {
        -: 2889:                /* Allocate next chunk. Binary protocol needs 2b for \r\n */
    42020: 2890:                c->ritem = (char *) do_item_alloc_chunk(ch, c->rlbytes +
    42020: 2891:                       ((c->protocol == binary_prot) ? 2 : 0));
    42020: 2892:                if (!c->ritem) {
        -: 2893:                    // We failed an allocation. Let caller handle cleanup.
        -: 2894:                    total = -2;
        -: 2895:                    break;
        -: 2896:                }
        -: 2897:                // ritem has new chunk, restart the loop.
    42020: 2898:                continue;
        -: 2899:                //assert(c->rlbytes == 0);
        -: 2900:            }
        -: 2901:        }
        -: 2902:
    57896: 2903:        int unused = ch->size - ch->used;
        -: 2904:        /* first check if we have leftovers in the conn_read buffer */
    57896: 2905:        if (c->rbytes > 0) {
    17692: 2906:            total = 0;
    17692: 2907:            int tocopy = c->rbytes > c->rlbytes ? c->rlbytes : c->rbytes;
    17692: 2908:            tocopy = tocopy > unused ? unused : tocopy;
    17692: 2909:            if (c->ritem != c->rcurr) {
    17692: 2910:                memmove(ch->data + ch->used, c->rcurr, tocopy);
        -: 2911:            }
    17692: 2912:            total += tocopy;
    17692: 2913:            c->rlbytes -= tocopy;
    17692: 2914:            c->rcurr += tocopy;
    17692: 2915:            c->rbytes -= tocopy;
    17692: 2916:            ch->used += tocopy;
    17692: 2917:            if (c->rlbytes == 0) {
        -: 2918:                break;
        -: 2919:            }
        -: 2920:        } else {
        -: 2921:            /*  now try reading from the socket */
    80408: 2922:            res = c->read(c, ch->data + ch->used,
    40204: 2923:                    (unused > c->rlbytes ? c->rlbytes : unused));
    40204: 2924:            if (res > 0) {
    37572: 2925:                pthread_mutex_lock(&c->thread->stats.mutex);
    37572: 2926:                c->thread->stats.bytes_read += res;
    37572: 2927:                pthread_mutex_unlock(&c->thread->stats.mutex);
    37572: 2928:                ch->used += res;
    37572: 2929:                total += res;
    37572: 2930:                c->rlbytes -= res;
        -: 2931:            } else {
        -: 2932:                /* Reset total to the latest result so caller can handle it */
        -: 2933:                total = res;
        -: 2934:                break;
        -: 2935:            }
        -: 2936:        }
        -: 2937:    }
        -: 2938:
        -: 2939:    /* At some point I will be able to ditch the \r\n from item storage and
        -: 2940:       remove all of these kludges.
        -: 2941:       The above binprot check ensures inline space for \r\n, but if we do
        -: 2942:       exactly enough allocs there will be no additional chunk for \r\n.
        -: 2943:     */
    10365: 2944:    if (c->rlbytes == 0 && c->protocol == binary_prot && total >= 0) {
      202: 2945:        item_chunk *ch = (item_chunk *)c->ritem;
      202: 2946:        if (ch->size - ch->used < 2) {
        2: 2947:            c->ritem = (char *) do_item_alloc_chunk(ch, 2);
        2: 2948:            if (!c->ritem) {
    10365: 2949:                total = -2;
        -: 2950:            }
        -: 2951:        }
        -: 2952:    }
    10365: 2953:    return total;
        -: 2954:}
        -: 2955:
   523113: 2956:static void drive_machine(conn *c) {
   523113: 2957:    bool stop = false;
   523113: 2958:    int sfd;
   523113: 2959:    socklen_t addrlen;
   523113: 2960:    struct sockaddr_storage addr;
   523113: 2961:    int nreqs = settings.reqs_per_event;
   523113: 2962:    int res;
   523113: 2963:    const char *str;
        -: 2964:#ifdef HAVE_ACCEPT4
   523113: 2965:    static int  use_accept4 = 1;
        -: 2966:#else
        -: 2967:    static int  use_accept4 = 0;
        -: 2968:#endif
        -: 2969:
  523113*: 2970:    assert(c != NULL);
        -: 2971:
  4583204: 2972:    while (!stop) {
        -: 2973:
  4060091: 2974:        switch(c->state) {
     2195: 2975:        case conn_listening:
     2195: 2976:            addrlen = sizeof(addr);
        -: 2977:#ifdef HAVE_ACCEPT4
     2195: 2978:            if (use_accept4) {
     2195: 2979:                sfd = accept4(c->sfd, (struct sockaddr *)&addr, &addrlen, SOCK_NONBLOCK);
        -: 2980:            } else {
    #####: 2981:                sfd = accept(c->sfd, (struct sockaddr *)&addr, &addrlen);
        -: 2982:            }
        -: 2983:#else
        -: 2984:            sfd = accept(c->sfd, (struct sockaddr *)&addr, &addrlen);
        -: 2985:#endif
     2195: 2986:            if (sfd == -1) {
    #####: 2987:                if (use_accept4 && errno == ENOSYS) {
    #####: 2988:                    use_accept4 = 0;
    #####: 2989:                    continue;
        -: 2990:                }
    #####: 2991:                perror(use_accept4 ? "accept4()" : "accept()");
    #####: 2992:                if (errno == EAGAIN || errno == EWOULDBLOCK) {
        -: 2993:                    /* these are transient, so don't log anything */
        -: 2994:                    stop = true;
    #####: 2995:                } else if (errno == EMFILE) {
    #####: 2996:                    if (settings.verbose > 0)
    #####: 2997:                        fprintf(stderr, "Too many open connections\n");
    #####: 2998:                    accept_new_conns(false);
    #####: 2999:                    stop = true;
        -: 3000:                } else {
    #####: 3001:                    perror("accept()");
    #####: 3002:                    stop = true;
        -: 3003:                }
        -: 3004:                break;
        -: 3005:            }
     2195: 3006:            if (!use_accept4) {
    #####: 3007:                if (fcntl(sfd, F_SETFL, fcntl(sfd, F_GETFL) | O_NONBLOCK) < 0) {
    #####: 3008:                    perror("setting O_NONBLOCK");
    #####: 3009:                    close(sfd);
    #####: 3010:                    break;
        -: 3011:                }
        -: 3012:            }
        -: 3013:
     2195: 3014:            bool reject;
     2195: 3015:            if (settings.maxconns_fast) {
     2186: 3016:                reject = sfd >= settings.maxconns - 1;
     2186: 3017:                if (reject) {
       59: 3018:                    STATS_LOCK();
       59: 3019:                    stats.rejected_conns++;
       59: 3020:                    STATS_UNLOCK();
        -: 3021:                }
        -: 3022:            } else {
        -: 3023:                reject = false;
        -: 3024:            }
        -: 3025:
     2186: 3026:            if (reject) {
       59: 3027:                str = "ERROR Too many open connections\r\n";
       59: 3028:                res = write(sfd, str, strlen(str));
       59: 3029:                close(sfd);
        -: 3030:            } else {
        -: 3031:                // run accept routine if ssl is compiled + enabled
     2136: 3032:                bool fail = false;
     2136: 3033:                void *ssl_v = ssl_accept(c, sfd, &fail);
     2136: 3034:                if (fail) {
        -: 3035:                    close(sfd);
        -: 3036:                    break;
        -: 3037:                }
        -: 3038:
     2136: 3039:                dispatch_conn_new(sfd, conn_new_cmd, EV_READ | EV_PERSIST,
        -: 3040:                                     READ_BUFFER_CACHED, c->transport, ssl_v, c->tag, c->protocol);
        -: 3041:            }
        -: 3042:
        -: 3043:            stop = true;
        -: 3044:            break;
        -: 3045:
   500054: 3046:        case conn_waiting:
   500054: 3047:            rbuf_release(c);
   500054: 3048:            if (!update_event(c, EV_READ | EV_PERSIST)) {
    #####: 3049:                if (settings.verbose > 0)
    #####: 3050:                    fprintf(stderr, "Couldn't update event\n");
    #####: 3051:                conn_set_state(c, conn_closing);
    #####: 3052:                break;
        -: 3053:            }
        -: 3054:
   500054: 3055:            conn_set_state(c, conn_read);
   500054: 3056:            stop = true;
   500054: 3057:            break;
        -: 3058:
   500051: 3059:        case conn_read:
   500051: 3060:            if (!IS_UDP(c->transport)) {
        -: 3061:                // Assign a read buffer if necessary.
   500022: 3062:                if (!rbuf_alloc(c)) {
        -: 3063:                    // TODO: Some way to allow for temporary failures.
    #####: 3064:                    conn_set_state(c, conn_closing);
    #####: 3065:                    break;
        -: 3066:                }
   500022: 3067:                res = try_read_network(c);
        -: 3068:            } else {
        -: 3069:                // UDP connections always have a static buffer.
       29: 3070:                res = try_read_udp(c);
        -: 3071:            }
        -: 3072:
   500051: 3073:            switch (res) {
       11: 3074:            case READ_NO_DATA_RECEIVED:
       11: 3075:                conn_set_state(c, conn_waiting);
       11: 3076:                break;
   497942: 3077:            case READ_DATA_RECEIVED:
   497942: 3078:                conn_set_state(c, conn_parse_cmd);
   497942: 3079:                break;
     2098: 3080:            case READ_ERROR:
     2098: 3081:                conn_set_state(c, conn_closing);
     2098: 3082:                break;
        -: 3083:            case READ_MEMORY_ERROR: /* Failed to allocate more memory */
        -: 3084:                /* State already set by try_read_network */
        -: 3085:                break;
        -: 3086:            }
        -: 3087:            break;
        -: 3088:
   650654: 3089:        case conn_parse_cmd:
   650654: 3090:            c->noreply = false;
   650654: 3091:            if (c->try_read_command(c) == 0) {
        -: 3092:                /* we need more data! */
     7359: 3093:                if (c->resp_head) {
        -: 3094:                    // Buffered responses waiting, flush in the meantime.
     3668: 3095:                    conn_set_state(c, conn_mwrite);
        -: 3096:                } else {
     3691: 3097:                    conn_set_state(c, conn_waiting);
        -: 3098:                }
        -: 3099:            }
        -: 3100:
        -: 3101:            break;
        -: 3102:
  1151663: 3103:        case conn_new_cmd:
        -: 3104:            /* Only process nreqs at a time to avoid starving other
        -: 3105:               connections */
        -: 3106:
  1151663: 3107:            --nreqs;
  1151663: 3108:            if (nreqs >= 0) {
  1141935: 3109:                reset_cmd_handler(c);
     9728: 3110:            } else if (c->resp_head) {
        -: 3111:                // flush response pipe on yield.
     4770: 3112:                conn_set_state(c, conn_mwrite);
        -: 3113:            } else {
     4958: 3114:                pthread_mutex_lock(&c->thread->stats.mutex);
     4958: 3115:                c->thread->stats.conn_yields++;
     4958: 3116:                pthread_mutex_unlock(&c->thread->stats.mutex);
     4958: 3117:                if (c->rbytes > 0) {
        -: 3118:                    /* We have already read in data into the input buffer,
        -: 3119:                       so libevent will most likely not signal read events
        -: 3120:                       on the socket (unless more data is available. As a
        -: 3121:                       hack we should just put in a request to write data,
        -: 3122:                       because that should be possible ;-)
        -: 3123:                    */
     4890: 3124:                    if (!update_event(c, EV_WRITE | EV_PERSIST)) {
    #####: 3125:                        if (settings.verbose > 0)
    #####: 3126:                            fprintf(stderr, "Couldn't update event\n");
    #####: 3127:                        conn_set_state(c, conn_closing);
    #####: 3128:                        break;
        -: 3129:                    }
        -: 3130:                }
        -: 3131:                stop = true;
        -: 3132:            }
        -: 3133:            break;
        -: 3134:
   742656: 3135:        case conn_nread:
   742656: 3136:            if (c->rlbytes == 0) {
   359975: 3137:                complete_nread(c);
   359975: 3138:                break;
        -: 3139:            }
        -: 3140:
        -: 3141:            /* Check if rbytes < 0, to prevent crash */
   382681: 3142:            if (c->rlbytes < 0) {
    #####: 3143:                if (settings.verbose) {
    #####: 3144:                    fprintf(stderr, "Invalid rlbytes to read: len %d\n", c->rlbytes);
        -: 3145:                }
    #####: 3146:                conn_set_state(c, conn_closing);
    #####: 3147:                break;
        -: 3148:            }
        -: 3149:
   382681: 3150:            if (c->item_malloced || ((((item *)c->item)->it_flags & ITEM_CHUNKED) == 0) ) {
        -: 3151:                /* first check if we have leftovers in the conn_read buffer */
   372316: 3152:                if (c->rbytes > 0) {
   352154: 3153:                    int tocopy = c->rbytes > c->rlbytes ? c->rlbytes : c->rbytes;
   352154: 3154:                    memmove(c->ritem, c->rcurr, tocopy);
   352154: 3155:                    c->ritem += tocopy;
   352154: 3156:                    c->rlbytes -= tocopy;
   352154: 3157:                    c->rcurr += tocopy;
   352154: 3158:                    c->rbytes -= tocopy;
   352154: 3159:                    if (c->rlbytes == 0) {
        -: 3160:                        break;
        -: 3161:                    }
        -: 3162:                }
        -: 3163:
        -: 3164:                /*  now try reading from the socket */
    90810: 3165:                res = c->read(c, c->ritem, c->rlbytes);
    90810: 3166:                if (res > 0) {
    81809: 3167:                    pthread_mutex_lock(&c->thread->stats.mutex);
    81809: 3168:                    c->thread->stats.bytes_read += res;
    81809: 3169:                    pthread_mutex_unlock(&c->thread->stats.mutex);
    81809: 3170:                    if (c->rcurr == c->ritem) {
    #####: 3171:                        c->rcurr += res;
        -: 3172:                    }
    81809: 3173:                    c->ritem += res;
    81809: 3174:                    c->rlbytes -= res;
    81809: 3175:                    break;
        -: 3176:                }
        -: 3177:            } else {
    10365: 3178:                res = read_into_chunked_item(c);
    10365: 3179:                if (res > 0)
        -: 3180:                    break;
        -: 3181:            }
        -: 3182:
    11633: 3183:            if (res == 0) { /* end of stream */
        2: 3184:                c->close_reason = NORMAL_CLOSE;
        2: 3185:                conn_set_state(c, conn_closing);
        2: 3186:                break;
        -: 3187:            }
        -: 3188:
    11631: 3189:            if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {
    11631: 3190:                if (!update_event(c, EV_READ | EV_PERSIST)) {
    #####: 3191:                    if (settings.verbose > 0)
    #####: 3192:                        fprintf(stderr, "Couldn't update event\n");
    #####: 3193:                    conn_set_state(c, conn_closing);
    #####: 3194:                    break;
        -: 3195:                }
        -: 3196:                stop = true;
        -: 3197:                break;
        -: 3198:            }
        -: 3199:
        -: 3200:            /* Memory allocation failure */
    #####: 3201:            if (res == -2) {
    #####: 3202:                out_of_memory(c, "SERVER_ERROR Out of memory during read");
    #####: 3203:                c->sbytes = c->rlbytes;
    #####: 3204:                conn_set_state(c, conn_swallow);
        -: 3205:                // Ensure this flag gets cleared. It gets killed on conn_new()
        -: 3206:                // so any conn_closing is fine, calling complete_nread is
        -: 3207:                // fine. This swallow semms to be the only other case.
    #####: 3208:                c->set_stale = false;
    #####: 3209:                c->mset_res = false;
    #####: 3210:                break;
        -: 3211:            }
        -: 3212:            /* otherwise we have a real error, on which we close the connection */
    #####: 3213:            if (settings.verbose > 0) {
    #####: 3214:                fprintf(stderr, "Failed to read, and not due to blocking:\n"
        -: 3215:                        "errno: %d %s \n"
        -: 3216:                        "rcurr=%p ritem=%p rbuf=%p rlbytes=%d rsize=%d\n",
    #####: 3217:                        errno, strerror(errno),
    #####: 3218:                        (void *)c->rcurr, (void *)c->ritem, (void *)c->rbuf,
        -: 3219:                        (int)c->rlbytes, (int)c->rsize);
        -: 3220:            }
    #####: 3221:            conn_set_state(c, conn_closing);
    #####: 3222:            break;
        -: 3223:
      877: 3224:        case conn_swallow:
        -: 3225:            /* we are reading sbytes and throwing them away */
      877: 3226:            if (c->sbytes <= 0) {
       12: 3227:                conn_set_state(c, conn_new_cmd);
       12: 3228:                break;
        -: 3229:            }
        -: 3230:
        -: 3231:            /* first check if we have leftovers in the conn_read buffer */
      865: 3232:            if (c->rbytes > 0) {
       11: 3233:                int tocopy = c->rbytes > c->sbytes ? c->sbytes : c->rbytes;
       11: 3234:                c->sbytes -= tocopy;
       11: 3235:                c->rcurr += tocopy;
       11: 3236:                c->rbytes -= tocopy;
       11: 3237:                break;
        -: 3238:            }
        -: 3239:
        -: 3240:            /*  now try reading from the socket */
      854: 3241:            res = c->read(c, c->rbuf, c->rsize > c->sbytes ? c->sbytes : c->rsize);
      854: 3242:            if (res > 0) {
      652: 3243:                pthread_mutex_lock(&c->thread->stats.mutex);
      652: 3244:                c->thread->stats.bytes_read += res;
      652: 3245:                pthread_mutex_unlock(&c->thread->stats.mutex);
      652: 3246:                c->sbytes -= res;
      652: 3247:                break;
        -: 3248:            }
      202: 3249:            if (res == 0) { /* end of stream */
    #####: 3250:                c->close_reason = NORMAL_CLOSE;
    #####: 3251:                conn_set_state(c, conn_closing);
    #####: 3252:                break;
        -: 3253:            }
      202: 3254:            if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {
      202: 3255:                if (!update_event(c, EV_READ | EV_PERSIST)) {
    #####: 3256:                    if (settings.verbose > 0)
    #####: 3257:                        fprintf(stderr, "Couldn't update event\n");
    #####: 3258:                    conn_set_state(c, conn_closing);
    #####: 3259:                    break;
        -: 3260:                }
        -: 3261:                stop = true;
        -: 3262:                break;
        -: 3263:            }
        -: 3264:            /* otherwise we have a real error, on which we close the connection */
    #####: 3265:            if (settings.verbose > 0)
    #####: 3266:                fprintf(stderr, "Failed to read, and not due to blocking\n");
    #####: 3267:            conn_set_state(c, conn_closing);
    #####: 3268:            break;
        -: 3269:
   508200: 3270:        case conn_write:
        -: 3271:        case conn_mwrite:
        -: 3272:            /* have side IO's that must process before transmit() can run.
        -: 3273:             * remove the connection from the worker thread and dispatch the
        -: 3274:             * IO queue
        -: 3275:             */
   508200: 3276:            if (c->resps_suspended) {
     1593: 3277:                LIBEVENT_THREAD *t = c->thread;
        -: 3278:                // FIXME: carefully check or document somewhere that submit
        -: 3279:                // cannot resume a connection in-line with submission.
     1593: 3280:                conn_set_state(c, conn_io_queue);
     1593: 3281:                if (t->conns_tosubmit++ > 20) {
        -: 3282:                    // Run occasional batches, else submit outside event loop.
    #####: 3283:                    thread_io_queue_submit(c->thread);
        -: 3284:                }
        -: 3285:
        -: 3286:                stop = true;
        -: 3287:                break;
        -: 3288:            }
        -: 3289:
   506607: 3290:            switch (!IS_UDP(c->transport) ? transmit(c) : transmit_udp(c)) {
   505874: 3291:            case TRANSMIT_COMPLETE:
   505874: 3292:                if (c->state == conn_mwrite) {
        -: 3293:                    // Free up IO wraps and any half-uploaded items.
   505874: 3294:                    conn_release_items(c);
   505874: 3295:                    conn_set_state(c, conn_new_cmd);
   505874: 3296:                    if (c->close_after_write) {
        8: 3297:                        conn_set_state(c, conn_closing);
        -: 3298:                    }
        -: 3299:                } else {
    #####: 3300:                    if (settings.verbose > 0)
    #####: 3301:                        fprintf(stderr, "Unexpected state %d\n", c->state);
    #####: 3302:                    conn_set_state(c, conn_closing);
        -: 3303:                }
        -: 3304:                break;
        -: 3305:
        -: 3306:            case TRANSMIT_INCOMPLETE:
        -: 3307:            case TRANSMIT_HARD_ERROR:
        -: 3308:                break;                   /* Continue in state machine. */
        -: 3309:
        -: 3310:            case TRANSMIT_SOFT_ERROR:
  4060078: 3311:                stop = true;
        -: 3312:                break;
        -: 3313:            }
        -: 3314:            break;
        -: 3315:
     2134: 3316:        case conn_closing:
     2134: 3317:            if (IS_UDP(c->transport))
    #####: 3318:                conn_cleanup(c);
        -: 3319:            else
     2134: 3320:                conn_close(c);
        -: 3321:            stop = true;
        -: 3322:            break;
        -: 3323:
    #####: 3324:        case conn_closed:
        -: 3325:            /* This only happens if dormando is an idiot. */
    #####: 3326:            abort();
        -: 3327:            break;
        -: 3328:
        -: 3329:        case conn_watch:
        -: 3330:            /* We handed off our connection to the logger thread. */
  4583204: 3331:            stop = true;
        -: 3332:            break;
        1: 3333:        case conn_io_queue:
        -: 3334:            /* Woke up while waiting for an async return, but not ready. */
        1: 3335:            event_del(&c->event);
        1: 3336:            conn_set_state(c, conn_io_pending);
        1: 3337:            stop = true;
        1: 3338:            break;
        -: 3339:        case conn_io_pending:
        -: 3340:            /* Should not be reachable */
    #####: 3341:            assert(false);
        -: 3342:            break;
     1593: 3343:        case conn_io_resume:
        -: 3344:            /* Complete our queued IO's from within the worker thread. */
     1593: 3345:            conn_set_state(c, conn_mwrite);
     1593: 3346:            break;
        -: 3347:        case conn_max_state:
    #####: 3348:            assert(false);
        -: 3349:            break;
        -: 3350:        }
        -: 3351:    }
        -: 3352:
   523113: 3353:    return;
        -: 3354:}
        -: 3355:
   523101: 3356:void event_handler(const evutil_socket_t fd, const short which, void *arg) {
   523101: 3357:    conn *c;
        -: 3358:
   523101: 3359:    c = (conn *)arg;
  523101*: 3360:    assert(c != NULL);
        -: 3361:
   523101: 3362:    c->which = which;
        -: 3363:
        -: 3364:    /* sanity */
   523101: 3365:    if (fd != c->sfd) {
    #####: 3366:        if (settings.verbose > 0)
    #####: 3367:            fprintf(stderr, "Catastrophic: event fd doesn't match conn fd!\n");
    #####: 3368:        conn_close(c);
    #####: 3369:        return;
        -: 3370:    }
        -: 3371:
   523101: 3372:    drive_machine(c);
        -: 3373:
        -: 3374:    /* wait for next event */
   523101: 3375:    return;
        -: 3376:}
        -: 3377:
       50: 3378:static int new_socket(struct addrinfo *ai) {
       50: 3379:    int sfd;
       50: 3380:    int flags;
        -: 3381:
       50: 3382:    if ((sfd = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol)) == -1) {
        -: 3383:        return -1;
        -: 3384:    }
        -: 3385:
      100: 3386:    if ((flags = fcntl(sfd, F_GETFL, 0)) < 0 ||
       50: 3387:        fcntl(sfd, F_SETFL, flags | O_NONBLOCK) < 0) {
    #####: 3388:        perror("setting O_NONBLOCK");
    #####: 3389:        close(sfd);
    #####: 3390:        return -1;
        -: 3391:    }
        -: 3392:    return sfd;
        -: 3393:}
        -: 3394:
        -: 3395:
        -: 3396:/*
        -: 3397: * Sets a socket's send buffer size to the maximum allowed by the system.
        -: 3398: */
       18: 3399:static void maximize_sndbuf(const int sfd) {
       18: 3400:    socklen_t intsize = sizeof(int);
       18: 3401:    int last_good = 0;
       18: 3402:    int min, max, avg;
       18: 3403:    int old_size;
        -: 3404:
        -: 3405:    /* Start with the default size. */
        -: 3406:#ifdef _WIN32
        -: 3407:    if (getsockopt((SOCKET)sfd, SOL_SOCKET, SO_SNDBUF, (char *)&old_size, &intsize) != 0) {
        -: 3408:#else
       18: 3409:    if (getsockopt(sfd, SOL_SOCKET, SO_SNDBUF, &old_size, &intsize) != 0) {
        -: 3410:#endif /* #ifdef _WIN32 */
    #####: 3411:        if (settings.verbose > 0)
    #####: 3412:            perror("getsockopt(SO_SNDBUF)");
    #####: 3413:        return;
        -: 3414:    }
        -: 3415:
        -: 3416:    /* Binary-search for the real maximum. */
       18: 3417:    min = old_size;
       18: 3418:    max = MAX_SENDBUF_SIZE;
        -: 3419:
      522: 3420:    while (min <= max) {
      504: 3421:        avg = ((unsigned int)(min + max)) / 2;
      504: 3422:        if (setsockopt(sfd, SOL_SOCKET, SO_SNDBUF, (void *)&avg, intsize) == 0) {
      504: 3423:            last_good = avg;
      504: 3424:            min = avg + 1;
        -: 3425:        } else {
    #####: 3426:            max = avg - 1;
        -: 3427:        }
        -: 3428:    }
        -: 3429:
       18: 3430:    if (settings.verbose > 1)
    #####: 3431:        fprintf(stderr, "<%d send buffer was %d, now %d\n", sfd, old_size, last_good);
        -: 3432:}
        -: 3433:
        -: 3434:/**
        -: 3435: * Create a socket and bind it to a specific port number
        -: 3436: * @param interface the interface to bind to
        -: 3437: * @param port the port number to bind to
        -: 3438: * @param transport the transport protocol (TCP / UDP)
        -: 3439: * @param portnumber_file A filepointer to write the port numbers to
        -: 3440: *        when they are successfully added to the list of ports we
        -: 3441: *        listen on.
        -: 3442: */
       32: 3443:static int server_socket(const char *interface,
        -: 3444:                         int port,
        -: 3445:                         enum network_transport transport,
        -: 3446:                         FILE *portnumber_file, uint8_t ssl_enabled,
        -: 3447:                         uint64_t conntag,
        -: 3448:                         enum protocol bproto) {
       32: 3449:    int sfd;
       32: 3450:    struct linger ling = {0, 0};
       32: 3451:    struct addrinfo *ai;
       32: 3452:    struct addrinfo *next;
       32: 3453:    struct addrinfo hints = { .ai_flags = AI_PASSIVE,
        -: 3454:                              .ai_family = AF_UNSPEC };
       32: 3455:    char port_buf[NI_MAXSERV];
       32: 3456:    int error;
       32: 3457:    int success = 0;
       32: 3458:    int flags =1;
        -: 3459:
       32: 3460:    hints.ai_socktype = IS_UDP(transport) ? SOCK_DGRAM : SOCK_STREAM;
        -: 3461:
       32: 3462:    if (port == -1) {
        9: 3463:        port = 0;
        -: 3464:    }
       32: 3465:    snprintf(port_buf, sizeof(port_buf), "%d", port);
       32: 3466:    error= getaddrinfo(interface, port_buf, &hints, &ai);
       32: 3467:    if (error != 0) {
        1: 3468:        if (error != EAI_SYSTEM)
        1: 3469:          fprintf(stderr, "getaddrinfo(): %s\n", gai_strerror(error));
        -: 3470:        else
    #####: 3471:          perror("getaddrinfo()");
        1: 3472:        return 1;
        -: 3473:    }
        -: 3474:
       81: 3475:    for (next= ai; next; next= next->ai_next) {
       50: 3476:        conn *listen_conn_add;
      50*: 3477:        if ((sfd = new_socket(next)) == -1) {
        -: 3478:            /* getaddrinfo can return "junk" addresses,
        -: 3479:             * we make sure at least one works before erroring.
        -: 3480:             */
    #####: 3481:            if (errno == EMFILE) {
        -: 3482:                /* ...unless we're out of fds */
    #####: 3483:                perror("server_socket");
    #####: 3484:                exit(EX_OSERR);
        -: 3485:            }
    #####: 3486:            continue;
        -: 3487:        }
        -: 3488:
       50: 3489:        if (settings.num_napi_ids) {
    #####: 3490:            socklen_t len = sizeof(socklen_t);
    #####: 3491:            int napi_id;
    #####: 3492:            error = getsockopt(sfd, SOL_SOCKET, SO_INCOMING_NAPI_ID, &napi_id, &len);
    #####: 3493:            if (error != 0) {
    #####: 3494:                fprintf(stderr, "-N <num_napi_ids> option not supported\n");
    #####: 3495:                exit(EXIT_FAILURE);
        -: 3496:            }
        -: 3497:        }
        -: 3498:
        -: 3499:#ifdef IPV6_V6ONLY
       50: 3500:        if (next->ai_family == AF_INET6) {
       19: 3501:            error = setsockopt(sfd, IPPROTO_IPV6, IPV6_V6ONLY, (char *) &flags, sizeof(flags));
      19*: 3502:            if (error != 0) {
    #####: 3503:                perror("setsockopt");
    #####: 3504:                close(sfd);
    #####: 3505:                continue;
        -: 3506:            }
        -: 3507:        }
        -: 3508:#endif
        -: 3509:#ifdef SOCK_COOKIE_ID
       50: 3510:        if (settings.sock_cookie_id != 0) {
    #####: 3511:            error = setsockopt(sfd, SOL_SOCKET, SOCK_COOKIE_ID, (void *)&settings.sock_cookie_id, sizeof(uint32_t));
    #####: 3512:            if (error != 0)
    #####: 3513:                perror("setsockopt");
        -: 3514:        }
        -: 3515:#endif
        -: 3516:
       50: 3517:        setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flags, sizeof(flags));
       50: 3518:        if (IS_UDP(transport)) {
       18: 3519:            maximize_sndbuf(sfd);
        -: 3520:        } else {
       32: 3521:            error = setsockopt(sfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flags, sizeof(flags));
       32: 3522:            if (error != 0)
    #####: 3523:                perror("setsockopt");
        -: 3524:
       32: 3525:            error = setsockopt(sfd, SOL_SOCKET, SO_LINGER, (void *)&ling, sizeof(ling));
       32: 3526:            if (error != 0)
    #####: 3527:                perror("setsockopt");
        -: 3528:
       32: 3529:            error = setsockopt(sfd, IPPROTO_TCP, TCP_NODELAY, (void *)&flags, sizeof(flags));
       32: 3530:            if (error != 0)
    #####: 3531:                perror("setsockopt");
        -: 3532:        }
        -: 3533:
      50*: 3534:        if (bind(sfd, next->ai_addr, next->ai_addrlen) == -1) {
    #####: 3535:            if (errno != EADDRINUSE) {
    #####: 3536:                perror("bind()");
    #####: 3537:                close(sfd);
    #####: 3538:                freeaddrinfo(ai);
    #####: 3539:                return 1;
        -: 3540:            }
    #####: 3541:            close(sfd);
    #####: 3542:            continue;
        -: 3543:        } else {
       50: 3544:            success++;
       50: 3545:            if (!IS_UDP(transport) && listen(sfd, settings.backlog) == -1) {
    #####: 3546:                perror("listen()");
    #####: 3547:                close(sfd);
    #####: 3548:                freeaddrinfo(ai);
    #####: 3549:                return 1;
        -: 3550:            }
       50: 3551:            if (portnumber_file != NULL &&
       38: 3552:                (next->ai_addr->sa_family == AF_INET ||
        -: 3553:                 next->ai_addr->sa_family == AF_INET6)) {
       38: 3554:                union {
        -: 3555:                    struct sockaddr_in in;
        -: 3556:                    struct sockaddr_in6 in6;
        -: 3557:                } my_sockaddr;
       38: 3558:                socklen_t len = sizeof(my_sockaddr);
       38: 3559:                if (getsockname(sfd, (struct sockaddr*)&my_sockaddr, &len)==0) {
       38: 3560:                    if (next->ai_addr->sa_family == AF_INET) {
       19: 3561:                        fprintf(portnumber_file, "%s INET: %u\n",
        -: 3562:                                IS_UDP(transport) ? "UDP" : "TCP",
       19: 3563:                                ntohs(my_sockaddr.in.sin_port));
        -: 3564:                    } else {
       19: 3565:                        fprintf(portnumber_file, "%s INET6: %u\n",
        -: 3566:                                IS_UDP(transport) ? "UDP" : "TCP",
       19: 3567:                                ntohs(my_sockaddr.in6.sin6_port));
        -: 3568:                    }
        -: 3569:                }
        -: 3570:            }
        -: 3571:        }
        -: 3572:
       50: 3573:        if (IS_UDP(transport)) {
        -: 3574:            int c;
        -: 3575:
       90: 3576:            for (c = 0; c < settings.num_threads_per_udp; c++) {
        -: 3577:                /* Allocate one UDP file descriptor per worker thread;
        -: 3578:                 * this allows "stats conns" to separately list multiple
        -: 3579:                 * parallel UDP requests in progress.
        -: 3580:                 *
        -: 3581:                 * The dispatch code round-robins new connection requests
        -: 3582:                 * among threads, so this is guaranteed to assign one
        -: 3583:                 * FD to each thread.
        -: 3584:                 */
       72: 3585:                int per_thread_fd;
       72: 3586:                if (c == 0) {
        -: 3587:                    per_thread_fd = sfd;
        -: 3588:                } else {
       54: 3589:                    per_thread_fd = dup(sfd);
       54: 3590:                    if (per_thread_fd < 0) {
    #####: 3591:                        perror("Failed to duplicate file descriptor");
    #####: 3592:                        exit(EXIT_FAILURE);
        -: 3593:                    }
        -: 3594:                }
       72: 3595:                dispatch_conn_new(per_thread_fd, conn_read,
        -: 3596:                                  EV_READ | EV_PERSIST,
        -: 3597:                                  UDP_READ_BUFFER_SIZE, transport, NULL, conntag, bproto);
        -: 3598:            }
        -: 3599:        } else {
       32: 3600:            if (!(listen_conn_add = conn_new(sfd, conn_listening,
        -: 3601:                                             EV_READ | EV_PERSIST, 1,
        -: 3602:                                             transport, main_base, NULL, conntag, bproto))) {
    #####: 3603:                fprintf(stderr, "failed to create listening connection\n");
    #####: 3604:                exit(EXIT_FAILURE);
        -: 3605:            }
        -: 3606:#ifdef TLS
        -: 3607:            listen_conn_add->ssl_enabled = ssl_enabled;
        -: 3608:#else
      32*: 3609:            assert(ssl_enabled == false);
        -: 3610:#endif
       32: 3611:            listen_conn_add->next = listen_conn;
       32: 3612:            listen_conn = listen_conn_add;
        -: 3613:        }
        -: 3614:    }
        -: 3615:
       31: 3616:    freeaddrinfo(ai);
        -: 3617:
        -: 3618:    /* Return zero iff we detected no errors in starting up connections */
       31: 3619:    return success == 0;
        -: 3620:}
        -: 3621:
       32: 3622:static int server_sockets(int port, enum network_transport transport,
        -: 3623:                          FILE *portnumber_file) {
       32: 3624:    uint8_t ssl_enabled = MC_SSL_DISABLED;
        -: 3625:
       32: 3626:    const char *notls = "notls";
       32: 3627:    const char *btls = "btls";
       32: 3628:    const char *mtls = "mtls";
       32: 3629:    if (settings.ssl_enabled) {
    #####: 3630:        ssl_enabled = MC_SSL_ENABLED_DEFAULT;
        -: 3631:    }
        -: 3632:
       32: 3633:    if (settings.inter == NULL) {
       19: 3634:        return server_socket(settings.inter, port, transport, portnumber_file, ssl_enabled, 0, settings.binding_protocol);
        -: 3635:    } else {
        -: 3636:        // tokenize them and bind to each one of them..
       13: 3637:        char *b;
       13: 3638:        int ret = 0;
       13: 3639:        char *list = strdup(settings.inter);
        -: 3640:
       13: 3641:        if (list == NULL) {
    #####: 3642:            fprintf(stderr, "Failed to allocate memory for parsing server interface string\n");
    #####: 3643:            return 1;
        -: 3644:        }
        -: 3645:        // If we encounter any failure, preserve the first errno for the caller.
       13: 3646:        int errno_save = 0;
       13: 3647:        for (char *p = strtok_r(list, ";,", &b);
       26: 3648:            p != NULL;
       13: 3649:            p = strtok_r(NULL, ";,", &b)) {
       13: 3650:            uint64_t conntag = 0;
       13: 3651:            int the_port = port;
       13: 3652:            if (settings.ssl_enabled) {
    #####: 3653:                ssl_enabled = MC_SSL_ENABLED_DEFAULT;
        -: 3654:            }
        -: 3655:            // "notls" option is valid only when memcached is run with SSL enabled.
       13: 3656:            if (strncmp(p, notls, strlen(notls)) == 0) {
    #####: 3657:                if (!settings.ssl_enabled) {
    #####: 3658:                    fprintf(stderr, "'notls' option is valid only when SSL is enabled\n");
    #####: 3659:                    free(list);
    #####: 3660:                    return 1;
        -: 3661:                }
    #####: 3662:                ssl_enabled = MC_SSL_DISABLED;
    #####: 3663:                p += strlen(notls) + 1;
       13: 3664:            } else if (strncmp(p, btls, strlen(btls)) == 0) {
    #####: 3665:                 if (!settings.ssl_enabled) {
    #####: 3666:                    fprintf(stderr, "'btls' option is valid only when SSL is enabled\n");
    #####: 3667:                    free(list);
    #####: 3668:                    return 1;
        -: 3669:                }
    #####: 3670:                ssl_enabled = MC_SSL_ENABLED_NOPEER;
    #####: 3671:                p += strlen(btls) + 1;
       13: 3672:            } else if (strncmp(p, mtls, strlen(mtls)) == 0) {
    #####: 3673:                if (!settings.ssl_enabled) {
    #####: 3674:                    fprintf(stderr, "'otls' option is valid only when SSL is enabled\n");
    #####: 3675:                    free(list);
    #####: 3676:                    return 1;
        -: 3677:                }
    #####: 3678:                ssl_enabled = MC_SSL_ENABLED_PEER;
    #####: 3679:                p += strlen(mtls) + 1;
        -: 3680:            }
        -: 3681:
        -: 3682:            // Allow forcing the protocol of this listener.
       13: 3683:            const char *protostr = "proto";
       13: 3684:            enum protocol bproto = settings.binding_protocol;
       13: 3685:            if (strncmp(p, protostr, strlen(protostr)) == 0) {
    #####: 3686:                p += strlen(protostr);
    #####: 3687:                if (*p == '[') {
    #####: 3688:                    char *e = strchr(p, ']');
    #####: 3689:                    if (e == NULL) {
    #####: 3690:                        fprintf(stderr, "Invalid protocol spec: \"%s\"\n", p);
    #####: 3691:                        free(list);
    #####: 3692:                        return 1;
        -: 3693:                    }
    #####: 3694:                    char *st = ++p; // skip '[';
    #####: 3695:                    *e = '\0';
    #####: 3696:                    size_t len = e - st;
    #####: 3697:                    p = ++e; // skip ']'
    #####: 3698:                    p++; // skip an assumed ':'
        -: 3699:
    #####: 3700:                    if (strncmp(st, "ascii", len) == 0) {
        -: 3701:                        bproto = ascii_prot;
    #####: 3702:                    } else if (strncmp(st, "binary", len) == 0) {
        -: 3703:                        bproto = binary_prot;
    #####: 3704:                    } else if (strncmp(st, "negotiating", len) == 0) {
        -: 3705:                        bproto = negotiating_prot;
    #####: 3706:                    } else if (strncmp(st, "proxy", len) == 0) {
        -: 3707:#ifdef PROXY
        -: 3708:                        if (settings.proxy_enabled) {
        -: 3709:                            bproto = proxy_prot;
        -: 3710:                        } else {
        -: 3711:                            fprintf(stderr, "Proxy must be enabled to use: \"%s\"\n", list);
        -: 3712:                            free(list);
        -: 3713:                            return 1;
        -: 3714:                        }
        -: 3715:#else
    #####: 3716:                        fprintf(stderr, "Server not built with proxy: \"%s\"\n", list);
    #####: 3717:                        free(list);
    #####: 3718:                        return 1;
        -: 3719:#endif
        -: 3720:                    }
        -: 3721:                }
        -: 3722:            }
        -: 3723:
       13: 3724:            const char *tagstr = "tag";
       13: 3725:            if (strncmp(p, tagstr, strlen(tagstr)) == 0) {
    #####: 3726:                p += strlen(tagstr);
        -: 3727:                // NOTE: should probably retire the [] dumbassery. those're
        -: 3728:                // shell characters.
    #####: 3729:                if (*p == '[' || *p == '_') {
    #####: 3730:                    char *e = strchr(p, ']');
    #####: 3731:                    if (e == NULL) {
    #####: 3732:                        e = strchr(p+1, '_');
        -: 3733:                    }
    #####: 3734:                    if (e == NULL) {
    #####: 3735:                        fprintf(stderr, "Invalid tag in socket config: \"%s\"\n", p);
    #####: 3736:                        free(list);
    #####: 3737:                        return 1;
        -: 3738:                    }
    #####: 3739:                    char *st = ++p; // skip '['
    #####: 3740:                    *e = '\0';
    #####: 3741:                    size_t len = e - st;
    #####: 3742:                    p = ++e; // skip ']'
    #####: 3743:                    p++; // skip an assumed ':'
        -: 3744:
        -: 3745:                    // validate the tag and copy it in.
    #####: 3746:                    if (len > 8 || len < 1) {
    #####: 3747:                        fprintf(stderr, "Listener tags must be between 1 and 8 characters: \"%s\"\n", st);
    #####: 3748:                        free(list);
    #####: 3749:                        return 1;
        -: 3750:                    }
        -: 3751:
        -: 3752:                    // C programmers love turning string comparisons into
        -: 3753:                    // integer comparisons.
    #####: 3754:                    memcpy(&conntag, st, len);
        -: 3755:                }
        -: 3756:            }
        -: 3757:
       13: 3758:            char *h = NULL;
       13: 3759:            if (*p == '[') {
        -: 3760:                // expecting it to be an IPv6 address enclosed in []
        -: 3761:                // i.e. RFC3986 style recommended by RFC5952
    #####: 3762:                char *e = strchr(p, ']');
    #####: 3763:                if (e == NULL) {
    #####: 3764:                    fprintf(stderr, "Invalid IPV6 address: \"%s\"", p);
    #####: 3765:                    free(list);
    #####: 3766:                    return 1;
        -: 3767:                }
    #####: 3768:                h = ++p; // skip the opening '['
    #####: 3769:                *e = '\0';
    #####: 3770:                p = ++e; // skip the closing ']'
        -: 3771:            }
        -: 3772:
       13: 3773:            char *s = strchr(p, ':');
       13: 3774:            if (s != NULL) {
        -: 3775:                // If no more semicolons - attempt to treat as port number.
        -: 3776:                // Otherwise the only valid option is an unenclosed IPv6 without port, until
        -: 3777:                // of course there was an RFC3986 IPv6 address previously specified -
        -: 3778:                // in such a case there is no good option, will just send it to fail as port number.
    #####: 3779:                if (strchr(s + 1, ':') == NULL || h != NULL) {
    #####: 3780:                    *s = '\0';
    #####: 3781:                    ++s;
    #####: 3782:                    if (!safe_strtol(s, &the_port)) {
    #####: 3783:                        fprintf(stderr, "Invalid port number: \"%s\"\n", s);
    #####: 3784:                        free(list);
    #####: 3785:                        return 1;
        -: 3786:                    }
        -: 3787:                }
        -: 3788:            }
        -: 3789:
       13: 3790:            if (h != NULL)
       13: 3791:                p = h;
        -: 3792:
       13: 3793:            if (strcmp(p, "*") == 0) {
    #####: 3794:                p = NULL;
        -: 3795:            }
       13: 3796:            ret |= server_socket(p, the_port, transport, portnumber_file, ssl_enabled, conntag, bproto);
       13: 3797:            if (ret != 0 && errno_save == 0) errno_save = errno;
        -: 3798:        }
       13: 3799:        free(list);
       13: 3800:        errno = errno_save;
       13: 3801:        return ret;
        -: 3802:    }
        -: 3803:}
        -: 3804:
        -: 3805:#ifndef DISABLE_UNIX_SOCKET
      101: 3806:static int new_socket_unix(void) {
      101: 3807:    int sfd;
      101: 3808:    int flags;
        -: 3809:
      101: 3810:    if ((sfd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {
    #####: 3811:        perror("socket()");
    #####: 3812:        return -1;
        -: 3813:    }
        -: 3814:
      202: 3815:    if ((flags = fcntl(sfd, F_GETFL, 0)) < 0 ||
      101: 3816:        fcntl(sfd, F_SETFL, flags | O_NONBLOCK) < 0) {
    #####: 3817:        perror("setting O_NONBLOCK");
    #####: 3818:        close(sfd);
    #####: 3819:        return -1;
        -: 3820:    }
        -: 3821:    return sfd;
        -: 3822:}
        -: 3823:
      101: 3824:static int server_socket_unix(const char *path, int access_mask) {
      101: 3825:    int sfd;
      101: 3826:    struct linger ling = {0, 0};
      101: 3827:    struct sockaddr_un addr;
      101: 3828:    struct stat tstat;
      101: 3829:    int flags =1;
      101: 3830:    int old_umask;
        -: 3831:
      101: 3832:    if (!path) {
        -: 3833:        return 1;
        -: 3834:    }
        -: 3835:
      101: 3836:    if ((sfd = new_socket_unix()) == -1) {
        -: 3837:        return 1;
        -: 3838:    }
        -: 3839:
        -: 3840:    /*
        -: 3841:     * Clean up a previous socket file if we left it around
        -: 3842:     */
      101: 3843:    if (lstat(path, &tstat) == 0) {
    #####: 3844:        if (S_ISSOCK(tstat.st_mode))
    #####: 3845:            unlink(path);
        -: 3846:    }
        -: 3847:
      101: 3848:    setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flags, sizeof(flags));
      101: 3849:    setsockopt(sfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flags, sizeof(flags));
      101: 3850:    setsockopt(sfd, SOL_SOCKET, SO_LINGER, (void *)&ling, sizeof(ling));
        -: 3851:
        -: 3852:    /*
        -: 3853:     * the memset call clears nonstandard fields in some implementations
        -: 3854:     * that otherwise mess things up.
        -: 3855:     */
      101: 3856:    memset(&addr, 0, sizeof(addr));
        -: 3857:
      101: 3858:    addr.sun_family = AF_UNIX;
      101: 3859:    strncpy(addr.sun_path, path, sizeof(addr.sun_path) - 1);
     101*: 3860:    assert(strcmp(addr.sun_path, path) == 0);
      101: 3861:    old_umask = umask( ~(access_mask&0777));
      101: 3862:    if (bind(sfd, (struct sockaddr *)&addr, sizeof(addr)) == -1) {
    #####: 3863:        perror("bind()");
    #####: 3864:        close(sfd);
    #####: 3865:        umask(old_umask);
    #####: 3866:        return 1;
        -: 3867:    }
      101: 3868:    umask(old_umask);
      101: 3869:    if (listen(sfd, settings.backlog) == -1) {
    #####: 3870:        perror("listen()");
    #####: 3871:        close(sfd);
    #####: 3872:        return 1;
        -: 3873:    }
      101: 3874:    if (!(listen_conn = conn_new(sfd, conn_listening,
        -: 3875:                                 EV_READ | EV_PERSIST, 1,
        -: 3876:                                 local_transport, main_base, NULL, 0, settings.binding_protocol))) {
    #####: 3877:        fprintf(stderr, "failed to create listening connection\n");
    #####: 3878:        exit(EXIT_FAILURE);
        -: 3879:    }
        -: 3880:
        -: 3881:    return 0;
        -: 3882:}
        -: 3883:#else
        -: 3884:#define server_socket_unix(path, access_mask)   -1
        -: 3885:#endif /* #ifndef DISABLE_UNIX_SOCKET */
        -: 3886:
        -: 3887:/*
        -: 3888: * We keep the current time of day in a global variable that's updated by a
        -: 3889: * timer event. This saves us a bunch of time() system calls (we really only
        -: 3890: * need to get the time once a second, whereas there can be tens of thousands
        -: 3891: * of requests a second) and allows us to use server-start-relative timestamps
        -: 3892: * rather than absolute UNIX timestamps, a space savings on systems where
        -: 3893: * sizeof(time_t) > sizeof(unsigned int).
        -: 3894: */
        -: 3895:volatile rel_time_t current_time;
        -: 3896:static struct event clockevent;
        -: 3897:#ifdef MEMCACHED_DEBUG
        -: 3898:volatile bool is_paused;
        -: 3899:volatile int64_t delta;
        -: 3900:#endif
        -: 3901:#if defined(HAVE_CLOCK_GETTIME) && defined(CLOCK_MONOTONIC)
        -: 3902:static bool monotonic = false;
        -: 3903:static int64_t monotonic_start;
        -: 3904:#endif
        -: 3905:
        -: 3906:/* libevent uses a monotonic clock when available for event scheduling. Aside
        -: 3907: * from jitter, simply ticking our internal timer here is accurate enough.
        -: 3908: * Note that users who are setting explicit dates for expiration times *must*
        -: 3909: * ensure their clocks are correct before starting memcached. */
      498: 3910:static void clock_handler(const evutil_socket_t fd, const short which, void *arg) {
      498: 3911:    struct timeval t = {.tv_sec = 1, .tv_usec = 0};
      498: 3912:    static bool initialized = false;
        -: 3913:
      498: 3914:    if (initialized) {
        -: 3915:        /* only delete the event if it's actually there. */
      376: 3916:        evtimer_del(&clockevent);
        -: 3917:    } else {
      122: 3918:        initialized = true;
        -: 3919:    }
        -: 3920:
        -: 3921:    // While we're here, check for hash table expansion.
        -: 3922:    // This function should be quick to avoid delaying the timer.
      498: 3923:    assoc_start_expand(stats_state.curr_items);
        -: 3924:    // also, if HUP'ed we need to do some maintenance.
        -: 3925:    // for now that's just the authfile reload.
      498: 3926:    if (settings.sig_hup) {
        1: 3927:        settings.sig_hup = false;
        -: 3928:
        1: 3929:        authfile_load(settings.auth_file);
        -: 3930:#ifdef PROXY
        -: 3931:        if (settings.proxy_ctx) {
        -: 3932:            proxy_start_reload(settings.proxy_ctx);
        -: 3933:        }
        -: 3934:#endif
        -: 3935:    }
        -: 3936:
      498: 3937:    evtimer_set(&clockevent, clock_handler, 0);
      498: 3938:    event_base_set(main_base, &clockevent);
      498: 3939:    evtimer_add(&clockevent, &t);
        -: 3940:
        -: 3941:#ifdef MEMCACHED_DEBUG
      996: 3942:    if (is_paused) return;
        -: 3943:#endif
        -: 3944:
        -: 3945:#if defined(HAVE_CLOCK_GETTIME) && defined(CLOCK_MONOTONIC)
      498: 3946:    if (monotonic) {
      498: 3947:        struct timespec ts;
      498: 3948:        if (clock_gettime(CLOCK_MONOTONIC, &ts) == -1)
        -: 3949:            return;
        -: 3950:#ifdef MEMCACHED_DEBUG
      498: 3951:        current_time = (rel_time_t) (ts.tv_sec - monotonic_start + delta);
        -: 3952:#else
        -: 3953:        current_time = (rel_time_t) (ts.tv_sec - monotonic_start);
        -: 3954:#endif
      498: 3955:        return;
        -: 3956:    }
        -: 3957:#endif
        -: 3958:    {
    #####: 3959:        struct timeval tv;
    #####: 3960:        gettimeofday(&tv, NULL);
        -: 3961:#ifdef MEMCACHED_DEBUG
    #####: 3962:        current_time = (rel_time_t) (tv.tv_sec - process_started + delta);
        -: 3963:#else
        -: 3964:        current_time = (rel_time_t) (tv.tv_sec - process_started);
        -: 3965:#endif
        -: 3966:    }
        -: 3967:}
        -: 3968:
      638: 3969:static const char* flag_enabled_disabled(bool flag) {
      638: 3970:    return (flag ? "enabled" : "disabled");
        -: 3971:}
        -: 3972:
     2364: 3973:void verify_default(const char* param, bool condition) {
     2364: 3974:    if (!condition) {
    #####: 3975:        printf("Default value of [%s] has changed."
        -: 3976:            " Modify the help text and default value check.\n", param);
    #####: 3977:        exit(EXIT_FAILURE);
        -: 3978:    }
     2364: 3979:}
        -: 3980:
      319: 3981:static void usage(void) {
      319: 3982:    printf(PACKAGE " " VERSION "\n");
      319: 3983:    printf("-p, --port=<num>          TCP port to listen on (default: %d)\n"
        -: 3984:           "-U, --udp-port=<num>      UDP port to listen on (default: %d, off)\n",
        -: 3985:           settings.port, settings.udpport);
        -: 3986:#ifndef DISABLE_UNIX_SOCKET
      319: 3987:    printf("-s, --unix-socket=<file>  UNIX socket to listen on (disables network support)\n");
      319: 3988:    printf("-a, --unix-mask=<mask>    access mask for UNIX socket, in octal (default: %o)\n",
        -: 3989:            settings.access);
        -: 3990:#endif /* #ifndef DISABLE_UNIX_SOCKET */
      319: 3991:    printf("-A, --enable-shutdown     enable ascii \"shutdown\" command\n");
      319: 3992:    printf("-l, --listen=<addr>       interface to listen on (default: INADDR_ANY)\n");
        -: 3993:#ifdef TLS
        -: 3994:    printf("                          if TLS/SSL is enabled, 'notls' prefix can be used to\n"
        -: 3995:           "                          disable for specific listeners (-l notls:<ip>:<port>) \n");
        -: 3996:#endif
      638: 3997:    printf("-d, --daemon              run as a daemon\n"
        -: 3998:           "-r, --enable-coredumps    maximize core file limit\n"
        -: 3999:           "-u, --user=<user>         assume identity of <username> (only when run as root)\n"
        -: 4000:           "-m, --memory-limit=<num>  item memory in megabytes (default: %lu)\n"
        -: 4001:           "-M, --disable-evictions   return error on memory exhausted instead of evicting\n"
        -: 4002:           "-c, --conn-limit=<num>    max simultaneous connections (default: %d)\n"
        -: 4003:           "-k, --lock-memory         lock down all paged memory\n"
        -: 4004:           "-v, --verbose             verbose (print errors/warnings while in event loop)\n"
        -: 4005:           "-vv                       very verbose (also print client commands/responses)\n"
        -: 4006:           "-vvv                      extremely verbose (internal state transitions)\n"
        -: 4007:           "-h, --help                print this help and exit\n"
        -: 4008:           "-i, --license             print memcached and libevent license\n"
        -: 4009:           "-V, --version             print version and exit\n"
        -: 4010:           "-P, --pidfile=<file>      save PID in <file>, only used with -d option\n"
        -: 4011:           "-f, --slab-growth-factor=<num> chunk size growth factor (default: %2.2f)\n"
        -: 4012:           "-n, --slab-min-size=<bytes> min space used for key+value+flags (default: %d)\n",
      319: 4013:           (unsigned long) settings.maxbytes / (1 << 20),
        -: 4014:           settings.maxconns, settings.factor, settings.chunk_size);
      319: 4015:    verify_default("udp-port",settings.udpport == 0);
      319: 4016:    printf("-L, --enable-largepages  try to use large memory pages (if available)\n");
      638: 4017:    printf("-D <char>     Use <char> as the delimiter between key prefixes and IDs.\n"
        -: 4018:           "              This is used for per-prefix stats reporting. The default is\n"
        -: 4019:           "              \"%c\" (colon). If this option is specified, stats collection\n"
        -: 4020:           "              is turned on automatically; if not, then it may be turned on\n"
        -: 4021:           "              by sending the \"stats detail on\" command to the server.\n",
      319: 4022:           settings.prefix_delimiter);
      319: 4023:    printf("-t, --threads=<num>       number of threads to use (default: %d)\n", settings.num_threads);
      319: 4024:    printf("-R, --max-reqs-per-event  maximum number of requests per event, limits the\n"
        -: 4025:           "                          requests processed per connection to prevent \n"
        -: 4026:           "                          starvation (default: %d)\n", settings.reqs_per_event);
      319: 4027:    printf("-C, --disable-cas         disable use of CAS\n");
      319: 4028:    printf("-b, --listen-backlog=<num> set the backlog queue limit (default: %d)\n", settings.backlog);
      638: 4029:    printf("-B, --protocol=<name>     protocol - one of ascii, binary, or auto (default: %s)\n",
        -: 4030:           prot_text(settings.binding_protocol));
      638: 4031:    printf("-I, --max-item-size=<num> adjusts max item size\n"
        -: 4032:           "                          (default: %dm, min: %dk, max: %dm)\n",
      319: 4033:           settings.item_size_max/ (1 << 20), ITEM_SIZE_MAX_LOWER_LIMIT / (1 << 10),  ITEM_SIZE_MAX_UPPER_LIMIT / (1 << 20));
        -: 4034:#ifdef ENABLE_SASL
        -: 4035:    printf("-S, --enable-sasl         turn on Sasl authentication\n");
        -: 4036:#endif
      319: 4037:    printf("-F, --disable-flush-all   disable flush_all command\n");
      319: 4038:    printf("-X, --disable-dumping     disable stats cachedump, stats detail, and lru_crawler metadump\n");
      319: 4039:    printf("-W  --disable-watch       disable watch commands (live logging)\n");
      319: 4040:    printf("-Y, --auth-file=<file>    (EXPERIMENTAL) enable ASCII protocol authentication. format:\n"
        -: 4041:           "                          user:pass\\nuser2:pass2\\n\n");
      319: 4042:    printf("-e, --memory-file=<file>  (EXPERIMENTAL) mmap a file for item memory.\n"
        -: 4043:           "                          use only in ram disks or persistent memory mounts!\n"
        -: 4044:           "                          enables restartable cache (stop with SIGUSR1)\n");
        -: 4045:#ifdef TLS
        -: 4046:    printf("-Z, --enable-ssl          enable TLS/SSL\n");
        -: 4047:#endif
      319: 4048:    printf("-o, --extended            comma separated list of extended options\n"
        -: 4049:           "                          most options have a 'no_' prefix to disable\n"
        -: 4050:           "   - maxconns_fast:       immediately close new connections after limit (default: %s)\n"
        -: 4051:           "   - hashpower:           an integer multiplier for how large the hash\n"
        -: 4052:           "                          table should be. normally grows at runtime. (default starts at: %d)\n"
        -: 4053:           "                          set based on \"STAT hash_power_level\"\n"
        -: 4054:           "   - tail_repair_time:    time in seconds for how long to wait before\n"
        -: 4055:           "                          forcefully killing LRU tail item.\n"
        -: 4056:           "                          disabled by default; very dangerous option.\n"
        -: 4057:           "   - hash_algorithm:      the hash table algorithm\n"
        -: 4058:           "                          default is murmur3 hash. options: jenkins, murmur3, xxh3\n"
        -: 4059:           "   - no_lru_crawler:      disable LRU Crawler background thread.\n"
        -: 4060:           "   - lru_crawler_sleep:   microseconds to sleep between items\n"
        -: 4061:           "                          default is %d.\n"
        -: 4062:           "   - lru_crawler_tocrawl: max items to crawl per slab per run\n"
        -: 4063:           "                          default is %u (unlimited)\n",
      319: 4064:           flag_enabled_disabled(settings.maxconns_fast), settings.hashpower_init,
        -: 4065:           settings.lru_crawler_sleep, settings.lru_crawler_tocrawl);
      319: 4066:    printf("   - read_buf_mem_limit:  limit in megabytes for connection read/response buffers.\n"
        -: 4067:           "                          do not adjust unless you have high (20k+) conn. limits.\n"
        -: 4068:           "                          0 means unlimited (default: %u)\n",
        -: 4069:           settings.read_buf_mem_limit);
      319: 4070:    verify_default("read_buf_mem_limit", settings.read_buf_mem_limit == 0);
      319: 4071:    printf("   - no_lru_maintainer:   disable new LRU system + background thread.\n"
        -: 4072:           "   - hot_lru_pct:         pct of slab memory to reserve for hot lru.\n"
        -: 4073:           "                          (requires lru_maintainer, default pct: %d)\n"
        -: 4074:           "   - warm_lru_pct:        pct of slab memory to reserve for warm lru.\n"
        -: 4075:           "                          (requires lru_maintainer, default pct: %d)\n"
        -: 4076:           "   - hot_max_factor:      items idle > cold lru age * drop from hot lru. (default: %.2f)\n"
        -: 4077:           "   - warm_max_factor:     items idle > cold lru age * this drop from warm. (default: %.2f)\n"
        -: 4078:           "   - temporary_ttl:       TTL's below get separate LRU, can't be evicted.\n"
        -: 4079:           "                          (requires lru_maintainer, default: %d)\n"
        -: 4080:           "   - idle_timeout:        timeout for idle connections. (default: %d, no timeout)\n",
        -: 4081:           settings.hot_lru_pct, settings.warm_lru_pct, settings.hot_max_factor, settings.warm_max_factor,
        -: 4082:           settings.temporary_ttl, settings.idle_timeout);
      638: 4083:    printf("   - slab_chunk_max:      (EXPERIMENTAL) maximum slab size in kilobytes. use extreme care. (default: %d)\n"
        -: 4084:           "   - watcher_logbuf_size: size in kilobytes of per-watcher write buffer. (default: %u)\n"
        -: 4085:           "   - worker_logbuf_size:  size in kilobytes of per-worker-thread buffer\n"
        -: 4086:           "                          read by background thread, then written to watchers. (default: %u)\n"
        -: 4087:           "   - track_sizes:         enable dynamic reports for 'stats sizes' command.\n"
        -: 4088:           "                          note that counts for each size are approximate.\n"
        -: 4089:           "   - no_hashexpand:       disables hash table expansion (dangerous)\n"
        -: 4090:           "   - modern:              enables options which will be default in future.\n"
        -: 4091:           "                          currently: nothing\n"
        -: 4092:           "   - no_modern:           uses defaults of previous major version (1.4.x)\n",
      319: 4093:           settings.slab_chunk_size_max / (1 << 10), settings.logger_watcher_buf_size / (1 << 10),
      319: 4094:           settings.logger_buf_size / (1 << 10));
      319: 4095:    verify_default("tail_repair_time", settings.tail_repair_time == TAIL_REPAIR_TIME_DEFAULT);
      319: 4096:    verify_default("lru_crawler_tocrawl", settings.lru_crawler_tocrawl == 0);
      319: 4097:    verify_default("idle_timeout", settings.idle_timeout == 0);
        -: 4098:#ifdef HAVE_DROP_PRIVILEGES
        -: 4099:    printf("   - drop_privileges:     enable dropping extra syscall privileges\n"
        -: 4100:           "   - no_drop_privileges:  disable drop_privileges in case it causes issues with\n"
        -: 4101:           "                          some customisation.\n"
        -: 4102:           "                          (default is no_drop_privileges)\n");
        -: 4103:    verify_default("drop_privileges", !settings.drop_privileges);
        -: 4104:#ifdef MEMCACHED_DEBUG
        -: 4105:    printf("   - relaxed_privileges:  running tests requires extra privileges. (default: %s)\n",
        -: 4106:           flag_enabled_disabled(settings.relaxed_privileges));
        -: 4107:#endif
        -: 4108:#endif
        -: 4109:#ifdef SOCK_COOKIE_ID
      319: 4110:    printf("   - sock_cookie_id:      attributes an ID to a socket for ip filtering/firewalls \n");
        -: 4111:#endif
        -: 4112:#ifdef EXTSTORE
      319: 4113:    printf("\n   - External storage (ext_*) related options (see: https://memcached.org/extstore)\n");
      957: 4114:    printf("   - ext_path:            file to write to for external storage.\n"
        -: 4115:           "                          ie: ext_path=/mnt/d1/extstore:1G\n"
        -: 4116:           "   - ext_page_size:       size in megabytes of storage pages. (default: %u)\n"
        -: 4117:           "   - ext_wbuf_size:       size in megabytes of page write buffers. (default: %u)\n"
        -: 4118:           "   - ext_threads:         number of IO threads to run. (default: %u)\n"
        -: 4119:           "   - ext_item_size:       store items larger than this (bytes, default %u)\n"
        -: 4120:           "   - ext_item_age:        store items idle at least this long (seconds, default: no age limit)\n"
        -: 4121:           "   - ext_low_ttl:         consider TTLs lower than this specially (default: %u)\n"
        -: 4122:           "   - ext_drop_unread:     don't re-write unread values during compaction (default: %s)\n"
        -: 4123:           "   - ext_recache_rate:    recache an item every N accesses (default: %u)\n"
        -: 4124:           "   - ext_compact_under:   compact when fewer than this many free pages\n"
        -: 4125:           "                          (default: 1 percent of the assigned storage)\n"
        -: 4126:           "   - ext_drop_under:      drop COLD items when fewer than this many free pages\n"
        -: 4127:           "                          (default: 1/4th of the assigned storage)\n"
        -: 4128:           "   - ext_max_frag:        only defrag pages if they are less full than this pct-wise (default: %.2f)\n"
        -: 4129:           "   - ext_max_sleep:       max sleep time of background threads in us (default: %u)\n"
        -: 4130:           "   - slab_automove_freeratio: ratio of memory to hold free as buffer.\n"
        -: 4131:           "                          (see doc/storage.txt for more info, default: %.3f)\n",
      319: 4132:           settings.ext_page_size / (1 << 20), settings.ext_wbuf_size / (1 << 20), settings.ext_io_threadcount,
        -: 4133:           settings.ext_item_size, settings.ext_low_ttl,
      319: 4134:           flag_enabled_disabled(settings.ext_drop_unread), settings.ext_recache_rate,
        -: 4135:           settings.ext_max_frag, settings.ext_max_sleep, settings.slab_automove_freeratio);
      319: 4136:    verify_default("ext_item_age", settings.ext_item_age == UINT_MAX);
        -: 4137:#endif
        -: 4138:#ifdef PROXY
        -: 4139:    printf("   - proxy_config:        path to lua library file. separate with ':' for multiple files\n"
        -: 4140:           "                          use proxy_config=routelib to use built-in library\n"
        -: 4141:           "                          see https://memcached.org/proxy for information\n"
        -: 4142:            );
        -: 4143:    printf("   - proxy_arg:           argument string (file path) to pass to proxy config\n"
        -: 4144:            );
        -: 4145:#endif
      319: 4146:    ssl_help();
      319: 4147:    printf("-N, --napi_ids            number of napi ids. see doc/napi_ids.txt for more details\n");
      319: 4148:    return;
        -: 4149:}
        -: 4150:
    #####: 4151:static void usage_license(void) {
    #####: 4152:    printf(PACKAGE " " VERSION "\n\n");
    #####: 4153:    printf(
        -: 4154:    "Copyright (c) 2003, Danga Interactive, Inc. <http://www.danga.com/>\n"
        -: 4155:    "All rights reserved.\n"
        -: 4156:    "\n"
        -: 4157:    "Redistribution and use in source and binary forms, with or without\n"
        -: 4158:    "modification, are permitted provided that the following conditions are\n"
        -: 4159:    "met:\n"
        -: 4160:    "\n"
        -: 4161:    "    * Redistributions of source code must retain the above copyright\n"
        -: 4162:    "notice, this list of conditions and the following disclaimer.\n"
        -: 4163:    "\n"
        -: 4164:    "    * Redistributions in binary form must reproduce the above\n"
        -: 4165:    "copyright notice, this list of conditions and the following disclaimer\n"
        -: 4166:    "in the documentation and/or other materials provided with the\n"
        -: 4167:    "distribution.\n"
        -: 4168:    "\n"
        -: 4169:    "    * Neither the name of the Danga Interactive nor the names of its\n"
        -: 4170:    "contributors may be used to endorse or promote products derived from\n"
        -: 4171:    "this software without specific prior written permission.\n"
        -: 4172:    "\n"
        -: 4173:    "THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n"
        -: 4174:    "\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n"
        -: 4175:    "LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n"
        -: 4176:    "A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n"
        -: 4177:    "OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n"
        -: 4178:    "SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n"
        -: 4179:    "LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n"
        -: 4180:    "DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n"
        -: 4181:    "THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n"
        -: 4182:    "(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n"
        -: 4183:    "OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        -: 4184:    );
        -: 4185:
    #####: 4186:    return;
        -: 4187:}
        -: 4188:
        1: 4189:static void save_pid(const char *pid_file) {
        1: 4190:    FILE *fp;
        1: 4191:    if (access(pid_file, F_OK) == 0) {
    #####: 4192:        if ((fp = fopen(pid_file, "r")) != NULL) {
    #####: 4193:            char buffer[1024];
    #####: 4194:            if (fgets(buffer, sizeof(buffer), fp) != NULL) {
    #####: 4195:                unsigned int pid;
    #####: 4196:                if (safe_strtoul(buffer, &pid) && kill((pid_t)pid, 0) == 0) {
    #####: 4197:                    fprintf(stderr, "WARNING: The pid file contained the following (running) pid: %u\n", pid);
        -: 4198:                }
        -: 4199:            }
    #####: 4200:            fclose(fp);
        -: 4201:        }
        -: 4202:    }
        -: 4203:
        -: 4204:    /* Create the pid file first with a temporary name, then
        -: 4205:     * atomically move the file to the real name to avoid a race with
        -: 4206:     * another process opening the file to read the pid, but finding
        -: 4207:     * it empty.
        -: 4208:     */
        1: 4209:    char tmp_pid_file[1024];
        1: 4210:    snprintf(tmp_pid_file, sizeof(tmp_pid_file), "%s.tmp", pid_file);
        -: 4211:
        1: 4212:    if ((fp = fopen(tmp_pid_file, "w")) == NULL) {
    #####: 4213:        vperror("Could not open the pid file %s for writing", tmp_pid_file);
    #####: 4214:        return;
        -: 4215:    }
        -: 4216:
        1: 4217:    fprintf(fp,"%ld\n", (long)getpid());
        1: 4218:    if (fclose(fp) == -1) {
    #####: 4219:        vperror("Could not close the pid file %s", tmp_pid_file);
        -: 4220:    }
        -: 4221:
        1: 4222:    if (rename(tmp_pid_file, pid_file) != 0) {
    #####: 4223:        vperror("Could not rename the pid file from %s to %s",
        -: 4224:                tmp_pid_file, pid_file);
        -: 4225:    }
        -: 4226:}
        -: 4227:
        1: 4228:static void remove_pidfile(const char *pid_file) {
        1: 4229:  if (pid_file == NULL)
        -: 4230:      return;
        -: 4231:
        1: 4232:  if (unlink(pid_file) != 0) {
        1: 4233:      vperror("Could not remove the pid file %s", pid_file);
        -: 4234:  }
        -: 4235:
        -: 4236:}
        -: 4237:
      127: 4238:static void sig_handler(const int sig) {
      127: 4239:    stop_main_loop = EXIT_NORMALLY;
      127: 4240:}
        -: 4241:
        1: 4242:static void sighup_handler(const int sig) {
        1: 4243:    settings.sig_hup = true;
        1: 4244:}
        -: 4245:
        2: 4246:static void sig_usrhandler(const int sig) {
        2: 4247:    stop_main_loop = GRACE_STOP;
        2: 4248:}
        -: 4249:
        -: 4250:/*
        -: 4251: * On systems that supports multiple page sizes we may reduce the
        -: 4252: * number of TLB-misses by using the biggest available page size
        -: 4253: */
    #####: 4254:static int enable_large_pages(void) {
        -: 4255:#if defined(HAVE_GETPAGESIZES) && defined(HAVE_MEMCNTL)
        -: 4256:    int ret = -1;
        -: 4257:    size_t sizes[32];
        -: 4258:    int avail = getpagesizes(sizes, 32);
        -: 4259:    if (avail != -1) {
        -: 4260:        size_t max = sizes[0];
        -: 4261:        struct memcntl_mha arg = {0};
        -: 4262:        int ii;
        -: 4263:
        -: 4264:        for (ii = 1; ii < avail; ++ii) {
        -: 4265:            if (max < sizes[ii]) {
        -: 4266:                max = sizes[ii];
        -: 4267:            }
        -: 4268:        }
        -: 4269:
        -: 4270:        arg.mha_flags   = 0;
        -: 4271:        arg.mha_pagesize = max;
        -: 4272:        arg.mha_cmd = MHA_MAPSIZE_BSSBRK;
        -: 4273:
        -: 4274:        if (memcntl(0, 0, MC_HAT_ADVISE, (caddr_t)&arg, 0, 0) == -1) {
        -: 4275:            fprintf(stderr, "Failed to set large pages: %s\n",
        -: 4276:                    strerror(errno));
        -: 4277:            fprintf(stderr, "Will use default page size\n");
        -: 4278:        } else {
        -: 4279:            ret = 0;
        -: 4280:        }
        -: 4281:    } else {
        -: 4282:        fprintf(stderr, "Failed to get supported pagesizes: %s\n",
        -: 4283:                strerror(errno));
        -: 4284:        fprintf(stderr, "Will use default page size\n");
        -: 4285:    }
        -: 4286:
        -: 4287:    return ret;
        -: 4288:#elif defined(__linux__) && defined(MADV_HUGEPAGE)
        -: 4289:    /* check if transparent hugepages is compiled into the kernel */
        -: 4290:    /* RH based systems possibly uses a different path */
    #####: 4291:    static const char *mm_thp_paths[] = {
        -: 4292:        "/sys/kernel/mm/transparent_hugepage/enabled",
        -: 4293:        "/sys/kernel/mm/redhat_transparent_hugepage/enabled",
        -: 4294:        NULL
        -: 4295:    };
        -: 4296:
    #####: 4297:    char thpb[128] = {0};
    #####: 4298:    int pfd = -1;
    #####: 4299:    for (const char **p = mm_thp_paths; *p; p++) {
    #####: 4300:        if ((pfd = open(*p, O_RDONLY)) != -1)
        -: 4301:            break;
        -: 4302:    }
        -: 4303:
    #####: 4304:    if (pfd == -1) {
    #####: 4305:        fprintf(stderr, "Transparent huge pages support not detected.\n");
    #####: 4306:        fprintf(stderr, "Will use default page size.\n");
    #####: 4307:        return -1;
        -: 4308:    }
    #####: 4309:    ssize_t rd = read(pfd, thpb, sizeof(thpb));
    #####: 4310:    close(pfd);
    #####: 4311:    if (rd <= 0) {
    #####: 4312:        fprintf(stderr, "Transparent huge pages could not read the configuration.\n");
    #####: 4313:        fprintf(stderr, "Will use default page size.\n");
    #####: 4314:        return -1;
        -: 4315:    }
    #####: 4316:    thpb[rd] = 0;
    #####: 4317:    if (strstr(thpb, "[never]")) {
    #####: 4318:        fprintf(stderr, "Transparent huge pages support disabled.\n");
    #####: 4319:        fprintf(stderr, "Will use default page size.\n");
    #####: 4320:        return -1;
        -: 4321:    }
        -: 4322:    return 0;
        -: 4323:#elif defined(__FreeBSD__)
        -: 4324:    int spages;
        -: 4325:    size_t spagesl = sizeof(spages);
        -: 4326:
        -: 4327:    if (sysctlbyname("vm.pmap.pg_ps_enabled", &spages,
        -: 4328:    &spagesl, NULL, 0) != 0) {
        -: 4329:        fprintf(stderr, "Could not evaluate the presence of superpages features.");
        -: 4330:        return -1;
        -: 4331:    }
        -: 4332:    if (spages != 1) {
        -: 4333:        fprintf(stderr, "Superpages support not detected.\n");
        -: 4334:        fprintf(stderr, "Will use default page size.\n");
        -: 4335:        return -1;
        -: 4336:    }
        -: 4337:    return 0;
        -: 4338:#else
        -: 4339:    return -1;
        -: 4340:#endif
        -: 4341:}
        -: 4342:
        -: 4343:/**
        -: 4344: * Do basic sanity check of the runtime environment
        -: 4345: * @return true if no errors found, false if we can't use this env
        -: 4346: */
      450: 4347:static bool sanitycheck(void) {
        -: 4348:    /* One of our biggest problems is old and bogus libevents */
      450: 4349:    const char *ever = event_get_version();
      450: 4350:    if (ever != NULL) {
      450: 4351:        if (strncmp(ever, "1.", 2) == 0) {
    #####: 4352:            fprintf(stderr, "You are using libevent %s.\nPlease upgrade to 2.x"
        -: 4353:                        " or newer\n", event_get_version());
    #####: 4354:            return false;
        -: 4355:        }
        -: 4356:    }
        -: 4357:
        -: 4358:    return true;
        -: 4359:}
        -: 4360:
    #####: 4361:static bool _parse_slab_sizes(char *s, uint32_t *slab_sizes) {
    #####: 4362:    char *b = NULL;
    #####: 4363:    uint32_t size = 0;
    #####: 4364:    int i = 0;
    #####: 4365:    uint32_t last_size = 0;
        -: 4366:
    #####: 4367:    if (strlen(s) < 1)
        -: 4368:        return false;
        -: 4369:
    #####: 4370:    for (char *p = strtok_r(s, "-", &b);
    #####: 4371:         p != NULL;
    #####: 4372:         p = strtok_r(NULL, "-", &b)) {
    #####: 4373:        if (!safe_strtoul(p, &size) || size < settings.chunk_size
    #####: 4374:             || size > settings.slab_chunk_size_max) {
    #####: 4375:            fprintf(stderr, "slab size %u is out of valid range\n", size);
    #####: 4376:            return false;
        -: 4377:        }
    #####: 4378:        if (last_size >= size) {
    #####: 4379:            fprintf(stderr, "slab size %u cannot be lower than or equal to a previous class size\n", size);
    #####: 4380:            return false;
        -: 4381:        }
    #####: 4382:        if (size <= last_size + CHUNK_ALIGN_BYTES) {
    #####: 4383:            fprintf(stderr, "slab size %u must be at least %d bytes larger than previous class\n",
        -: 4384:                    size, CHUNK_ALIGN_BYTES);
    #####: 4385:            return false;
        -: 4386:        }
    #####: 4387:        slab_sizes[i++] = size;
    #####: 4388:        last_size = size;
    #####: 4389:        if (i >= MAX_NUMBER_OF_SLAB_CLASSES-1) {
    #####: 4390:            fprintf(stderr, "too many slab classes specified\n");
    #####: 4391:            return false;
        -: 4392:        }
        -: 4393:    }
        -: 4394:
    #####: 4395:    slab_sizes[i] = 0;
    #####: 4396:    return true;
        -: 4397:}
        -: 4398:
        -: 4399:struct _mc_meta_data {
        -: 4400:    void *mmap_base;
        -: 4401:    uint64_t old_base;
        -: 4402:    char *slab_config; // string containing either factor or custom slab list.
        -: 4403:    int64_t time_delta;
        -: 4404:    uint64_t process_started;
        -: 4405:    uint32_t current_time;
        -: 4406:};
        -: 4407:
        -: 4408:// We need to remember a combination of configuration settings and global
        -: 4409:// state for restart viability and resumption of internal services.
        -: 4410:// Compared to the number of tunables and state values, relatively little
        -: 4411:// does need to be remembered.
        -: 4412:// Time is the hardest; we have to assume the sys clock is correct and re-sync for
        -: 4413:// the lost time after restart.
        1: 4414:static int _mc_meta_save_cb(const char *tag, void *ctx, void *data) {
        1: 4415:    struct _mc_meta_data *meta = (struct _mc_meta_data *)data;
        -: 4416:
        -: 4417:    // Settings to remember.
        -: 4418:    // TODO: should get a version of version which is numeric, else
        -: 4419:    // comparisons for compat reasons are difficult.
        -: 4420:    // it may be possible to punt on this for now; since we can test for the
        -: 4421:    // absence of another key... such as the new numeric version.
        -: 4422:    //restart_set_kv(ctx, "version", "%s", VERSION);
        -: 4423:    // We hold the original factor or subopts _string_
        -: 4424:    // it can be directly compared without roundtripping through floats or
        -: 4425:    // serializing/deserializing the long options list.
        1: 4426:    restart_set_kv(ctx, "slab_config", "%s", meta->slab_config);
        1: 4427:    restart_set_kv(ctx, "maxbytes", "%llu", (unsigned long long) settings.maxbytes);
        1: 4428:    restart_set_kv(ctx, "chunk_size", "%d", settings.chunk_size);
        1: 4429:    restart_set_kv(ctx, "item_size_max", "%d", settings.item_size_max);
        1: 4430:    restart_set_kv(ctx, "slab_chunk_size_max", "%d", settings.slab_chunk_size_max);
        1: 4431:    restart_set_kv(ctx, "slab_page_size", "%d", settings.slab_page_size);
        1: 4432:    restart_set_kv(ctx, "use_cas", "%s", settings.use_cas ? "true" : "false");
        1: 4433:    restart_set_kv(ctx, "slab_reassign", "%s", settings.slab_reassign ? "true" : "false");
        -: 4434:
        -: 4435:    // Online state to remember.
        -: 4436:
        -: 4437:    // current time is tough. we need to rely on the clock being correct to
        -: 4438:    // pull the delta between stop and start times. we also need to know the
        -: 4439:    // delta between start time and now to restore monotonic clocks.
        -: 4440:    // for non-monotonic clocks (some OS?), process_started is the only
        -: 4441:    // important one.
        1: 4442:    restart_set_kv(ctx, "current_time", "%u", current_time);
        -: 4443:    // types are great until... this. some systems time_t could be big, but
        -: 4444:    // I'm assuming never negative.
        1: 4445:    restart_set_kv(ctx, "process_started", "%llu", (unsigned long long) process_started);
        -: 4446:    {
        1: 4447:        struct timeval tv;
        1: 4448:        gettimeofday(&tv, NULL);
        1: 4449:        restart_set_kv(ctx, "stop_time", "%lu", tv.tv_sec);
        -: 4450:    }
        -: 4451:
        -: 4452:    // Might as well just fetch the next CAS value to use than tightly
        -: 4453:    // coupling the internal variable into the restart system.
        1: 4454:    restart_set_kv(ctx, "current_cas", "%llu", (unsigned long long) get_cas_id());
        1: 4455:    restart_set_kv(ctx, "logger_gid", "%llu", logger_get_gid());
        1: 4456:    restart_set_kv(ctx, "hashpower", "%u", stats_state.hash_power_level);
        -: 4457:    // NOTE: oldest_live is a rel_time_t, which aliases for unsigned int.
        -: 4458:    // should future proof this with a 64bit upcast, or fetch value from a
        -: 4459:    // converter function/macro?
        1: 4460:    restart_set_kv(ctx, "oldest_live", "%u", settings.oldest_live);
        -: 4461:    // TODO: use uintptr_t etc? is it portable enough?
        1: 4462:    restart_set_kv(ctx, "mmap_oldbase", "%p", meta->mmap_base);
        -: 4463:
        1: 4464:    return 0;
        -: 4465:}
        -: 4466:
        -: 4467:// We must see at least this number of checked lines. Else empty/missing lines
        -: 4468:// could cause a false-positive.
        -: 4469:// TODO: Once crc32'ing of the metadata file is done this could be ensured better by
        -: 4470:// the restart module itself (crc32 + count of lines must match on the
        -: 4471:// backend)
        -: 4472:#define RESTART_REQUIRED_META 16
        -: 4473:
        -: 4474:// With this callback we make a decision on if the current configuration
        -: 4475:// matches up enough to allow reusing the cache.
        -: 4476:// We also re-load important runtime information.
        1: 4477:static int _mc_meta_load_cb(const char *tag, void *ctx, void *data) {
        1: 4478:    struct _mc_meta_data *meta = (struct _mc_meta_data *)data;
        1: 4479:    char *key;
        1: 4480:    char *val;
        1: 4481:    int reuse_mmap = 0;
        1: 4482:    meta->process_started = 0;
        1: 4483:    meta->time_delta = 0;
        1: 4484:    meta->current_time = 0;
        1: 4485:    int lines_seen = 0;
        -: 4486:
        -: 4487:    // TODO: not sure this is any better than just doing an if/else tree with
        -: 4488:    // strcmp's...
        1: 4489:    enum {
        -: 4490:        R_MMAP_OLDBASE = 0,
        -: 4491:        R_MAXBYTES,
        -: 4492:        R_CHUNK_SIZE,
        -: 4493:        R_ITEM_SIZE_MAX,
        -: 4494:        R_SLAB_CHUNK_SIZE_MAX,
        -: 4495:        R_SLAB_PAGE_SIZE,
        -: 4496:        R_SLAB_CONFIG,
        -: 4497:        R_USE_CAS,
        -: 4498:        R_SLAB_REASSIGN,
        -: 4499:        R_CURRENT_CAS,
        -: 4500:        R_OLDEST_LIVE,
        -: 4501:        R_LOGGER_GID,
        -: 4502:        R_CURRENT_TIME,
        -: 4503:        R_STOP_TIME,
        -: 4504:        R_PROCESS_STARTED,
        -: 4505:        R_HASHPOWER,
        -: 4506:    };
        -: 4507:
        1: 4508:    const char *opts[] = {
        -: 4509:        [R_MMAP_OLDBASE] = "mmap_oldbase",
        -: 4510:        [R_MAXBYTES] = "maxbytes",
        -: 4511:        [R_CHUNK_SIZE] = "chunk_size",
        -: 4512:        [R_ITEM_SIZE_MAX] = "item_size_max",
        -: 4513:        [R_SLAB_CHUNK_SIZE_MAX] = "slab_chunk_size_max",
        -: 4514:        [R_SLAB_PAGE_SIZE] = "slab_page_size",
        -: 4515:        [R_SLAB_CONFIG] = "slab_config",
        -: 4516:        [R_USE_CAS] = "use_cas",
        -: 4517:        [R_SLAB_REASSIGN] = "slab_reassign",
        -: 4518:        [R_CURRENT_CAS] = "current_cas",
        -: 4519:        [R_OLDEST_LIVE] = "oldest_live",
        -: 4520:        [R_LOGGER_GID] = "logger_gid",
        -: 4521:        [R_CURRENT_TIME] = "current_time",
        -: 4522:        [R_STOP_TIME] = "stop_time",
        -: 4523:        [R_PROCESS_STARTED] = "process_started",
        -: 4524:        [R_HASHPOWER] = "hashpower",
        -: 4525:        NULL
        -: 4526:    };
        -: 4527:
       17: 4528:    while (restart_get_kv(ctx, &key, &val) == RESTART_OK) {
       16: 4529:        int type = 0;
       16: 4530:        int32_t val_int = 0;
       16: 4531:        uint32_t val_uint = 0;
       16: 4532:        int64_t bigval_int = 0;
       16: 4533:        uint64_t bigval_uint = 0;
        -: 4534:
      136: 4535:        while (opts[type] != NULL && strcmp(key, opts[type]) != 0) {
      120: 4536:            type++;
        -: 4537:        }
      16*: 4538:        if (opts[type] == NULL) {
    #####: 4539:            fprintf(stderr, "[restart] unknown/unhandled key: %s\n", key);
    #####: 4540:            continue;
        -: 4541:        }
       16: 4542:        lines_seen++;
        -: 4543:
        -: 4544:        // helper for any boolean checkers.
       16: 4545:        bool val_bool = false;
       16: 4546:        bool is_bool = true;
       16: 4547:        if (strcmp(val, "false") == 0) {
        -: 4548:            val_bool = false;
       16: 4549:        } else if (strcmp(val, "true") == 0) {
        -: 4550:            val_bool = true;
        -: 4551:        } else {
       14: 4552:            is_bool = false;
        -: 4553:        }
        -: 4554:
       16: 4555:        switch (type) {
        1: 4556:        case R_MMAP_OLDBASE:
        1: 4557:            if (!safe_strtoull_hex(val, &meta->old_base)) {
    #####: 4558:                fprintf(stderr, "[restart] failed to parse %s: %s\n", key, val);
    #####: 4559:                reuse_mmap = -1;
        -: 4560:            }
        -: 4561:            break;
        1: 4562:        case R_MAXBYTES:
        1: 4563:            if (!safe_strtoll(val, &bigval_int) || settings.maxbytes != bigval_int) {
        -: 4564:                reuse_mmap = -1;
        -: 4565:            }
        -: 4566:            break;
        1: 4567:        case R_CHUNK_SIZE:
        1: 4568:            if (!safe_strtol(val, &val_int) || settings.chunk_size != val_int) {
        -: 4569:                reuse_mmap = -1;
        -: 4570:            }
        -: 4571:            break;
        1: 4572:        case R_ITEM_SIZE_MAX:
        1: 4573:            if (!safe_strtol(val, &val_int) || settings.item_size_max != val_int) {
        -: 4574:                reuse_mmap = -1;
        -: 4575:            }
        -: 4576:            break;
        1: 4577:        case R_SLAB_CHUNK_SIZE_MAX:
        1: 4578:            if (!safe_strtol(val, &val_int) || settings.slab_chunk_size_max != val_int) {
        -: 4579:                reuse_mmap = -1;
        -: 4580:            }
        -: 4581:            break;
        1: 4582:        case R_SLAB_PAGE_SIZE:
        1: 4583:            if (!safe_strtol(val, &val_int) || settings.slab_page_size != val_int) {
        -: 4584:                reuse_mmap = -1;
        -: 4585:            }
        -: 4586:            break;
        1: 4587:        case R_SLAB_CONFIG:
        1: 4588:            if (strcmp(val, meta->slab_config) != 0) {
        -: 4589:                reuse_mmap = -1;
        -: 4590:            }
        -: 4591:            break;
        1: 4592:        case R_USE_CAS:
        1: 4593:            if (!is_bool || settings.use_cas != val_bool) {
        -: 4594:                reuse_mmap = -1;
        -: 4595:            }
        -: 4596:            break;
        1: 4597:        case R_SLAB_REASSIGN:
        1: 4598:            if (!is_bool || settings.slab_reassign != val_bool) {
        -: 4599:                reuse_mmap = -1;
        -: 4600:            }
        -: 4601:            break;
        1: 4602:        case R_CURRENT_CAS:
        -: 4603:            // FIXME: do we need to fail if these values _aren't_ found?
        1: 4604:            if (!safe_strtoull(val, &bigval_uint)) {
        -: 4605:                reuse_mmap = -1;
        -: 4606:            } else {
        1: 4607:                set_cas_id(bigval_uint);
        -: 4608:            }
        -: 4609:            break;
        1: 4610:        case R_OLDEST_LIVE:
        1: 4611:            if (!safe_strtoul(val, &val_uint)) {
        -: 4612:                reuse_mmap = -1;
        -: 4613:            } else {
        1: 4614:                settings.oldest_live = val_uint;
        -: 4615:            }
        -: 4616:            break;
        1: 4617:        case R_LOGGER_GID:
        1: 4618:            if (!safe_strtoull(val, &bigval_uint)) {
        -: 4619:                reuse_mmap = -1;
        -: 4620:            } else {
        1: 4621:                logger_set_gid(bigval_uint);
        -: 4622:            }
        -: 4623:            break;
        1: 4624:        case R_PROCESS_STARTED:
        1: 4625:            if (!safe_strtoull(val, &bigval_uint)) {
        -: 4626:                reuse_mmap = -1;
        -: 4627:            } else {
        1: 4628:                meta->process_started = bigval_uint;
        -: 4629:            }
        -: 4630:            break;
        1: 4631:        case R_CURRENT_TIME:
        1: 4632:            if (!safe_strtoul(val, &val_uint)) {
        -: 4633:                reuse_mmap = -1;
        -: 4634:            } else {
        1: 4635:                meta->current_time = val_uint;
        -: 4636:            }
        -: 4637:            break;
        1: 4638:        case R_STOP_TIME:
        1: 4639:            if (!safe_strtoll(val, &bigval_int)) {
        -: 4640:                reuse_mmap = -1;
        -: 4641:            } else {
        1: 4642:                struct timeval t;
        1: 4643:                gettimeofday(&t, NULL);
        1: 4644:                meta->time_delta = t.tv_sec - bigval_int;
        -: 4645:                // clock has done something crazy.
        -: 4646:                // there are _lots_ of ways the clock can go wrong here, but
        -: 4647:                // this is a safe sanity check since there's nothing else we
        -: 4648:                // can realistically do.
        1: 4649:                if (meta->time_delta <= 0) {
    #####: 4650:                    reuse_mmap = -1;
        -: 4651:                }
        -: 4652:            }
        -: 4653:            break;
        1: 4654:        case R_HASHPOWER:
        1: 4655:            if (!safe_strtoul(val, &val_uint)) {
        -: 4656:                reuse_mmap = -1;
        -: 4657:            } else {
        1: 4658:                settings.hashpower_init = val_uint;
        -: 4659:            }
        -: 4660:            break;
    #####: 4661:        default:
    #####: 4662:            fprintf(stderr, "[restart] unhandled key: %s\n", key);
        -: 4663:        }
        -: 4664:
      16*: 4665:        if (reuse_mmap != 0) {
    #####: 4666:            fprintf(stderr, "[restart] restart incompatible due to setting for [%s] [old value: %s]\n", key, val);
    #####: 4667:            break;
        -: 4668:        }
        -: 4669:    }
        -: 4670:
        1: 4671:    if (lines_seen < RESTART_REQUIRED_META) {
    #####: 4672:        fprintf(stderr, "[restart] missing some metadata lines\n");
    #####: 4673:        reuse_mmap = -1;
        -: 4674:    }
        -: 4675:
        1: 4676:    return reuse_mmap;
        -: 4677:}
        -: 4678:
      450: 4679:int main (int argc, char **argv) {
      450: 4680:    int c;
      450: 4681:    bool lock_memory = false;
      450: 4682:    bool do_daemonize = false;
      450: 4683:    bool preallocate = false;
      450: 4684:    int maxcore = 0;
      450: 4685:    char *username = NULL;
      450: 4686:    char *pid_file = NULL;
      450: 4687:    struct passwd *pw;
      450: 4688:    struct rlimit rlim;
      450: 4689:    char *buf;
      450: 4690:    char unit = '\0';
      450: 4691:    int size_max = 0;
      450: 4692:    int retval = EXIT_SUCCESS;
      450: 4693:    bool protocol_specified = false;
      450: 4694:    bool tcp_specified = false;
      450: 4695:    bool udp_specified = false;
      450: 4696:    bool start_lru_maintainer = true;
      450: 4697:    bool start_lru_crawler = true;
      450: 4698:    bool start_assoc_maint = true;
      450: 4699:    enum hashfunc_type hash_type = MURMUR3_HASH;
      450: 4700:    uint32_t tocrawl;
      450: 4701:    uint32_t slab_sizes[MAX_NUMBER_OF_SLAB_CLASSES];
      450: 4702:    bool use_slab_sizes = false;
      450: 4703:    char *slab_sizes_unparsed = NULL;
      450: 4704:    bool slab_chunk_size_changed = false;
        -: 4705:    // struct for restart code. Initialized up here so we can curry
        -: 4706:    // important settings to save or validate.
      450: 4707:    struct _mc_meta_data *meta = malloc(sizeof(struct _mc_meta_data));
      450: 4708:    meta->slab_config = NULL;
      450: 4709:    char *subopts, *subopts_orig;
      450: 4710:    char *subopts_value;
      450: 4711:    enum {
        -: 4712:        MAXCONNS_FAST = 0,
        -: 4713:        HASHPOWER_INIT,
        -: 4714:        NO_HASHEXPAND,
        -: 4715:        SLAB_REASSIGN,
        -: 4716:        SLAB_AUTOMOVE,
        -: 4717:        SLAB_AUTOMOVE_RATIO,
        -: 4718:        SLAB_AUTOMOVE_WINDOW,
        -: 4719:        TAIL_REPAIR_TIME,
        -: 4720:        HASH_ALGORITHM,
        -: 4721:        LRU_CRAWLER,
        -: 4722:        LRU_CRAWLER_SLEEP,
        -: 4723:        LRU_CRAWLER_TOCRAWL,
        -: 4724:        LRU_MAINTAINER,
        -: 4725:        HOT_LRU_PCT,
        -: 4726:        WARM_LRU_PCT,
        -: 4727:        HOT_MAX_FACTOR,
        -: 4728:        WARM_MAX_FACTOR,
        -: 4729:        TEMPORARY_TTL,
        -: 4730:        IDLE_TIMEOUT,
        -: 4731:        WATCHER_LOGBUF_SIZE,
        -: 4732:        WORKER_LOGBUF_SIZE,
        -: 4733:        SLAB_SIZES,
        -: 4734:        SLAB_CHUNK_MAX,
        -: 4735:        TRACK_SIZES,
        -: 4736:        NO_INLINE_ASCII_RESP,
        -: 4737:        MODERN,
        -: 4738:        NO_MODERN,
        -: 4739:        NO_CHUNKED_ITEMS,
        -: 4740:        NO_SLAB_REASSIGN,
        -: 4741:        NO_SLAB_AUTOMOVE,
        -: 4742:        NO_MAXCONNS_FAST,
        -: 4743:        INLINE_ASCII_RESP,
        -: 4744:        NO_LRU_CRAWLER,
        -: 4745:        NO_LRU_MAINTAINER,
        -: 4746:        NO_DROP_PRIVILEGES,
        -: 4747:        DROP_PRIVILEGES,
        -: 4748:        RESP_OBJ_MEM_LIMIT,
        -: 4749:        READ_BUF_MEM_LIMIT,
        -: 4750:#ifdef TLS
        -: 4751:        SSL_CERT,
        -: 4752:        SSL_KEY,
        -: 4753:        SSL_VERIFY_MODE,
        -: 4754:        SSL_KEYFORM,
        -: 4755:        SSL_CIPHERS,
        -: 4756:        SSL_CA_CERT,
        -: 4757:        SSL_WBUF_SIZE,
        -: 4758:        SSL_SESSION_CACHE,
        -: 4759:        SSL_KERNEL_TLS,
        -: 4760:        SSL_MIN_VERSION,
        -: 4761:#endif
        -: 4762:#ifdef PROXY
        -: 4763:        PROXY_CONFIG,
        -: 4764:        PROXY_ARG,
        -: 4765:        PROXY_URING,
        -: 4766:        PROXY_MEMPROFILE,
        -: 4767:#endif
        -: 4768:#ifdef MEMCACHED_DEBUG
        -: 4769:        RELAXED_PRIVILEGES,
        -: 4770:#endif
        -: 4771:#ifdef SOCK_COOKIE_ID
        -: 4772:        COOKIE_ID,
        -: 4773:#endif
        -: 4774:    };
      450: 4775:    char *const subopts_tokens[] = {
        -: 4776:        [MAXCONNS_FAST] = "maxconns_fast",
        -: 4777:        [HASHPOWER_INIT] = "hashpower",
        -: 4778:        [NO_HASHEXPAND] = "no_hashexpand",
        -: 4779:        [SLAB_REASSIGN] = "slab_reassign",
        -: 4780:        [SLAB_AUTOMOVE] = "slab_automove",
        -: 4781:        [SLAB_AUTOMOVE_RATIO] = "slab_automove_ratio",
        -: 4782:        [SLAB_AUTOMOVE_WINDOW] = "slab_automove_window",
        -: 4783:        [TAIL_REPAIR_TIME] = "tail_repair_time",
        -: 4784:        [HASH_ALGORITHM] = "hash_algorithm",
        -: 4785:        [LRU_CRAWLER] = "lru_crawler",
        -: 4786:        [LRU_CRAWLER_SLEEP] = "lru_crawler_sleep",
        -: 4787:        [LRU_CRAWLER_TOCRAWL] = "lru_crawler_tocrawl",
        -: 4788:        [LRU_MAINTAINER] = "lru_maintainer",
        -: 4789:        [HOT_LRU_PCT] = "hot_lru_pct",
        -: 4790:        [WARM_LRU_PCT] = "warm_lru_pct",
        -: 4791:        [HOT_MAX_FACTOR] = "hot_max_factor",
        -: 4792:        [WARM_MAX_FACTOR] = "warm_max_factor",
        -: 4793:        [TEMPORARY_TTL] = "temporary_ttl",
        -: 4794:        [IDLE_TIMEOUT] = "idle_timeout",
        -: 4795:        [WATCHER_LOGBUF_SIZE] = "watcher_logbuf_size",
        -: 4796:        [WORKER_LOGBUF_SIZE] = "worker_logbuf_size",
        -: 4797:        [SLAB_SIZES] = "slab_sizes",
        -: 4798:        [SLAB_CHUNK_MAX] = "slab_chunk_max",
        -: 4799:        [TRACK_SIZES] = "track_sizes",
        -: 4800:        [NO_INLINE_ASCII_RESP] = "no_inline_ascii_resp",
        -: 4801:        [MODERN] = "modern",
        -: 4802:        [NO_MODERN] = "no_modern",
        -: 4803:        [NO_CHUNKED_ITEMS] = "no_chunked_items",
        -: 4804:        [NO_SLAB_REASSIGN] = "no_slab_reassign",
        -: 4805:        [NO_SLAB_AUTOMOVE] = "no_slab_automove",
        -: 4806:        [NO_MAXCONNS_FAST] = "no_maxconns_fast",
        -: 4807:        [INLINE_ASCII_RESP] = "inline_ascii_resp",
        -: 4808:        [NO_LRU_CRAWLER] = "no_lru_crawler",
        -: 4809:        [NO_LRU_MAINTAINER] = "no_lru_maintainer",
        -: 4810:        [NO_DROP_PRIVILEGES] = "no_drop_privileges",
        -: 4811:        [DROP_PRIVILEGES] = "drop_privileges",
        -: 4812:        [RESP_OBJ_MEM_LIMIT] = "resp_obj_mem_limit",
        -: 4813:        [READ_BUF_MEM_LIMIT] = "read_buf_mem_limit",
        -: 4814:#ifdef TLS
        -: 4815:        [SSL_CERT] = "ssl_chain_cert",
        -: 4816:        [SSL_KEY] = "ssl_key",
        -: 4817:        [SSL_VERIFY_MODE] = "ssl_verify_mode",
        -: 4818:        [SSL_KEYFORM] = "ssl_keyformat",
        -: 4819:        [SSL_CIPHERS] = "ssl_ciphers",
        -: 4820:        [SSL_CA_CERT] = "ssl_ca_cert",
        -: 4821:        [SSL_WBUF_SIZE] = "ssl_wbuf_size",
        -: 4822:        [SSL_SESSION_CACHE] = "ssl_session_cache",
        -: 4823:        [SSL_KERNEL_TLS] = "ssl_kernel_tls",
        -: 4824:        [SSL_MIN_VERSION] = "ssl_min_version",
        -: 4825:#endif
        -: 4826:#ifdef PROXY
        -: 4827:        [PROXY_CONFIG] = "proxy_config",
        -: 4828:        [PROXY_ARG] = "proxy_arg",
        -: 4829:        [PROXY_URING] = "proxy_uring",
        -: 4830:        [PROXY_MEMPROFILE] = "proxy_memprofile",
        -: 4831:#endif
        -: 4832:#ifdef MEMCACHED_DEBUG
        -: 4833:        [RELAXED_PRIVILEGES] = "relaxed_privileges",
        -: 4834:#endif
        -: 4835:#ifdef SOCK_COOKIE_ID
        -: 4836:        [COOKIE_ID] = "sock_cookie_id",
        -: 4837:#endif
        -: 4838:        NULL
        -: 4839:    };
        -: 4840:
      450: 4841:    if (!sanitycheck()) {
    #####: 4842:        free(meta);
    #####: 4843:        return EX_OSERR;
        -: 4844:    }
        -: 4845:
        -: 4846:    /* handle SIGINT, SIGTERM */
      450: 4847:    signal(SIGINT, sig_handler);
      450: 4848:    signal(SIGTERM, sig_handler);
      450: 4849:    signal(SIGHUP, sighup_handler);
      450: 4850:    signal(SIGUSR1, sig_usrhandler);
        -: 4851:
        -: 4852:    /* init settings */
      450: 4853:    settings_init();
      450: 4854:    verify_default("hash_algorithm", hash_type == MURMUR3_HASH);
      450: 4855:    void *storage = NULL;
        -: 4856:#ifdef EXTSTORE
      450: 4857:    void *storage_cf = storage_init_config(&settings);
      450: 4858:    bool storage_enabled = false;
      450: 4859:    if (storage_cf == NULL) {
    #####: 4860:        fprintf(stderr, "failed to allocate extstore config\n");
    #####: 4861:        return 1;
        -: 4862:    }
        -: 4863:#endif
        -: 4864:
        -: 4865:    /* set stderr non-buffering (for running under, say, daemontools) */
      450: 4866:    setbuf(stderr, NULL);
        -: 4867:
      450: 4868:    char *shortopts =
        -: 4869:          "a:"  /* access mask for unix socket */
        -: 4870:          "A"   /* enable admin shutdown command */
        -: 4871:          "Z"   /* enable SSL */
        -: 4872:          "p:"  /* TCP port number to listen on */
        -: 4873:          "s:"  /* unix socket path to listen on */
        -: 4874:          "U:"  /* UDP port number to listen on */
        -: 4875:          "m:"  /* max memory to use for items in megabytes */
        -: 4876:          "M"   /* return error on memory exhausted */
        -: 4877:          "c:"  /* max simultaneous connections */
        -: 4878:          "k"   /* lock down all paged memory */
        -: 4879:          "hiV" /* help, licence info, version */
        -: 4880:          "r"   /* maximize core file limit */
        -: 4881:          "v"   /* verbose */
        -: 4882:          "d"   /* daemon mode */
        -: 4883:          "l:"  /* interface to listen on */
        -: 4884:          "u:"  /* user identity to run as */
        -: 4885:          "P:"  /* save PID in file */
        -: 4886:          "f:"  /* factor? */
        -: 4887:          "n:"  /* minimum space allocated for key+value+flags */
        -: 4888:          "t:"  /* threads */
        -: 4889:          "D:"  /* prefix delimiter? */
        -: 4890:          "L"   /* Large memory pages */
        -: 4891:          "R:"  /* max requests per event */
        -: 4892:          "C"   /* Disable use of CAS */
        -: 4893:          "b:"  /* backlog queue limit */
        -: 4894:          "B:"  /* Binding protocol */
        -: 4895:          "I:"  /* Max item size */
        -: 4896:          "S"   /* Sasl ON */
        -: 4897:          "F"   /* Disable flush_all */
        -: 4898:          "X"   /* Disable dump commands */
        -: 4899:          "W"   /* Disable watch commands */
        -: 4900:          "Y:"   /* Enable token auth */
        -: 4901:          "e:"  /* mmap path for external item memory */
        -: 4902:          "o:"  /* Extended generic options */
        -: 4903:          "N:"  /* NAPI ID based thread selection */
        -: 4904:          ;
        -: 4905:
        -: 4906:    /* process arguments */
        -: 4907:#ifdef HAVE_GETOPT_LONG
      450: 4908:    const struct option longopts[] = {
        -: 4909:        {"unix-mask", required_argument, 0, 'a'},
        -: 4910:        {"enable-shutdown", no_argument, 0, 'A'},
        -: 4911:        {"enable-ssl", no_argument, 0, 'Z'},
        -: 4912:        {"port", required_argument, 0, 'p'},
        -: 4913:        {"unix-socket", required_argument, 0, 's'},
        -: 4914:        {"udp-port", required_argument, 0, 'U'},
        -: 4915:        {"memory-limit", required_argument, 0, 'm'},
        -: 4916:        {"disable-evictions", no_argument, 0, 'M'},
        -: 4917:        {"conn-limit", required_argument, 0, 'c'},
        -: 4918:        {"lock-memory", no_argument, 0, 'k'},
        -: 4919:        {"help", no_argument, 0, 'h'},
        -: 4920:        {"license", no_argument, 0, 'i'},
        -: 4921:        {"version", no_argument, 0, 'V'},
        -: 4922:        {"enable-coredumps", no_argument, 0, 'r'},
        -: 4923:        {"verbose", optional_argument, 0, 'v'},
        -: 4924:        {"daemon", no_argument, 0, 'd'},
        -: 4925:        {"listen", required_argument, 0, 'l'},
        -: 4926:        {"user", required_argument, 0, 'u'},
        -: 4927:        {"pidfile", required_argument, 0, 'P'},
        -: 4928:        {"slab-growth-factor", required_argument, 0, 'f'},
        -: 4929:        {"slab-min-size", required_argument, 0, 'n'},
        -: 4930:        {"threads", required_argument, 0, 't'},
        -: 4931:        {"enable-largepages", no_argument, 0, 'L'},
        -: 4932:        {"max-reqs-per-event", required_argument, 0, 'R'},
        -: 4933:        {"disable-cas", no_argument, 0, 'C'},
        -: 4934:        {"listen-backlog", required_argument, 0, 'b'},
        -: 4935:        {"protocol", required_argument, 0, 'B'},
        -: 4936:        {"max-item-size", required_argument, 0, 'I'},
        -: 4937:        {"enable-sasl", no_argument, 0, 'S'},
        -: 4938:        {"disable-flush-all", no_argument, 0, 'F'},
        -: 4939:        {"disable-dumping", no_argument, 0, 'X'},
        -: 4940:        {"disable-watch", no_argument, 0, 'W'},
        -: 4941:        {"auth-file", required_argument, 0, 'Y'},
        -: 4942:        {"memory-file", required_argument, 0, 'e'},
        -: 4943:        {"extended", required_argument, 0, 'o'},
        -: 4944:        {"napi-ids", required_argument, 0, 'N'},
        -: 4945:        {0, 0, 0, 0}
        -: 4946:    };
      450: 4947:    int optindex;
      970: 4948:    while (-1 != (c = getopt_long(argc, argv, shortopts,
        -: 4949:                    longopts, &optindex))) {
        -: 4950:#else
        -: 4951:    while (-1 != (c = getopt(argc, argv, shortopts))) {
        -: 4952:#endif
      846: 4953:        if (optarg) {
      510: 4954:            while(isspace(optarg[0])) {
    #####: 4955:                optarg++;
        -: 4956:            }
        -: 4957:        }
      846: 4958:        switch (c) {
        5: 4959:        case 'A':
        -: 4960:            /* enables "shutdown" command */
        5: 4961:            settings.shutdown_command = true;
        5: 4962:            break;
    #####: 4963:        case 'Z':
        -: 4964:            /* enable secure communication*/
        -: 4965:#ifdef TLS
        -: 4966:            settings.ssl_enabled = true;
        -: 4967:#else
    #####: 4968:            fprintf(stderr, "This server is not built with TLS support.\n");
    #####: 4969:            exit(EX_USAGE);
        -: 4970:#endif
    #####: 4971:            break;
    #####: 4972:        case 'a':
        -: 4973:#ifndef DISABLE_UNIX_SOCKET
        -: 4974:            /* access for unix domain socket, as octal mask (like chmod)*/
    #####: 4975:            settings.access= strtol(optarg,NULL,8);
        -: 4976:#else
        -: 4977:            fprintf(stderr, "This server is not built with unix socket support.\n");
        -: 4978:            exit(EX_USAGE);
        -: 4979:#endif /* #ifndef DISABLE_UNIX_SOCKET */
    #####: 4980:            break;
       30: 4981:        case 'U':
       30: 4982:            settings.udpport = atoi(optarg);
       30: 4983:            udp_specified = true;
       30: 4984:            break;
       17: 4985:        case 'p':
       17: 4986:            settings.port = atoi(optarg);
       17: 4987:            tcp_specified = true;
       17: 4988:            break;
      104: 4989:        case 's':
        -: 4990:#ifndef DISABLE_UNIX_SOCKET
      104: 4991:            settings.socketpath = optarg;
        -: 4992:#else
        -: 4993:            fprintf(stderr, "This server is not built with unix socket support.\n");
        -: 4994:            exit(EX_USAGE);
        -: 4995:#endif /* #ifndef DISABLE_UNIX_SOCKET */
      104: 4996:            break;
       36: 4997:        case 'm':
       36: 4998:            settings.maxbytes = ((size_t)atoi(optarg)) * 1024 * 1024;
       36: 4999:            break;
        2: 5000:        case 'M':
        2: 5001:            settings.evict_to_free = 0;
        2: 5002:            break;
        2: 5003:        case 'c':
        2: 5004:            settings.maxconns = atoi(optarg);
        2: 5005:            if (settings.maxconns <= 0) {
        2: 5006:                fprintf(stderr, "Maximum connections must be greater than 0\n");
        2: 5007:                return 1;
        -: 5008:            }
        -: 5009:            break;
      319: 5010:        case 'h':
      319: 5011:            usage();
      319: 5012:            exit(EXIT_SUCCESS);
    #####: 5013:        case 'i':
    #####: 5014:            usage_license();
    #####: 5015:            exit(EXIT_SUCCESS);
        -: 5016:        case 'V':
    #####: 5017:            printf(PACKAGE " " VERSION "\n");
    #####: 5018:            exit(EXIT_SUCCESS);
        -: 5019:        case 'k':
        -: 5020:            lock_memory = true;
        -: 5021:            break;
        6: 5022:        case 'v':
        6: 5023:            settings.verbose++;
        6: 5024:            break;
        7: 5025:        case 'l':
        7: 5026:            if (settings.inter != NULL) {
    #####: 5027:                if (strstr(settings.inter, optarg) != NULL) {
        -: 5028:                    break;
        -: 5029:                }
    #####: 5030:                size_t len = strlen(settings.inter) + strlen(optarg) + 2;
    #####: 5031:                char *p = malloc(len);
    #####: 5032:                if (p == NULL) {
    #####: 5033:                    fprintf(stderr, "Failed to allocate memory\n");
    #####: 5034:                    return 1;
        -: 5035:                }
    #####: 5036:                snprintf(p, len, "%s,%s", settings.inter, optarg);
    #####: 5037:                free(settings.inter);
    #####: 5038:                settings.inter = p;
        -: 5039:            } else {
        7: 5040:                settings.inter= strdup(optarg);
        -: 5041:            }
        -: 5042:            break;
    #####: 5043:        case 'd':
    #####: 5044:            do_daemonize = true;
    #####: 5045:            break;
    #####: 5046:        case 'r':
    #####: 5047:            maxcore = 1;
    #####: 5048:            break;
        2: 5049:        case 'R':
        2: 5050:            settings.reqs_per_event = atoi(optarg);
        2: 5051:            if (settings.reqs_per_event <= 0) {
    #####: 5052:                fprintf(stderr, "Number of requests per event must be greater than 0\n");
    #####: 5053:                return 1;
        -: 5054:            }
        -: 5055:            break;
      124: 5056:        case 'u':
      124: 5057:            username = optarg;
      124: 5058:            break;
    #####: 5059:        case 'P':
    #####: 5060:            pid_file = optarg;
    #####: 5061:            break;
        2: 5062:        case 'e':
        2: 5063:            settings.memory_file = optarg;
        2: 5064:            break;
    #####: 5065:        case 'f':
    #####: 5066:            settings.factor = atof(optarg);
    #####: 5067:            if (settings.factor <= 1.0) {
    #####: 5068:                fprintf(stderr, "Factor must be greater than 1\n");
    #####: 5069:                return 1;
        -: 5070:            }
    #####: 5071:            meta->slab_config = strdup(optarg);
    #####: 5072:            break;
    #####: 5073:        case 'n':
    #####: 5074:            settings.chunk_size = atoi(optarg);
    #####: 5075:            if (settings.chunk_size <= 0) {
    #####: 5076:                fprintf(stderr, "Chunk size must be greater than 0\n");
    #####: 5077:                return 1;
        -: 5078:            }
        -: 5079:            break;
        2: 5080:        case 't':
        2: 5081:            settings.num_threads = atoi(optarg);
        2: 5082:            if (settings.num_threads <= 0) {
        1: 5083:                fprintf(stderr, "Number of threads must be greater than 0\n");
        1: 5084:                return 1;
        -: 5085:            }
        -: 5086:            /* There're other problems when you get above 64 threads.
        -: 5087:             * In the future we should portably detect # of cores for the
        -: 5088:             * default.
        -: 5089:             */
        1: 5090:            if (settings.num_threads > 64) {
    #####: 5091:                fprintf(stderr, "WARNING: Setting a high number of worker"
        -: 5092:                                "threads is not recommended.\n"
        -: 5093:                                " Set this value to the number of cores in"
        -: 5094:                                " your machine or less.\n");
        -: 5095:            }
        -: 5096:            break;
    #####: 5097:        case 'D':
    #####: 5098:            if (! optarg || ! optarg[0]) {
    #####: 5099:                fprintf(stderr, "No delimiter specified\n");
    #####: 5100:                return 1;
        -: 5101:            }
    #####: 5102:            settings.prefix_delimiter = optarg[0];
    #####: 5103:            settings.detail_enabled = 1;
    #####: 5104:            break;
    #####: 5105:        case 'L' :
    #####: 5106:            if (enable_large_pages() == 0) {
        -: 5107:                preallocate = true;
        -: 5108:            } else {
    #####: 5109:                fprintf(stderr, "Cannot enable large pages on this system\n"
        -: 5110:                    "(There is no support as of this version)\n");
    #####: 5111:                return 1;
        -: 5112:            }
        -: 5113:            break;
        1: 5114:        case 'C' :
        1: 5115:            settings.use_cas = false;
        1: 5116:            break;
        1: 5117:        case 'b' :
        1: 5118:            settings.backlog = atoi(optarg);
        1: 5119:            break;
        8: 5120:        case 'B':
        8: 5121:            protocol_specified = true;
        8: 5122:            if (strcmp(optarg, "auto") == 0) {
        2: 5123:                settings.binding_protocol = negotiating_prot;
        6: 5124:            } else if (strcmp(optarg, "binary") == 0) {
        3: 5125:                settings.binding_protocol = binary_prot;
        3: 5126:            } else if (strcmp(optarg, "ascii") == 0) {
        2: 5127:                settings.binding_protocol = ascii_prot;
        -: 5128:            } else {
        1: 5129:                fprintf(stderr, "Invalid value for binding protocol: %s\n"
        -: 5130:                        " -- should be one of auto, binary, or ascii\n", optarg);
        1: 5131:                exit(EX_USAGE);
        -: 5132:            }
        -: 5133:            break;
       10: 5134:        case 'I':
       10: 5135:            buf = strdup(optarg);
       10: 5136:            unit = buf[strlen(buf)-1];
       10: 5137:            if (unit == 'k' || unit == 'm' ||
        -: 5138:                unit == 'K' || unit == 'M') {
        6: 5139:                buf[strlen(buf)-1] = '\0';
        6: 5140:                size_max = atoi(buf);
        6: 5141:                if (unit == 'k' || unit == 'K')
        1: 5142:                    size_max *= 1024;
        6: 5143:                if (unit == 'm' || unit == 'M')
        5: 5144:                    size_max *= 1024 * 1024;
        6: 5145:                settings.item_size_max = size_max;
        -: 5146:            } else {
        4: 5147:                settings.item_size_max = atoi(buf);
        -: 5148:            }
       10: 5149:            free(buf);
       10: 5150:            break;
        1: 5151:        case 'S': /* set Sasl authentication to true. Default is false */
        -: 5152:#ifndef ENABLE_SASL
        1: 5153:            fprintf(stderr, "This server is not built with SASL support.\n");
        1: 5154:            exit(EX_USAGE);
        -: 5155:#endif
        -: 5156:            settings.sasl = true;
        -: 5157:            break;
        1: 5158:       case 'F' :
        1: 5159:            settings.flush_enabled = false;
        1: 5160:            break;
    #####: 5161:       case 'X' :
    #####: 5162:            settings.dump_enabled = false;
    #####: 5163:            break;
        1: 5164:       case 'W' :
        1: 5165:            settings.watch_enabled = false;
        1: 5166:            break;
        2: 5167:       case 'Y' :
        -: 5168:            // dupe the file path now just in case the options get mangled.
        2: 5169:            settings.auth_file = strdup(optarg);
        2: 5170:            break;
    #####: 5171:       case 'N':
    #####: 5172:            settings.num_napi_ids = atoi(optarg);
    #####: 5173:            if (settings.num_napi_ids <= 0) {
    #####: 5174:                fprintf(stderr, "Maximum number of NAPI IDs must be greater than 0\n");
    #####: 5175:                return 1;
        -: 5176:            }
        -: 5177:            break;
      163: 5178:        case 'o': /* It's sub-opts time! */
      163: 5179:            subopts_orig = subopts = strdup(optarg); /* getsubopt() changes the original args */
        -: 5180:
      464: 5181:            while (*subopts != '\0') {
        -: 5182:            // BSD getsubopt (at least) has undefined behavior on -1, so
        -: 5183:            // if we want to retry the getsubopt call in submodules we
        -: 5184:            // need an extra layer of string copies.
      303: 5185:            char *subopts_temp_o = NULL;
      303: 5186:            char *subopts_temp = subopts_temp_o = strdup(subopts);
        -: 5187:
      303: 5188:            switch (getsubopt(&subopts, subopts_tokens, &subopts_value)) {
    #####: 5189:            case MAXCONNS_FAST:
    #####: 5190:                settings.maxconns_fast = true;
    #####: 5191:                break;
    #####: 5192:            case HASHPOWER_INIT:
    #####: 5193:                if (subopts_value == NULL) {
    #####: 5194:                    fprintf(stderr, "Missing numeric argument for hashpower\n");
    #####: 5195:                    goto error;
        -: 5196:                }
    #####: 5197:                settings.hashpower_init = atoi(subopts_value);
    #####: 5198:                if (settings.hashpower_init < 12) {
    #####: 5199:                    fprintf(stderr, "Initial hashtable multiplier of %d is too low\n",
        -: 5200:                        settings.hashpower_init);
    #####: 5201:                    goto error;
    #####: 5202:                } else if (settings.hashpower_init > 32) {
    #####: 5203:                    fprintf(stderr, "Initial hashtable multiplier of %d is too high\n"
        -: 5204:                        "Choose a value based on \"STAT hash_power_level\" from a running instance\n",
        -: 5205:                        settings.hashpower_init);
    #####: 5206:                    goto error;
        -: 5207:                }
        -: 5208:                break;
        -: 5209:            case NO_HASHEXPAND:
      301: 5210:                start_assoc_maint = false;
        -: 5211:                break;
        5: 5212:            case SLAB_REASSIGN:
        5: 5213:                settings.slab_reassign = true;
        5: 5214:                break;
       14: 5215:            case SLAB_AUTOMOVE:
       14: 5216:                if (subopts_value == NULL) {
        2: 5217:                    settings.slab_automove = 1;
        2: 5218:                    break;
        -: 5219:                }
       12: 5220:                settings.slab_automove = atoi(subopts_value);
       12: 5221:                if (settings.slab_automove < 0 || settings.slab_automove > 2) {
    #####: 5222:                    fprintf(stderr, "slab_automove must be between 0 and 2\n");
    #####: 5223:                    goto error;
        -: 5224:                }
        -: 5225:                break;
    #####: 5226:            case SLAB_AUTOMOVE_RATIO:
    #####: 5227:                if (subopts_value == NULL) {
    #####: 5228:                    fprintf(stderr, "Missing slab_automove_ratio argument\n");
    #####: 5229:                    goto error;
        -: 5230:                }
    #####: 5231:                settings.slab_automove_ratio = atof(subopts_value);
    #####: 5232:                if (settings.slab_automove_ratio <= 0 || settings.slab_automove_ratio > 1) {
    #####: 5233:                    fprintf(stderr, "slab_automove_ratio must be > 0 and < 1\n");
    #####: 5234:                    goto error;
        -: 5235:                }
        -: 5236:                break;
        2: 5237:            case SLAB_AUTOMOVE_WINDOW:
        2: 5238:                if (subopts_value == NULL) {
    #####: 5239:                    fprintf(stderr, "Missing slab_automove_window argument\n");
    #####: 5240:                    goto error;
        -: 5241:                }
        2: 5242:                settings.slab_automove_window = atoi(subopts_value);
        2: 5243:                if (settings.slab_automove_window < 3) {
    #####: 5244:                    fprintf(stderr, "slab_automove_window must be > 2\n");
    #####: 5245:                    goto error;
        -: 5246:                }
        -: 5247:                break;
    #####: 5248:            case TAIL_REPAIR_TIME:
    #####: 5249:                if (subopts_value == NULL) {
    #####: 5250:                    fprintf(stderr, "Missing numeric argument for tail_repair_time\n");
    #####: 5251:                    goto error;
        -: 5252:                }
    #####: 5253:                settings.tail_repair_time = atoi(subopts_value);
    #####: 5254:                if (settings.tail_repair_time < 10) {
    #####: 5255:                    fprintf(stderr, "Cannot set tail_repair_time to less than 10 seconds\n");
    #####: 5256:                    goto error;
        -: 5257:                }
        -: 5258:                break;
    #####: 5259:            case HASH_ALGORITHM:
    #####: 5260:                if (subopts_value == NULL) {
    #####: 5261:                    fprintf(stderr, "Missing hash_algorithm argument\n");
    #####: 5262:                    goto error;
    #####: 5263:                };
    #####: 5264:                if (strcmp(subopts_value, "jenkins") == 0) {
        -: 5265:                    hash_type = JENKINS_HASH;
    #####: 5266:                } else if (strcmp(subopts_value, "murmur3") == 0) {
        -: 5267:                    hash_type = MURMUR3_HASH;
    #####: 5268:                } else if (strcmp(subopts_value, "xxh3") == 0) {
        -: 5269:                    hash_type = XXH3_HASH;
        -: 5270:                } else {
    #####: 5271:                    fprintf(stderr, "Unknown hash_algorithm option (jenkins, murmur3, xxh3)\n");
    #####: 5272:                    goto error;
        -: 5273:                }
        -: 5274:                break;
        6: 5275:            case LRU_CRAWLER:
        6: 5276:                start_lru_crawler = true;
        6: 5277:                break;
    #####: 5278:            case LRU_CRAWLER_SLEEP:
    #####: 5279:                if (subopts_value == NULL) {
    #####: 5280:                    fprintf(stderr, "Missing lru_crawler_sleep value\n");
    #####: 5281:                    goto error;
        -: 5282:                }
    #####: 5283:                settings.lru_crawler_sleep = atoi(subopts_value);
    #####: 5284:                if (settings.lru_crawler_sleep > 1000000 || settings.lru_crawler_sleep < 0) {
    #####: 5285:                    fprintf(stderr, "LRU crawler sleep must be between 0 and 1 second\n");
    #####: 5286:                    goto error;
        -: 5287:                }
        -: 5288:                break;
    #####: 5289:            case LRU_CRAWLER_TOCRAWL:
    #####: 5290:                if (subopts_value == NULL) {
    #####: 5291:                    fprintf(stderr, "Missing lru_crawler_tocrawl value\n");
    #####: 5292:                    goto error;
        -: 5293:                }
    #####: 5294:                if (!safe_strtoul(subopts_value, &tocrawl)) {
    #####: 5295:                    fprintf(stderr, "lru_crawler_tocrawl takes a numeric 32bit value\n");
    #####: 5296:                    goto error;
        -: 5297:                }
    #####: 5298:                settings.lru_crawler_tocrawl = tocrawl;
    #####: 5299:                break;
        5: 5300:            case LRU_MAINTAINER:
        5: 5301:                start_lru_maintainer = true;
        5: 5302:                settings.lru_segmented = true;
        5: 5303:                break;
    #####: 5304:            case HOT_LRU_PCT:
    #####: 5305:                if (subopts_value == NULL) {
    #####: 5306:                    fprintf(stderr, "Missing hot_lru_pct argument\n");
    #####: 5307:                    goto error;
        -: 5308:                }
    #####: 5309:                settings.hot_lru_pct = atoi(subopts_value);
    #####: 5310:                if (settings.hot_lru_pct < 1 || settings.hot_lru_pct >= 80) {
    #####: 5311:                    fprintf(stderr, "hot_lru_pct must be > 1 and < 80\n");
    #####: 5312:                    goto error;
        -: 5313:                }
        -: 5314:                break;
    #####: 5315:            case WARM_LRU_PCT:
    #####: 5316:                if (subopts_value == NULL) {
    #####: 5317:                    fprintf(stderr, "Missing warm_lru_pct argument\n");
    #####: 5318:                    goto error;
        -: 5319:                }
    #####: 5320:                settings.warm_lru_pct = atoi(subopts_value);
    #####: 5321:                if (settings.warm_lru_pct < 1 || settings.warm_lru_pct >= 80) {
    #####: 5322:                    fprintf(stderr, "warm_lru_pct must be > 1 and < 80\n");
    #####: 5323:                    goto error;
        -: 5324:                }
        -: 5325:                break;
    #####: 5326:            case HOT_MAX_FACTOR:
    #####: 5327:                if (subopts_value == NULL) {
    #####: 5328:                    fprintf(stderr, "Missing hot_max_factor argument\n");
    #####: 5329:                    goto error;
        -: 5330:                }
    #####: 5331:                settings.hot_max_factor = atof(subopts_value);
    #####: 5332:                if (settings.hot_max_factor <= 0) {
    #####: 5333:                    fprintf(stderr, "hot_max_factor must be > 0\n");
    #####: 5334:                    goto error;
        -: 5335:                }
        -: 5336:                break;
    #####: 5337:            case WARM_MAX_FACTOR:
    #####: 5338:                if (subopts_value == NULL) {
    #####: 5339:                    fprintf(stderr, "Missing warm_max_factor argument\n");
    #####: 5340:                    goto error;
        -: 5341:                }
    #####: 5342:                settings.warm_max_factor = atof(subopts_value);
    #####: 5343:                if (settings.warm_max_factor <= 0) {
    #####: 5344:                    fprintf(stderr, "warm_max_factor must be > 0\n");
    #####: 5345:                    goto error;
        -: 5346:                }
        -: 5347:                break;
        1: 5348:            case TEMPORARY_TTL:
        1: 5349:                if (subopts_value == NULL) {
    #####: 5350:                    fprintf(stderr, "Missing temporary_ttl argument\n");
    #####: 5351:                    goto error;
        -: 5352:                }
        1: 5353:                settings.temp_lru = true;
        1: 5354:                settings.temporary_ttl = atoi(subopts_value);
        1: 5355:                break;
        1: 5356:            case IDLE_TIMEOUT:
        1: 5357:                if (subopts_value == NULL) {
    #####: 5358:                    fprintf(stderr, "Missing numeric argument for idle_timeout\n");
    #####: 5359:                    goto error;
        -: 5360:                }
        1: 5361:                settings.idle_timeout = atoi(subopts_value);
        1: 5362:                break;
        4: 5363:            case WATCHER_LOGBUF_SIZE:
        4: 5364:                if (subopts_value == NULL) {
    #####: 5365:                    fprintf(stderr, "Missing watcher_logbuf_size argument\n");
    #####: 5366:                    goto error;
        -: 5367:                }
        4: 5368:                if (!safe_strtoul(subopts_value, &settings.logger_watcher_buf_size)) {
    #####: 5369:                    fprintf(stderr, "could not parse argument to watcher_logbuf_size\n");
    #####: 5370:                    goto error;
        -: 5371:                }
        4: 5372:                settings.logger_watcher_buf_size *= 1024; /* kilobytes */
        4: 5373:                break;
    #####: 5374:            case WORKER_LOGBUF_SIZE:
    #####: 5375:                if (subopts_value == NULL) {
    #####: 5376:                    fprintf(stderr, "Missing worker_logbuf_size argument\n");
    #####: 5377:                    goto error;
        -: 5378:                }
    #####: 5379:                if (!safe_strtoul(subopts_value, &settings.logger_buf_size)) {
    #####: 5380:                    fprintf(stderr, "could not parse argument to worker_logbuf_size\n");
    #####: 5381:                    goto error;
        -: 5382:                }
    #####: 5383:                settings.logger_buf_size *= 1024; /* kilobytes */
    #####: 5384:            case SLAB_SIZES:
    #####: 5385:                slab_sizes_unparsed = strdup(subopts_value);
    #####: 5386:                break;
        8: 5387:            case SLAB_CHUNK_MAX:
        8: 5388:                if (subopts_value == NULL) {
    #####: 5389:                    fprintf(stderr, "Missing slab_chunk_max argument\n");
    #####: 5390:                    goto error;
        -: 5391:                }
        8: 5392:                if (!safe_strtol(subopts_value, &settings.slab_chunk_size_max)) {
    #####: 5393:                    fprintf(stderr, "could not parse argument to slab_chunk_max\n");
    #####: 5394:                    goto error;
        -: 5395:                }
        8: 5396:                if (settings.slab_chunk_size_max <= 0) {
    #####: 5397:                    fprintf(stderr, "slab_chunk_max must be >= 0\n");
    #####: 5398:                    goto error;
        -: 5399:                }
        8: 5400:                if (settings.slab_chunk_size_max > (1 << 10)) {
    #####: 5401:                    fprintf(stderr, "slab_chunk_max must be specified in kilobytes.\n");
    #####: 5402:                    goto error;
        -: 5403:                }
        8: 5404:                settings.slab_chunk_size_max *= (1 << 10);
        8: 5405:                slab_chunk_size_changed = true;
        8: 5406:                break;
    #####: 5407:            case TRACK_SIZES:
    #####: 5408:                item_stats_sizes_init();
    #####: 5409:                break;
        -: 5410:            case NO_INLINE_ASCII_RESP:
        -: 5411:                break;
        -: 5412:            case INLINE_ASCII_RESP:
        -: 5413:                break;
    #####: 5414:            case NO_CHUNKED_ITEMS:
    #####: 5415:                settings.slab_chunk_size_max = settings.slab_page_size;
    #####: 5416:                break;
    #####: 5417:            case NO_SLAB_REASSIGN:
    #####: 5418:                settings.slab_reassign = false;
    #####: 5419:                break;
        1: 5420:            case NO_SLAB_AUTOMOVE:
        1: 5421:                settings.slab_automove = 0;
        1: 5422:                break;
    #####: 5423:            case NO_MAXCONNS_FAST:
    #####: 5424:                settings.maxconns_fast = false;
    #####: 5425:                break;
        4: 5426:            case NO_LRU_CRAWLER:
        4: 5427:                settings.lru_crawler = false;
        4: 5428:                start_lru_crawler = false;
        4: 5429:                break;
        1: 5430:            case NO_LRU_MAINTAINER:
        1: 5431:                start_lru_maintainer = false;
        1: 5432:                settings.lru_segmented = false;
        1: 5433:                break;
        -: 5434:#ifdef TLS
        -: 5435:            case SSL_CERT:
        -: 5436:                if (subopts_value == NULL) {
        -: 5437:                    fprintf(stderr, "Missing ssl_chain_cert argument\n");
        -: 5438:                    goto error;
        -: 5439:                }
        -: 5440:                settings.ssl_chain_cert = strdup(subopts_value);
        -: 5441:                break;
        -: 5442:            case SSL_KEY:
        -: 5443:                if (subopts_value == NULL) {
        -: 5444:                    fprintf(stderr, "Missing ssl_key argument\n");
        -: 5445:                    goto error;
        -: 5446:                }
        -: 5447:                settings.ssl_key = strdup(subopts_value);
        -: 5448:                break;
        -: 5449:            case SSL_VERIFY_MODE:
        -: 5450:            {
        -: 5451:                if (subopts_value == NULL) {
        -: 5452:                    fprintf(stderr, "Missing ssl_verify_mode argument\n");
        -: 5453:                    goto error;
        -: 5454:                }
        -: 5455:                int verify  = 0;
        -: 5456:                if (!safe_strtol(subopts_value, &verify)) {
        -: 5457:                    fprintf(stderr, "could not parse argument to ssl_verify_mode\n");
        -: 5458:                    goto error;
        -: 5459:                }
        -: 5460:                if (!ssl_set_verify_mode(verify)) {
        -: 5461:                    fprintf(stderr, "Invalid ssl_verify_mode. Use help to see valid options.\n");
        -: 5462:                    goto error;
        -: 5463:                }
        -: 5464:                break;
        -: 5465:            }
        -: 5466:            case SSL_KEYFORM:
        -: 5467:                if (subopts_value == NULL) {
        -: 5468:                    fprintf(stderr, "Missing ssl_keyformat argument\n");
        -: 5469:                    goto error;
        -: 5470:                }
        -: 5471:                if (!safe_strtol(subopts_value, &settings.ssl_keyformat)) {
        -: 5472:                    fprintf(stderr, "could not parse argument to ssl_keyformat\n");
        -: 5473:                    goto error;
        -: 5474:                }
        -: 5475:                break;
        -: 5476:            case SSL_CIPHERS:
        -: 5477:                if (subopts_value == NULL) {
        -: 5478:                    fprintf(stderr, "Missing ssl_ciphers argument\n");
        -: 5479:                    goto error;
        -: 5480:                }
        -: 5481:                settings.ssl_ciphers = strdup(subopts_value);
        -: 5482:                break;
        -: 5483:            case SSL_CA_CERT:
        -: 5484:                if (subopts_value == NULL) {
        -: 5485:                    fprintf(stderr, "Missing ssl_ca_cert argument\n");
        -: 5486:                    goto error;
        -: 5487:                }
        -: 5488:                settings.ssl_ca_cert = strdup(subopts_value);
        -: 5489:                break;
        -: 5490:            case SSL_WBUF_SIZE:
        -: 5491:                if (subopts_value == NULL) {
        -: 5492:                    fprintf(stderr, "Missing ssl_wbuf_size argument\n");
        -: 5493:                    goto error;
        -: 5494:                }
        -: 5495:                if (!safe_strtoul(subopts_value, &settings.ssl_wbuf_size)) {
        -: 5496:                    fprintf(stderr, "could not parse argument to ssl_wbuf_size\n");
        -: 5497:                    goto error;
        -: 5498:                }
        -: 5499:                settings.ssl_wbuf_size *= 1024; /* kilobytes */
        -: 5500:                break;
        -: 5501:            case SSL_SESSION_CACHE:
        -: 5502:                settings.ssl_session_cache = true;
        -: 5503:                break;
        -: 5504:            case SSL_KERNEL_TLS:
        -: 5505:                settings.ssl_kernel_tls = true;
        -: 5506:                break;
        -: 5507:            case SSL_MIN_VERSION: {
        -: 5508:                int min_version;
        -: 5509:                if (subopts_value == NULL) {
        -: 5510:                    fprintf(stderr, "Missing ssl_min_version argument\n");
        -: 5511:                    goto error;
        -: 5512:                }
        -: 5513:                if (!safe_strtol(subopts_value, &min_version)) {
        -: 5514:                    fprintf(stderr, "could not parse argument to ssl_min_version\n");
        -: 5515:                    goto error;
        -: 5516:                }
        -: 5517:                if (!ssl_set_min_version(min_version)) {
        -: 5518:                    fprintf(stderr, "Invalid ssl_min_version. Use help to see valid options.\n");
        -: 5519:                    goto error;
        -: 5520:                }
        -: 5521:                break;
        -: 5522:            }
        -: 5523:#endif
        -: 5524:            case MODERN:
        -: 5525:                /* currently no new defaults */
        -: 5526:                break;
        7: 5527:            case NO_MODERN:
        7: 5528:                if (!slab_chunk_size_changed) {
        7: 5529:                    settings.slab_chunk_size_max = settings.slab_page_size;
        -: 5530:                }
        7: 5531:                settings.slab_reassign = false;
        7: 5532:                settings.slab_automove = 0;
        7: 5533:                settings.maxconns_fast = false;
        7: 5534:                settings.lru_segmented = false;
        7: 5535:                hash_type = JENKINS_HASH;
        7: 5536:                start_lru_crawler = false;
        7: 5537:                start_lru_maintainer = false;
        7: 5538:                break;
    #####: 5539:            case NO_DROP_PRIVILEGES:
    #####: 5540:                settings.drop_privileges = false;
    #####: 5541:                break;
    #####: 5542:            case DROP_PRIVILEGES:
    #####: 5543:                settings.drop_privileges = true;
    #####: 5544:                break;
    #####: 5545:            case RESP_OBJ_MEM_LIMIT:
        -: 5546:                // TODO: Remove at some point in the future.
    #####: 5547:                fprintf(stderr, "DEPRECATED: resp_obj_mem_limit no longer used. See read_buf_mem_limit,\n");
    #####: 5548:                break;
        1: 5549:            case READ_BUF_MEM_LIMIT:
        1: 5550:                if (subopts_value == NULL) {
    #####: 5551:                    fprintf(stderr, "Missing read_buf_mem_limit argument\n");
    #####: 5552:                    goto error;
        -: 5553:                }
        1: 5554:                if (!safe_strtoul(subopts_value, &settings.read_buf_mem_limit)) {
    #####: 5555:                    fprintf(stderr, "could not parse argument to read_buf_mem_limit\n");
    #####: 5556:                    goto error;
        -: 5557:                }
        1: 5558:                settings.read_buf_mem_limit *= 1024 * 1024; /* megabytes */
        1: 5559:                break;
        -: 5560:#ifdef PROXY
        -: 5561:            case PROXY_CONFIG:
        -: 5562:                if (subopts_value == NULL) {
        -: 5563:                    fprintf(stderr, "Missing proxy_config file argument\n");
        -: 5564:                    goto error;
        -: 5565:                }
        -: 5566:                if (protocol_specified) {
        -: 5567:                    fprintf(stderr, "Cannot specify a protocol with proxy mode enabled\n");
        -: 5568:                    goto error;
        -: 5569:                }
        -: 5570:                settings.proxy_startfile = strdup(subopts_value);
        -: 5571:                settings.proxy_enabled = true;
        -: 5572:                settings.binding_protocol = proxy_prot;
        -: 5573:                protocol_specified = true;
        -: 5574:                break;
        -: 5575:            case PROXY_ARG:
        -: 5576:                settings.proxy_startarg = strdup(subopts_value);
        -: 5577:                break;
        -: 5578:            case PROXY_URING:
        -: 5579:                settings.proxy_uring = true;
        -: 5580:                break;
        -: 5581:            case PROXY_MEMPROFILE:
        -: 5582:                settings.proxy_memprofile = true;
        -: 5583:                break;
        -: 5584:#endif
        -: 5585:#ifdef MEMCACHED_DEBUG
      122: 5586:            case RELAXED_PRIVILEGES:
      122: 5587:                settings.relaxed_privileges = true;
      122: 5588:                break;
        -: 5589:#endif
        -: 5590:#ifdef SOCK_COOKIE_ID
    #####: 5591:            case COOKIE_ID:
    #####: 5592:                (void)safe_strtoul(subopts_value, &settings.sock_cookie_id);
    #####: 5593:                break;
        -: 5594:#endif
      120: 5595:            default:
        -: 5596:#ifdef EXTSTORE
        -: 5597:                // TODO: differentiating response code.
      120: 5598:                if (storage_read_config(storage_cf, &subopts_temp)) {
        2: 5599:                    goto error;
        -: 5600:                }
        -: 5601:#else
        -: 5602:                printf("Illegal suboption \"%s\"\n", subopts_temp);
        -: 5603:                goto error;
        -: 5604:#endif
        -: 5605:            } // switch
      301: 5606:            if (subopts_temp_o) {
      301: 5607:                free(subopts_temp_o);
        -: 5608:            }
        -: 5609:
        -: 5610:            } // while
      161: 5611:            free(subopts_orig);
      161: 5612:            break;
    #####: 5613:        default:
    #####: 5614:            fprintf(stderr, "Illegal argument \"%c\"\n", c);
    #####: 5615:            return 1;
        -: 5616:        }
        -: 5617:    }
        -: 5618:
      124: 5619:    if (settings.num_napi_ids > settings.num_threads) {
    #####: 5620:        fprintf(stderr, "Number of napi_ids(%d) cannot be greater than number of threads(%d)\n",
        -: 5621:                settings.num_napi_ids, settings.num_threads);
    #####: 5622:        exit(EX_USAGE);
        -: 5623:    }
        -: 5624:
      124: 5625:    if (settings.item_size_max < ITEM_SIZE_MAX_LOWER_LIMIT) {
        1: 5626:        fprintf(stderr, "Item max size cannot be less than 1024 bytes.\n");
        1: 5627:        exit(EX_USAGE);
        -: 5628:    }
      123: 5629:    if (settings.item_size_max > (settings.maxbytes / 2)) {
        1: 5630:        fprintf(stderr, "Cannot set item size limit higher than 1/2 of memory max.\n");
        1: 5631:        exit(EX_USAGE);
        -: 5632:    }
      122: 5633:    if (settings.item_size_max > (ITEM_SIZE_MAX_UPPER_LIMIT)) {
    #####: 5634:        fprintf(stderr, "Cannot set item size limit higher than a gigabyte.\n");
    #####: 5635:        exit(EX_USAGE);
        -: 5636:    }
      122: 5637:    if (settings.item_size_max > 1024 * 1024) {
        5: 5638:        if (!slab_chunk_size_changed) {
        -: 5639:            // Ideal new default is 16k, but needs stitching.
        5: 5640:            settings.slab_chunk_size_max = settings.slab_page_size / 2;
        -: 5641:        }
        -: 5642:    }
        -: 5643:
      122: 5644:    if (settings.slab_chunk_size_max > settings.item_size_max) {
    #####: 5645:        fprintf(stderr, "slab_chunk_max (bytes: %d) cannot be larger than -I (item_size_max %d)\n",
        -: 5646:                settings.slab_chunk_size_max, settings.item_size_max);
    #####: 5647:        exit(EX_USAGE);
        -: 5648:    }
        -: 5649:
      122: 5650:    if (settings.item_size_max % settings.slab_chunk_size_max != 0) {
    #####: 5651:        fprintf(stderr, "-I (item_size_max: %d) must be evenly divisible by slab_chunk_max (bytes: %d)\n",
        -: 5652:                settings.item_size_max, settings.slab_chunk_size_max);
    #####: 5653:        exit(EX_USAGE);
        -: 5654:    }
        -: 5655:
      122: 5656:    if (settings.slab_page_size % settings.slab_chunk_size_max != 0) {
    #####: 5657:        fprintf(stderr, "slab_chunk_max (bytes: %d) must divide evenly into %d (slab_page_size)\n",
        -: 5658:                settings.slab_chunk_size_max, settings.slab_page_size);
    #####: 5659:        exit(EX_USAGE);
        -: 5660:    }
        -: 5661:#ifdef EXTSTORE
      122: 5662:    switch (storage_check_config(storage_cf)) {
       13: 5663:        case 0:
       13: 5664:            storage_enabled = true;
       13: 5665:            break;
    #####: 5666:        case 1:
    #####: 5667:            exit(EX_USAGE);
      122: 5668:            break;
        -: 5669:    }
        -: 5670:#endif
        -: 5671:    // Reserve this for the new default. If factor size hasn't changed, use
        -: 5672:    // new default.
        -: 5673:    /*if (settings.slab_chunk_size_max == 16384 && settings.factor == 1.25) {
        -: 5674:        settings.factor = 1.08;
        -: 5675:    }*/
        -: 5676:
      122: 5677:    if (slab_sizes_unparsed != NULL) {
        -: 5678:        // want the unedited string for restart code.
    #####: 5679:        char *temp = strdup(slab_sizes_unparsed);
    #####: 5680:        if (_parse_slab_sizes(slab_sizes_unparsed, slab_sizes)) {
    #####: 5681:            use_slab_sizes = true;
    #####: 5682:            if (meta->slab_config) {
    #####: 5683:                free(meta->slab_config);
        -: 5684:            }
    #####: 5685:            meta->slab_config = temp;
        -: 5686:        } else {
    #####: 5687:            exit(EX_USAGE);
        -: 5688:        }
      122: 5689:    } else if (!meta->slab_config) {
        -: 5690:        // using the default factor.
      122: 5691:        meta->slab_config = "1.25";
        -: 5692:    }
        -: 5693:
      122: 5694:    if (settings.hot_lru_pct + settings.warm_lru_pct > 80) {
    #####: 5695:        fprintf(stderr, "hot_lru_pct + warm_lru_pct cannot be more than 80%% combined\n");
    #####: 5696:        exit(EX_USAGE);
        -: 5697:    }
        -: 5698:
      122: 5699:    if (settings.temp_lru && !start_lru_maintainer) {
    #####: 5700:        fprintf(stderr, "temporary_ttl requires lru_maintainer to be enabled\n");
    #####: 5701:        exit(EX_USAGE);
        -: 5702:    }
        -: 5703:
      122: 5704:    if (hash_init(hash_type) != 0) {
    #####: 5705:        fprintf(stderr, "Failed to initialize hash_algorithm!\n");
    #####: 5706:        exit(EX_USAGE);
        -: 5707:    }
        -: 5708:
        -: 5709:    /*
        -: 5710:     * Use one workerthread to serve each UDP port if the user specified
        -: 5711:     * multiple ports
        -: 5712:     */
      122: 5713:    if (settings.inter != NULL && strchr(settings.inter, ',')) {
    #####: 5714:        settings.num_threads_per_udp = 1;
        -: 5715:    } else {
      122: 5716:        settings.num_threads_per_udp = settings.num_threads;
        -: 5717:    }
        -: 5718:
      122: 5719:    if (settings.sasl) {
    #####: 5720:        if (!protocol_specified) {
    #####: 5721:            settings.binding_protocol = binary_prot;
        -: 5722:        } else {
    #####: 5723:            if (settings.binding_protocol != binary_prot) {
    #####: 5724:                fprintf(stderr, "ERROR: You cannot allow the ASCII protocol while using SASL.\n");
    #####: 5725:                exit(EX_USAGE);
        -: 5726:            }
        -: 5727:        }
        -: 5728:
    #####: 5729:        if (settings.udpport) {
    #####: 5730:            fprintf(stderr, "ERROR: Cannot enable UDP while using binary SASL authentication.\n");
    #####: 5731:            exit(EX_USAGE);
        -: 5732:        }
        -: 5733:    }
        -: 5734:
      122: 5735:    if (settings.auth_file) {
        2: 5736:        if (!protocol_specified) {
        2: 5737:            settings.binding_protocol = ascii_prot;
        -: 5738:        } else {
    #####: 5739:            if (settings.binding_protocol != ascii_prot) {
    #####: 5740:                fprintf(stderr, "ERROR: You cannot allow the BINARY protocol while using ascii authentication tokens.\n");
    #####: 5741:                exit(EX_USAGE);
        -: 5742:            }
        -: 5743:        }
        -: 5744:    }
        -: 5745:
      122: 5746:    if (udp_specified && settings.udpport != 0 && !tcp_specified) {
        2: 5747:        settings.port = settings.udpport;
        -: 5748:    }
        -: 5749:
      122: 5750:    if (settings.port > 65535) {
    #####: 5751:        fprintf(stderr, "ERROR: Invalid port number %d.\n", settings.port);
    #####: 5752:        exit(EX_USAGE);
        -: 5753:    }
        -: 5754:
        -: 5755:
        -: 5756:    /*
        -: 5757:     * Setup SSL if enabled
        -: 5758:     */
      122: 5759:    if (settings.ssl_enabled) {
    #####: 5760:        if (!settings.port) {
    #####: 5761:            fprintf(stderr, "ERROR: You cannot enable SSL without a TCP port.\n");
    #####: 5762:            exit(EX_USAGE);
        -: 5763:        }
        -: 5764:        // Initiate the SSL context.
      122: 5765:        ssl_init();
        -: 5766:    }
        -: 5767:
      122: 5768:    if (maxcore != 0) {
    #####: 5769:        struct rlimit rlim_new;
        -: 5770:        /*
        -: 5771:         * First try raising to infinity; if that fails, try bringing
        -: 5772:         * the soft limit to the hard.
        -: 5773:         */
    #####: 5774:        if (getrlimit(RLIMIT_CORE, &rlim) == 0) {
    #####: 5775:            rlim_new.rlim_cur = rlim_new.rlim_max = RLIM_INFINITY;
    #####: 5776:            if (setrlimit(RLIMIT_CORE, &rlim_new)!= 0) {
        -: 5777:                /* failed. try raising just to the old max */
    #####: 5778:                rlim_new.rlim_cur = rlim_new.rlim_max = rlim.rlim_max;
    #####: 5779:                (void)setrlimit(RLIMIT_CORE, &rlim_new);
        -: 5780:            }
        -: 5781:        }
        -: 5782:        /*
        -: 5783:         * getrlimit again to see what we ended up with. Only fail if
        -: 5784:         * the soft limit ends up 0, because then no core files will be
        -: 5785:         * created at all.
        -: 5786:         */
        -: 5787:
    #####: 5788:        if ((getrlimit(RLIMIT_CORE, &rlim) != 0) || rlim.rlim_cur == 0) {
    #####: 5789:            fprintf(stderr, "failed to ensure corefile creation\n");
    #####: 5790:            exit(EX_OSERR);
        -: 5791:        }
        -: 5792:    }
        -: 5793:
        -: 5794:    /*
        -: 5795:     * If needed, increase rlimits to allow as many connections
        -: 5796:     * as needed.
        -: 5797:     */
        -: 5798:
      122: 5799:    if (getrlimit(RLIMIT_NOFILE, &rlim) != 0) {
    #####: 5800:        fprintf(stderr, "failed to getrlimit number of files\n");
    #####: 5801:        exit(EX_OSERR);
        -: 5802:    } else {
      122: 5803:        rlim.rlim_cur = settings.maxconns;
      122: 5804:        rlim.rlim_max = settings.maxconns;
      122: 5805:        if (setrlimit(RLIMIT_NOFILE, &rlim) != 0) {
        -: 5806:#ifndef MEMCACHED_DEBUG
        -: 5807:            fprintf(stderr, "failed to set rlimit for open files. Try starting as root or requesting smaller maxconns value.\n");
        -: 5808:            exit(EX_OSERR);
        -: 5809:#endif
      122: 5810:        }
        -: 5811:    }
        -: 5812:
        -: 5813:    /* lose root privileges if we have them */
     122*: 5814:    if (getuid() == 0 || geteuid() == 0) {
      122: 5815:        if (username == 0 || *username == '\0') {
    #####: 5816:            fprintf(stderr, "must add '-u root' to start as root\n");
    #####: 5817:            exit(EX_USAGE);
        -: 5818:        }
      122: 5819:        if ((pw = getpwnam(username)) == 0) {
    #####: 5820:            fprintf(stderr, "can't find the user %s to switch to\n", username);
    #####: 5821:            exit(EX_NOUSER);
        -: 5822:        }
      122: 5823:        if (setgroups(0, NULL) < 0) {
        -: 5824:            /* setgroups may fail with EPERM, indicating we are already in a
        -: 5825:             * minimally-privileged state. In that case we continue. For all
        -: 5826:             * other failure codes we exit.
        -: 5827:             *
        -: 5828:             * Note that errno is stored here because fprintf may change it.
        -: 5829:             */
    #####: 5830:            bool should_exit = errno != EPERM;
    #####: 5831:            fprintf(stderr, "failed to drop supplementary groups: %s\n",
        -: 5832:                    strerror(errno));
    #####: 5833:            if (should_exit) {
    #####: 5834:                exit(EX_OSERR);
        -: 5835:            }
        -: 5836:        }
      122: 5837:        if (setgid(pw->pw_gid) < 0 || setuid(pw->pw_uid) < 0) {
    #####: 5838:            fprintf(stderr, "failed to assume identity of user %s\n", username);
    #####: 5839:            exit(EX_OSERR);
        -: 5840:        }
        -: 5841:    }
        -: 5842:
        -: 5843:    /* Initialize Sasl if -S was specified */
      122: 5844:    if (settings.sasl) {
      122: 5845:        init_sasl();
        -: 5846:    }
        -: 5847:
        -: 5848:    /* daemonize if requested */
        -: 5849:    /* if we want to ensure our ability to dump core, don't chdir to / */
      122: 5850:    if (do_daemonize) {
    #####: 5851:        if (daemonize(maxcore, settings.verbose) == -1) {
    #####: 5852:            fprintf(stderr, "failed to daemon() in order to daemonize\n");
    #####: 5853:            exit(EXIT_FAILURE);
        -: 5854:        }
        -: 5855:    }
        -: 5856:
        -: 5857:    /* lock paged memory if needed */
      123: 5858:    if (lock_memory) {
        -: 5859:#ifdef HAVE_MLOCKALL
    #####: 5860:        int res = mlockall(MCL_CURRENT | MCL_FUTURE);
    #####: 5861:        if (res != 0) {
    #####: 5862:            fprintf(stderr, "warning: -k invalid, mlockall() failed: %s\n",
    #####: 5863:                    strerror(errno));
        -: 5864:        }
        -: 5865:#else
        -: 5866:        fprintf(stderr, "warning: -k invalid, mlockall() not supported on this platform.  proceeding without.\n");
        -: 5867:#endif
        -: 5868:    }
        -: 5869:
        -: 5870:    /* initialize main thread libevent instance */
        -: 5871:#if defined(LIBEVENT_VERSION_NUMBER) && LIBEVENT_VERSION_NUMBER >= 0x02000101
        -: 5872:    /* If libevent version is larger/equal to 2.0.2-alpha, use newer version */
      123: 5873:    struct event_config *ev_config;
      123: 5874:    ev_config = event_config_new();
      123: 5875:    event_config_set_flag(ev_config, EVENT_BASE_FLAG_NOLOCK);
      123: 5876:    main_base = event_base_new_with_config(ev_config);
      123: 5877:    event_config_free(ev_config);
        -: 5878:#else
        -: 5879:    /* Otherwise, use older API */
        -: 5880:    main_base = event_init();
        -: 5881:#endif
        -: 5882:
        -: 5883:    /* Load initial auth file if required */
      123: 5884:    if (settings.auth_file) {
        2: 5885:        if (settings.udpport) {
    #####: 5886:            fprintf(stderr, "Cannot use UDP with ascii authentication enabled (-U 0 to disable)\n");
    #####: 5887:            exit(EX_USAGE);
        -: 5888:        }
        -: 5889:
        2: 5890:        switch (authfile_load(settings.auth_file)) {
    #####: 5891:            case AUTHFILE_STATFAIL:
    #####: 5892:                vperror("Could not stat authfile [%s], error %s", settings.auth_file
    #####: 5893:                                                            , strerror(errno));
    #####: 5894:                exit(EXIT_FAILURE);
    #####: 5895:                break;
    #####: 5896:            case AUTHFILE_OPENFAIL:
    #####: 5897:                vperror("Could not open authfile [%s] for reading, error %s", settings.auth_file
    #####: 5898:                                                                           , strerror(errno));
    #####: 5899:                exit(EXIT_FAILURE);
    #####: 5900:                break;
    #####: 5901:            case AUTHFILE_OOM:
    #####: 5902:                fprintf(stderr, "Out of memory reading password file: %s", settings.auth_file);
    #####: 5903:                exit(EXIT_FAILURE);
    #####: 5904:                break;
    #####: 5905:            case AUTHFILE_MALFORMED:
    #####: 5906:                fprintf(stderr, "Authfile [%s] has a malformed entry. Should be 'user:password'", settings.auth_file);
    #####: 5907:                exit(EXIT_FAILURE);
        -: 5908:                break;
        -: 5909:            case AUTHFILE_OK:
        -: 5910:                break;
        -: 5911:        }
        -: 5912:    }
        -: 5913:
        -: 5914:    /* initialize other stuff */
      123: 5915:    stats_init();
      123: 5916:    logger_init();
      123: 5917:    logger_create(); // main process logger
      123: 5918:    conn_init();
      123: 5919:    bool reuse_mem = false;
      123: 5920:    void *mem_base = NULL;
      123: 5921:    bool prefill = false;
      123: 5922:    if (settings.memory_file != NULL) {
        2: 5923:        preallocate = true;
        -: 5924:        // Easier to manage memory if we prefill the global pool when reusing.
        2: 5925:        prefill = true;
        2: 5926:        restart_register("main", _mc_meta_load_cb, _mc_meta_save_cb, meta);
        4: 5927:        reuse_mem = restart_mmap_open(settings.maxbytes,
        2: 5928:                        settings.memory_file,
        -: 5929:                        &mem_base);
        -: 5930:        // The "save" callback gets called when we're closing out the mmap,
        -: 5931:        // but we don't know what the mmap_base is until after we call open.
        -: 5932:        // So we pass the struct above but have to fill it in here so the
        -: 5933:        // data's available during the save routine.
        2: 5934:        meta->mmap_base = mem_base;
        -: 5935:        // Also, the callbacks for load() run before _open returns, so we
        -: 5936:        // should have the old base in 'meta' as of here.
        -: 5937:    }
        -: 5938:    // Initialize the hash table _after_ checking restart metadata.
        -: 5939:    // We override the hash table start argument with what was live
        -: 5940:    // previously, to avoid filling a huge set of items into a tiny hash
        -: 5941:    // table.
      123: 5942:    assoc_init(settings.hashpower_init);
        -: 5943:#ifdef EXTSTORE
      123: 5944:    if (storage_enabled && reuse_mem) {
    #####: 5945:        fprintf(stderr, "[restart] memory restart with extstore not presently supported.\n");
    #####: 5946:        reuse_mem = false;
        -: 5947:    }
        -: 5948:#endif
      246: 5949:    slabs_init(settings.maxbytes, settings.factor, preallocate,
        -: 5950:            use_slab_sizes ? slab_sizes : NULL, mem_base, reuse_mem);
        -: 5951:#ifdef EXTSTORE
      123: 5952:    if (storage_enabled) {
       13: 5953:        storage = storage_init(storage_cf);
       13: 5954:        if (storage == NULL) {
        1: 5955:            exit(EXIT_FAILURE);
        -: 5956:        }
       12: 5957:        ext_storage = storage;
        -: 5958:        /* page mover algorithm for extstore needs memory prefilled */
       12: 5959:        prefill = true;
        -: 5960:    }
        -: 5961:#endif
        -: 5962:
      122: 5963:    if (settings.drop_privileges) {
      122: 5964:        setup_privilege_violations_handler();
        -: 5965:    }
        -: 5966:
      122: 5967:    if (prefill)
       14: 5968:        slabs_prefill_global();
        -: 5969:    /* In restartable mode and we've decided to issue a fixup on memory */
      122: 5970:    if (settings.memory_file != NULL && reuse_mem) {
        1: 5971:        mc_ptr_t old_base = meta->old_base;
        1: 5972:        assert(old_base == meta->old_base);
        -: 5973:
        -: 5974:        // should've pulled in process_started from meta file.
        1: 5975:        process_started = meta->process_started;
        -: 5976:        // TODO: must be a more canonical way of serializing/deserializing
        -: 5977:        // pointers? passing through uint64_t should work, and we're not
        -: 5978:        // annotating the pointer with anything, but it's still slightly
        -: 5979:        // insane.
        1: 5980:        restart_fixup((void *)old_base);
        -: 5981:    }
        -: 5982:    /*
        -: 5983:     * ignore SIGPIPE signals; we can use errno == EPIPE if we
        -: 5984:     * need that information
        -: 5985:     */
      122: 5986:    if (signal(SIGPIPE, SIG_IGN) == SIG_ERR) {
    #####: 5987:        perror("failed to ignore SIGPIPE; sigaction");
    #####: 5988:        exit(EX_OSERR);
        -: 5989:    }
        -: 5990:    /* start up worker threads if MT mode */
        -: 5991:#ifdef PROXY
        -: 5992:    if (settings.proxy_enabled) {
        -: 5993:        settings.proxy_ctx = proxy_init(settings.proxy_uring, settings.proxy_memprofile);
        -: 5994:    }
        -: 5995:#endif
        -: 5996:#ifdef EXTSTORE
      122: 5997:    memcached_thread_init(settings.num_threads, storage);
      122: 5998:    init_lru_crawler(storage);
        -: 5999:#else
        -: 6000:    memcached_thread_init(settings.num_threads, NULL);
        -: 6001:    init_lru_crawler(NULL);
        -: 6002:#endif
        -: 6003:
        -: 6004:#ifdef PROXY
        -: 6005:    if (settings.proxy_enabled) {
        -: 6006:        if (proxy_first_confload(settings.proxy_ctx) != 0) {
        -: 6007:            exit(EXIT_FAILURE);
        -: 6008:        }
        -: 6009:    }
        -: 6010:#endif
        -: 6011:
      122: 6012:    if (start_assoc_maint && start_assoc_maintenance_thread() == -1) {
    #####: 6013:        exit(EXIT_FAILURE);
        -: 6014:    }
      122: 6015:    if (start_lru_crawler && start_item_crawler_thread() != 0) {
    #####: 6016:        fprintf(stderr, "Failed to enable LRU crawler thread\n");
    #####: 6017:        exit(EXIT_FAILURE);
        -: 6018:    }
        -: 6019:#ifdef EXTSTORE
      122: 6020:    if (storage && start_storage_compact_thread(storage) != 0) {
    #####: 6021:        fprintf(stderr, "Failed to start storage compaction thread\n");
    #####: 6022:        exit(EXIT_FAILURE);
        -: 6023:    }
       12: 6024:    if (storage && start_storage_write_thread(storage) != 0) {
    #####: 6025:        fprintf(stderr, "Failed to start storage writer thread\n");
    #####: 6026:        exit(EXIT_FAILURE);
        -: 6027:    }
        -: 6028:
      122: 6029:    if (start_lru_maintainer && start_lru_maintainer_thread(storage) != 0) {
        -: 6030:#else
        -: 6031:    if (start_lru_maintainer && start_lru_maintainer_thread(NULL) != 0) {
        -: 6032:#endif
    #####: 6033:        fprintf(stderr, "Failed to enable LRU maintainer thread\n");
    #####: 6034:        free(meta);
    #####: 6035:        return 1;
        -: 6036:    }
        -: 6037:
      122: 6038:    if (settings.slab_reassign) {
      115: 6039:        settings.slab_rebal = start_slab_maintenance_thread(storage);
      115: 6040:        if (!settings.slab_rebal) {
    #####: 6041:            exit(EXIT_FAILURE);
        -: 6042:        }
        -: 6043:    }
        -: 6044:
      122: 6045:    if (settings.idle_timeout && start_conn_timeout_thread() == -1) {
    #####: 6046:        exit(EXIT_FAILURE);
        -: 6047:    }
        -: 6048:
        -: 6049:    /* initialise clock event */
        -: 6050:#if defined(HAVE_CLOCK_GETTIME) && defined(CLOCK_MONOTONIC)
        -: 6051:    {
      122: 6052:        struct timespec ts;
      122: 6053:        if (clock_gettime(CLOCK_MONOTONIC, &ts) == 0) {
      122: 6054:            monotonic = true;
      122: 6055:            monotonic_start = ts.tv_sec;
        -: 6056:            // Monotonic clock needs special handling for restarts.
        -: 6057:            // We get a start time at an arbitrary place, so we need to
        -: 6058:            // restore the original time delta, which is always "now" - _start
      122: 6059:            if (reuse_mem) {
        -: 6060:                // the running timespan at stop time + the time we think we
        -: 6061:                // were stopped.
        1: 6062:                monotonic_start -= meta->current_time + meta->time_delta;
        -: 6063:            } else {
      121: 6064:                monotonic_start -= ITEM_UPDATE_INTERVAL + 2;
        -: 6065:            }
        -: 6066:        }
        -: 6067:    }
        -: 6068:#endif
      122: 6069:    clock_handler(0, 0, 0);
        -: 6070:
        -: 6071:    /* create unix mode sockets after dropping privileges */
      122: 6072:    if (settings.socketpath != NULL) {
      101: 6073:        errno = 0;
      101: 6074:        if (server_socket_unix(settings.socketpath,settings.access)) {
    #####: 6075:            vperror("failed to listen on UNIX socket: %s", settings.socketpath);
    #####: 6076:            exit(EX_OSERR);
        -: 6077:        }
        -: 6078:    }
        -: 6079:
        -: 6080:    /* create the listening socket, bind it, and init */
      122: 6081:    if (settings.socketpath == NULL) {
       21: 6082:        const char *portnumber_filename = getenv("MEMCACHED_PORT_FILENAME");
       21: 6083:        char *temp_portnumber_filename = NULL;
       21: 6084:        size_t len;
       21: 6085:        FILE *portnumber_file = NULL;
        -: 6086:
       21: 6087:        if (portnumber_filename != NULL) {
       14: 6088:            len = strlen(portnumber_filename)+4+1;
       14: 6089:            temp_portnumber_filename = malloc(len);
       14: 6090:            if (temp_portnumber_filename == NULL) {
    #####: 6091:                vperror("Failed to allocate memory for portnumber file");
    #####: 6092:                exit(EX_OSERR);
        -: 6093:            }
       14: 6094:            snprintf(temp_portnumber_filename,
        -: 6095:                     len,
        -: 6096:                     "%s.lck", portnumber_filename);
        -: 6097:
       14: 6098:            portnumber_file = fopen(temp_portnumber_filename, "a");
       14: 6099:            if (portnumber_file == NULL) {
    #####: 6100:                fprintf(stderr, "Failed to open \"%s\": %s\n",
    #####: 6101:                        temp_portnumber_filename, strerror(errno));
        -: 6102:            }
        -: 6103:        }
        -: 6104:
       21: 6105:        errno = 0;
       21: 6106:        if (settings.port && server_sockets(settings.port, tcp_transport,
        -: 6107:                                           portnumber_file)) {
        1: 6108:            if (settings.inter == NULL) {
    #####: 6109:                vperror("failed to listen on TCP port %d", settings.port);
        -: 6110:            } else {
        1: 6111:                vperror("failed to listen on one of interface(s) %s", settings.inter);
        -: 6112:            }
        1: 6113:            free(temp_portnumber_filename);
        1: 6114:            exit(EX_OSERR);
        -: 6115:        }
        -: 6116:
        -: 6117:        /*
        -: 6118:         * initialization order: first create the listening sockets
        -: 6119:         * (may need root on low ports), then drop root if needed,
        -: 6120:         * then daemonize if needed, then init libevent (in some cases
        -: 6121:         * descriptors created by libevent wouldn't survive forking).
        -: 6122:         */
        -: 6123:
        -: 6124:        /* create the UDP listening socket and bind it */
       20: 6125:        errno = 0;
       20: 6126:        if (settings.udpport && server_sockets(settings.udpport, udp_transport,
        -: 6127:                                              portnumber_file)) {
    #####: 6128:            if (settings.inter == NULL) {
    #####: 6129:                vperror("failed to listen on UDP port %d", settings.udpport);
        -: 6130:            } else {
    #####: 6131:                vperror("failed to listen on one of interface(s) %s", settings.inter);
        -: 6132:            }
    #####: 6133:            free(temp_portnumber_filename);
    #####: 6134:            exit(EX_OSERR);
        -: 6135:        }
        -: 6136:
       20: 6137:        if (portnumber_file) {
       14: 6138:            fclose(portnumber_file);
       14: 6139:            rename(temp_portnumber_filename, portnumber_filename);
        -: 6140:        }
       20: 6141:        if (temp_portnumber_filename)
       14: 6142:            free(temp_portnumber_filename);
        -: 6143:    }
        -: 6144:
        -: 6145:    /* Give the sockets a moment to open. I know this is dumb, but the error
        -: 6146:     * is only an advisory.
        -: 6147:     */
      121: 6148:    usleep(1000);
      121: 6149:    if (stats_state.curr_conns + stats_state.reserved_fds >= settings.maxconns - 1) {
    #####: 6150:        fprintf(stderr, "Maxconns setting is too low, use -c to increase.\n");
    #####: 6151:        exit(EXIT_FAILURE);
        -: 6152:    }
        -: 6153:
      121: 6154:    if (pid_file != NULL) {
        1: 6155:        save_pid(pid_file);
        -: 6156:    }
        -: 6157:
        -: 6158:    /* Drop privileges no longer needed */
      121: 6159:    if (settings.drop_privileges) {
      121: 6160:        drop_privileges();
        -: 6161:    }
        -: 6162:
        -: 6163:    /* Initialize the uriencode lookup table. */
      121: 6164:    uriencode_init();
        -: 6165:
        -: 6166:    /* enter the event loop */
     2692: 6167:    while (!stop_main_loop) {
     2571: 6168:        if (event_base_loop(main_base, EVLOOP_ONCE) != 0) {
        -: 6169:            retval = EXIT_FAILURE;
        -: 6170:            break;
        -: 6171:        }
        -: 6172:    }
        -: 6173:
      121: 6174:    switch (stop_main_loop) {
        2: 6175:        case GRACE_STOP:
        2: 6176:            fprintf(stderr, "Gracefully stopping\n");
        2: 6177:        break;
      119: 6178:        case EXIT_NORMALLY:
        -: 6179:            // Don't need to print anything to STDERR for a normal shutdown except
        -: 6180:            // if we want to.
        -: 6181:
      119: 6182:            if (settings.verbose) {
        3: 6183:                fprintf(stderr, "Exiting normally\n");
        -: 6184:            }
        -: 6185:
        -: 6186:        break;
    #####: 6187:        default:
    #####: 6188:            fprintf(stderr, "Exiting on error\n");
    #####: 6189:        break;
        -: 6190:    }
        -: 6191:
      121: 6192:    if (stop_main_loop == GRACE_STOP) {
        2: 6193:        stop_threads();
        2: 6194:        if (settings.memory_file != NULL) {
        1: 6195:            restart_mmap_close();
        -: 6196:        }
        -: 6197:    }
        -: 6198:
        -: 6199:    /* remove the PID file if we're a daemon */
      121: 6200:    if (do_daemonize)
        1: 6201:        remove_pidfile(pid_file);
        -: 6202:    /* Clean up strdup() call for bind() address */
      121: 6203:    if (settings.inter)
        6: 6204:      free(settings.inter);
        -: 6205:
        -: 6206:    /* cleanup base */
      121: 6207:    event_base_free(main_base);
        -: 6208:
      121: 6209:    free(meta);
        -: 6210:
      121: 6211:    return retval;
        -: 6212:
        2: 6213:error:
        2: 6214:    if (subopts_orig)
        2: 6215:        free(subopts_orig);
        -: 6216:    return 1;
        -: 6217:}
