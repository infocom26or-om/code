        -:    0:Source:logger.c
        -:    0:Graph:logger.gcno
        -:    0:Data:logger.gcda
        -:    0:Runs:451
        -:    1:/* -*- Mode: C; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*- */
        -:    2:
        -:    3:#include <arpa/inet.h>
        -:    4:#include <stdlib.h>
        -:    5:#include <stdio.h>
        -:    6:#include <string.h>
        -:    7:#include <errno.h>
        -:    8:#include <poll.h>
        -:    9:#include <stdarg.h>
        -:   10:
        -:   11:#if defined(__sun)
        -:   12:#include <atomic.h>
        -:   13:#endif
        -:   14:
        -:   15:#include "memcached.h"
        -:   16:#include "bipbuffer.h"
        -:   17:
        -:   18:#ifdef LOGGER_DEBUG
        -:   19:#define L_DEBUG(...) \
        -:   20:    do { \
        -:   21:        fprintf(stderr, __VA_ARGS__); \
        -:   22:    } while (0)
        -:   23:#else
        -:   24:#define L_DEBUG(...)
        -:   25:#endif
        -:   26:
        -:   27:
        -:   28:/* TODO: put this in a struct and ditch the global vars. */
        -:   29:static logger *logger_stack_head = NULL;
        -:   30:static logger *logger_stack_tail = NULL;
        -:   31:static unsigned int logger_count = 0;
        -:   32:static volatile int do_run_logger_thread = 1;
        -:   33:static pthread_t logger_tid;
        -:   34:pthread_mutex_t logger_stack_lock = PTHREAD_MUTEX_INITIALIZER;
        -:   35:pthread_cond_t logger_stack_cond = PTHREAD_COND_INITIALIZER;
        -:   36:
        -:   37:pthread_key_t logger_key;
        -:   38:
        -:   39:#if !defined(HAVE_GCC_64ATOMICS) && !defined(__sun)
        -:   40:pthread_mutex_t logger_atomics_mutex = PTHREAD_MUTEX_INITIALIZER;
        -:   41:#endif
        -:   42:
        -:   43:#define WATCHER_LIMIT 20
        -:   44:logger_watcher *watchers[20];
        -:   45:struct pollfd watchers_pollfds[20];
        -:   46:int watcher_count = 0;
        -:   47:
        -:   48:#define WATCHER_ALL -1
        -:   49:static int logger_thread_poll_watchers(int force_poll, int watcher);
        -:   50:
        -:   51:/* helpers for logger_log */
        -:   52:
    #####:   53:static void _logger_log_text(logentry *e, const entry_details *d, const void *entry, va_list ap) {
    #####:   54:    int reqlen = d->reqlen;
    #####:   55:    int total = vsnprintf((char *) e->data, reqlen, d->format, ap);
    #####:   56:    if (total <= 0) {
    #####:   57:        fprintf(stderr, "LOGGER: Failed to vsnprintf a text entry: (total) %d\n", total);
        -:   58:    }
    #####:   59:    e->size = total + 1; // null byte
    #####:   60:}
        -:   61:
        1:   62:static void _logger_log_evictions(logentry *e, const entry_details *d, const void *entry, va_list ap) {
        1:   63:    item *it = (item *)entry;
        1:   64:    struct logentry_eviction *le = (struct logentry_eviction *) e->data;
        -:   65:
       1*:   66:    le->exptime = (it->exptime > 0) ? (long long int)(it->exptime - current_time) : (long long int) -1;
        1:   67:    le->latime = current_time - it->time;
        1:   68:    le->it_flags = it->it_flags;
        1:   69:    le->nkey = it->nkey;
        1:   70:    le->nbytes = it->nbytes;
        1:   71:    le->clsid = ITEM_clsid(it);
        1:   72:    memcpy(le->key, ITEM_key(it), it->nkey);
        1:   73:    e->size = sizeof(struct logentry_eviction) + le->nkey;
        1:   74:}
        -:   75:#ifdef EXTSTORE
    #####:   76:static void _logger_log_ext_write(logentry *e, const entry_details *d, const void *entry, va_list ap) {
    #####:   77:    item *it = (item *)entry;
    #####:   78:    int ew_bucket = va_arg(ap, int);
        -:   79:
    #####:   80:    struct logentry_ext_write *le = (struct logentry_ext_write *) e->data;
    #####:   81:    le->exptime = (it->exptime > 0) ? (long long int)(it->exptime - current_time) : (long long int) -1;
    #####:   82:    le->latime = current_time - it->time;
    #####:   83:    le->it_flags = it->it_flags;
    #####:   84:    le->nkey = it->nkey;
    #####:   85:    le->clsid = ITEM_clsid(it);
    #####:   86:    le->bucket = (uint8_t)ew_bucket;
    #####:   87:    memcpy(le->key, ITEM_key(it), it->nkey);
    #####:   88:    e->size = sizeof(struct logentry_ext_write) + le->nkey;
    #####:   89:}
        -:   90:#endif
        -:   91:// 0 == nf, 1 == found. 2 == flushed. 3 == expired.
        -:   92:// might be useful to store/print the flags an item has?
        -:   93:// could also collapse this and above code into an "item status" struct. wait
        -:   94:// for more endpoints to be written before making it generic, though.
    81103:   95:static void _logger_log_item_get(logentry *e, const entry_details *d, const void *entry, va_list ap) {
    81103:   96:    int was_found = va_arg(ap, int);
    81103:   97:    char *key = va_arg(ap, char *);
    81103:   98:    int nkey = va_arg(ap, int);
    81103:   99:    int nbytes = va_arg(ap, int);
    81103:  100:    uint8_t clsid = va_arg(ap, int);
    81103:  101:    int sfd = va_arg(ap, int);
        -:  102:
    81103:  103:    struct logentry_item_get *le = (struct logentry_item_get *) e->data;
    81103:  104:    le->was_found = was_found;
    81103:  105:    le->nkey = nkey;
    81103:  106:    le->nbytes = nbytes;
    81103:  107:    le->clsid = clsid;
    81103:  108:    memcpy(le->key, key, nkey);
    81103:  109:    le->sfd = sfd;
    81103:  110:    e->size = sizeof(struct logentry_item_get) + nkey;
    81103:  111:}
        -:  112:
        4:  113:static void _logger_log_item_store(logentry *e, const entry_details *d, const void *entry, va_list ap) {
        4:  114:    enum store_item_type status = va_arg(ap, enum store_item_type);
        4:  115:    int comm = va_arg(ap, int);
        4:  116:    char *key = va_arg(ap, char *);
        4:  117:    int nkey = va_arg(ap, int);
        4:  118:    int nbytes = va_arg(ap, int);
        4:  119:    rel_time_t ttl = va_arg(ap, rel_time_t);
        4:  120:    uint8_t clsid = va_arg(ap, int);
        4:  121:    int sfd = va_arg(ap, int);
        -:  122:
        4:  123:    struct logentry_item_store *le = (struct logentry_item_store *) e->data;
        4:  124:    le->status = status;
        4:  125:    le->cmd = comm;
        4:  126:    le->nkey = nkey;
        4:  127:    le->nbytes = nbytes;
        4:  128:    le->clsid = clsid;
        4:  129:    if (ttl != 0) {
    #####:  130:        le->ttl = ttl - current_time;
        -:  131:    } else {
        4:  132:        le->ttl = 0;
        -:  133:    }
        4:  134:    memcpy(le->key, key, nkey);
        4:  135:    le->sfd = sfd;
        4:  136:    e->size = sizeof(struct logentry_item_store) + nkey;
        4:  137:}
        -:  138:
        3:  139:static void _logger_log_item_deleted(logentry *e, const entry_details *d, const void *entry, va_list ap) {
        3:  140:    item *it = (item *)entry;
        3:  141:    int comm = va_arg(ap, int);
        3:  142:    struct logentry_deletion *le = (struct logentry_deletion *) e->data;
        3:  143:    le->nkey = it->nkey;
        3:  144:    le->cmd = comm;
        3:  145:    le->nbytes = it->nbytes;
        3:  146:    le->clsid = ITEM_clsid(it);
        3:  147:    memcpy(le->key, ITEM_key(it), it->nkey);
        3:  148:    e->size = sizeof(struct logentry_deletion) + le->nkey;
        3:  149:}
        -:  150:
        6:  151:static void _logger_log_conn_event(logentry *e, const entry_details *d, const void *entry, va_list ap) {
        6:  152:    struct sockaddr_in6 *addr = va_arg(ap, struct sockaddr_in6 *);
        6:  153:    socklen_t addrlen = va_arg(ap, socklen_t);
        6:  154:    enum network_transport transport = va_arg(ap, enum network_transport);
        6:  155:    enum close_reasons reason = va_arg(ap, enum close_reasons);
        6:  156:    int sfd = va_arg(ap, int);
        -:  157:
        6:  158:    struct logentry_conn_event *le = (struct logentry_conn_event *) e->data;
        -:  159:
        6:  160:    memcpy(&le->addr, addr, addrlen);
        6:  161:    le->sfd = sfd;
        6:  162:    le->transport = transport;
        6:  163:    le->reason = reason;
        6:  164:    e->size = sizeof(struct logentry_conn_event);
        6:  165:}
        -:  166:
        -:  167:/*************************
        -:  168: * Util functions used by the logger background thread
        -:  169: *************************/
        -:  170:
        5:  171:static int _logger_util_addr_endpoint(struct sockaddr_in6 *addr, char *rip,
        -:  172:        size_t riplen, unsigned short *rport) {
        5:  173:    memset(rip, 0, riplen);
        5:  174:    *rport = 0;
        -:  175:
        5:  176:    switch (addr->sin6_family) {
    #####:  177:        case AF_INET:
    #####:  178:            inet_ntop(AF_INET, &((struct sockaddr_in *) addr)->sin_addr,
        -:  179:                    rip, riplen - 1);
    #####:  180:            *rport = ntohs(((struct sockaddr_in *) addr)->sin_port);
    #####:  181:            break;
    #####:  182:        case AF_INET6:
    #####:  183:            inet_ntop(AF_INET6, &((struct sockaddr_in6 *) addr)->sin6_addr,
        -:  184:                    rip, riplen - 1);
    #####:  185:            *rport = ntohs(((struct sockaddr_in6 *) addr)->sin6_port);
    #####:  186:            break;
        -:  187:#ifndef DISABLE_UNIX_SOCKET
        -:  188:        // Connections on Unix socket transports have c->request_addr zeroed out.
        -:  189:        case AF_UNSPEC:
        -:  190:        case AF_UNIX:
        5:  191:            strncpy(rip, "unix", strlen("unix") + 1);
        5:  192:            break;
        -:  193:#endif // #ifndef DISABLE_UNIX_SOCKET
        -:  194:    }
        -:  195:
        5:  196:    return 0;
        -:  197:}
        -:  198:
        -:  199:/*************************
        -:  200: * Logger background thread functions. Aggregates per-worker buffers and
        -:  201: * writes to any watchers.
        -:  202: *************************/
        -:  203:
        -:  204:#define LOGGER_PARSE_SCRATCH 4096
        -:  205:
    #####:  206:static int _logger_parse_text(logentry *e, char *scratch) {
    #####:  207:    return snprintf(scratch, LOGGER_PARSE_SCRATCH, "ts=%lld.%d gid=%llu %s\n",
    #####:  208:            (long long int)e->tv.tv_sec, (int)e->tv.tv_usec,
    #####:  209:            (unsigned long long) e->gid, (char *) e->data);
        -:  210:}
        -:  211:
        4:  212:static int _logger_parse_ise(logentry *e, char *scratch) {
        4:  213:    int total;
        4:  214:    const char *cmd = "na";
        4:  215:    char keybuf[KEY_MAX_URI_ENCODED_LENGTH];
        4:  216:    struct logentry_item_store *le = (struct logentry_item_store *) e->data;
        4:  217:    const char * const status_map[] = {
        -:  218:        "not_stored", "stored", "exists", "not_found", "too_large", "no_memory" };
        4:  219:    const char * const cmd_map[] = {
        -:  220:        "null", "add", "set", "replace", "append", "prepend", "cas", "append", "prepend" };
        -:  221:
        4:  222:    if (le->cmd <= 8)
        4:  223:        cmd = cmd_map[le->cmd];
        -:  224:
        4:  225:    uriencode(le->key, keybuf, le->nkey, KEY_MAX_URI_ENCODED_LENGTH);
        4:  226:    total = snprintf(scratch, LOGGER_PARSE_SCRATCH,
        -:  227:            "ts=%lld.%d gid=%llu type=item_store key=%s status=%s cmd=%s ttl=%u clsid=%u cfd=%d size=%d\n",
        4:  228:            (long long int)e->tv.tv_sec, (int)e->tv.tv_usec, (unsigned long long) e->gid,
        4:  229:            keybuf, status_map[le->status], cmd, le->ttl, le->clsid, le->sfd,
        4:  230:            le->nbytes > 0 ? le->nbytes - 2 : 0); // CLRF
        4:  231:    return total;
        -:  232:}
        -:  233:
    81103:  234:static int _logger_parse_ige(logentry *e, char *scratch) {
    81103:  235:    int total;
    81103:  236:    struct logentry_item_get *le = (struct logentry_item_get *) e->data;
    81103:  237:    char keybuf[KEY_MAX_URI_ENCODED_LENGTH];
    81103:  238:    const char * const was_found_map[] = {
        -:  239:        "not_found", "found", "flushed", "expired" };
        -:  240:
    81103:  241:    uriencode(le->key, keybuf, le->nkey, KEY_MAX_URI_ENCODED_LENGTH);
        8:  242:    total = snprintf(scratch, LOGGER_PARSE_SCRATCH,
        -:  243:            "ts=%lld.%d gid=%llu type=item_get key=%s status=%s clsid=%u cfd=%d size=%d\n",
    81103:  244:            (long long int)e->tv.tv_sec, (int)e->tv.tv_usec, (unsigned long long) e->gid,
    81103:  245:            keybuf, was_found_map[le->was_found], le->clsid, le->sfd,
    81103:  246:            le->nbytes > 0 ? le->nbytes - 2 : 0); // CLRF
    81103:  247:    return total;
        -:  248:}
        -:  249:
        1:  250:static int _logger_parse_ee(logentry *e, char *scratch) {
        1:  251:    int total;
        1:  252:    char keybuf[KEY_MAX_URI_ENCODED_LENGTH];
        1:  253:    struct logentry_eviction *le = (struct logentry_eviction *) e->data;
        1:  254:    uriencode(le->key, keybuf, le->nkey, KEY_MAX_URI_ENCODED_LENGTH);
        1:  255:    total = snprintf(scratch, LOGGER_PARSE_SCRATCH,
        -:  256:            "ts=%lld.%d gid=%llu type=eviction key=%s fetch=%s ttl=%lld la=%d clsid=%u size=%d\n",
        1:  257:            (long long int)e->tv.tv_sec, (int)e->tv.tv_usec, (unsigned long long) e->gid,
        1:  258:            keybuf, (le->it_flags & ITEM_FETCHED) ? "yes" : "no",
        1:  259:            (long long int)le->exptime, le->latime, le->clsid,
        1:  260:            le->nbytes > 0 ? le->nbytes - 2 : 0); // CLRF
        -:  261:
        1:  262:    return total;
        -:  263:}
        -:  264:
        3:  265:static int _logger_parse_ide(logentry *e, char *scratch) {
        3:  266:    int total;
        3:  267:    const char *cmd = "na";
        3:  268:    const char * const cmd_map[] = {
        -:  269:            "null", "delete", "md" };
        3:  270:    char keybuf[KEY_MAX_URI_ENCODED_LENGTH];
        3:  271:    struct logentry_deletion *le = (struct logentry_deletion *) e->data;
        3:  272:    uriencode(le->key, keybuf, le->nkey, KEY_MAX_URI_ENCODED_LENGTH);
        -:  273:
        3:  274:    if (le->cmd <= 2)
        3:  275:        cmd = cmd_map[le->cmd];
        -:  276:
        3:  277:    total = snprintf(scratch, LOGGER_PARSE_SCRATCH,
        -:  278:                     "ts=%d.%d gid=%llu type=deleted key=%s cmd=%s clsid=%u size=%d\n",
        3:  279:                     (int)e->tv.tv_sec, (int)e->tv.tv_usec, (unsigned long long) e->gid,
        3:  280:                     keybuf, cmd, le->clsid,
        3:  281:                     le->nbytes > 0 ? le->nbytes - 2 : 0); // CLRF
        3:  282:    return total;
        -:  283:}
        -:  284:
        -:  285:#ifdef EXTSTORE
    #####:  286:static int _logger_parse_extw(logentry *e, char *scratch) {
    #####:  287:    int total;
    #####:  288:    char keybuf[KEY_MAX_URI_ENCODED_LENGTH];
    #####:  289:    struct logentry_ext_write *le = (struct logentry_ext_write *) e->data;
    #####:  290:    uriencode(le->key, keybuf, le->nkey, KEY_MAX_URI_ENCODED_LENGTH);
    #####:  291:    total = snprintf(scratch, LOGGER_PARSE_SCRATCH,
        -:  292:            "ts=%lld.%d gid=%llu type=extwrite key=%s fetch=%s ttl=%lld la=%d clsid=%u bucket=%u\n",
    #####:  293:            (long long int)e->tv.tv_sec, (int)e->tv.tv_usec, (unsigned long long) e->gid,
    #####:  294:            keybuf, (le->it_flags & ITEM_FETCHED) ? "yes" : "no",
    #####:  295:            (long long int)le->exptime, le->latime, le->clsid, le->bucket);
        -:  296:
    #####:  297:    return total;
        -:  298:}
        -:  299:#endif
        -:  300:
        2:  301:static int _logger_parse_cne(logentry *e, char *scratch) {
        2:  302:    int total;
        2:  303:    unsigned short rport = 0;
        2:  304:    char rip[64];
        2:  305:    struct logentry_conn_event *le = (struct logentry_conn_event *) e->data;
        2:  306:    const char * const transport_map[] = { "local", "tcp", "udp" };
        -:  307:
        2:  308:    _logger_util_addr_endpoint(&le->addr, rip, sizeof(rip), &rport);
        -:  309:
        2:  310:    total = snprintf(scratch, LOGGER_PARSE_SCRATCH,
        -:  311:            "ts=%lld.%d gid=%llu type=conn_new rip=%s rport=%hu transport=%s cfd=%d\n",
        2:  312:            (long long int) e->tv.tv_sec, (int) e->tv.tv_usec, (unsigned long long) e->gid,
        2:  313:            rip, rport, transport_map[le->transport], le->sfd);
        -:  314:
        2:  315:    return total;
        -:  316:}
        -:  317:
        3:  318:static int _logger_parse_cce(logentry *e, char *scratch) {
        3:  319:    int total;
        3:  320:    unsigned short rport = 0;
        3:  321:    char rip[64];
        3:  322:    struct logentry_conn_event *le = (struct logentry_conn_event *) e->data;
        3:  323:    const char * const transport_map[] = { "local", "tcp", "udp" };
        3:  324:    const char * const reason_map[] = { "error", "normal", "idle_timeout", "shutdown" };
        -:  325:
        3:  326:    _logger_util_addr_endpoint(&le->addr, rip, sizeof(rip), &rport);
        -:  327:
        3:  328:    total = snprintf(scratch, LOGGER_PARSE_SCRATCH,
        -:  329:            "ts=%lld.%d gid=%llu type=conn_close rip=%s rport=%hu transport=%s reason=%s cfd=%d\n",
        3:  330:            (long long int) e->tv.tv_sec, (int) e->tv.tv_usec, (unsigned long long) e->gid,
        3:  331:            rip, rport, transport_map[le->transport],
        3:  332:            reason_map[le->reason], le->sfd);
        -:  333:
        3:  334:    return total;
        -:  335:}
        -:  336:
        -:  337:#ifdef PROXY
        -:  338:// TODO (v2): the length caps here are all magic numbers. Haven't thought of
        -:  339:// something yet that I like better.
        -:  340:// Should at least make a define to the max log len (1024) and do some math
        -:  341:// here.
        -:  342:static void _logger_log_proxy_req(logentry *e, const entry_details *d, const void *entry, va_list ap) {
        -:  343:    char *req = va_arg(ap, char *);
        -:  344:    int reqlen = va_arg(ap, uint32_t);
        -:  345:    long elapsed = va_arg(ap, long);
        -:  346:    unsigned short type = va_arg(ap, int);
        -:  347:    unsigned short code = va_arg(ap, int);
        -:  348:    int status = va_arg(ap, int);
        -:  349:    int flag = va_arg(ap, int);
        -:  350:    int conn_fd = va_arg(ap, int);
        -:  351:    char *detail = va_arg(ap, char *);
        -:  352:    int dlen = va_arg(ap, int);
        -:  353:    char *be_name = va_arg(ap, char *);
        -:  354:    char *be_port = va_arg(ap, char *);
        -:  355:
        -:  356:    struct logentry_proxy_req *le = (void *)e->data;
        -:  357:    le->type = type;
        -:  358:    le->code = code;
        -:  359:    le->status = status;
        -:  360:    le->flag = flag;
        -:  361:    le->conn_fd = conn_fd;
        -:  362:    le->dlen = dlen;
        -:  363:    le->elapsed = elapsed;
        -:  364:    if (be_name && be_port) {
        -:  365:        le->be_namelen = strlen(be_name);
        -:  366:        le->be_portlen = strlen(be_port);
        -:  367:    } else {
        -:  368:        le->be_namelen = 0;
        -:  369:        le->be_portlen = 0;
        -:  370:    }
        -:  371:    char *data = le->data;
        -:  372:    if (req[reqlen-2] == '\r') {
        -:  373:        reqlen -= 2;
        -:  374:    } else {
        -:  375:        reqlen--;
        -:  376:    }
        -:  377:    if (reqlen > 300) {
        -:  378:        reqlen = 300;
        -:  379:    }
        -:  380:    if (dlen > 150) {
        -:  381:        dlen = 150;
        -:  382:    }
        -:  383:    // be_namelen and be_portlen can't be longer than 255+6
        -:  384:    le->reqlen = reqlen;
        -:  385:    memcpy(data, req, reqlen);
        -:  386:    data += reqlen;
        -:  387:    memcpy(data, detail, dlen);
        -:  388:    data += dlen;
        -:  389:    memcpy(data, be_name, le->be_namelen);
        -:  390:    data += le->be_namelen;
        -:  391:    memcpy(data, be_port, le->be_portlen);
        -:  392:    e->size = sizeof(struct logentry_proxy_req) + reqlen + dlen + le->be_namelen + le->be_portlen;
        -:  393:}
        -:  394:
        -:  395:// FIXME: if I ever get better discipline around headers we can include the
        -:  396:// proxy header. Since proxy.h includes memcached.h we need to redefine things
        -:  397:// here.
        -:  398:#define RQUEUE_R_GOOD (1<<3)
        -:  399:#define RQUEUE_R_OK (1<<4)
        -:  400:#define RQUEUE_R_ANY (1<<5)
        -:  401:static int _logger_parse_prx_req(logentry *e, char *scratch) {
        -:  402:    int total;
        -:  403:    struct logentry_proxy_req *le = (void *)e->data;
        -:  404:    const char *rqu_res = "any";
        -:  405:    if (le->flag == RQUEUE_R_GOOD) {
        -:  406:        rqu_res = "good";
        -:  407:    } else if (le->flag == RQUEUE_R_OK) {
        -:  408:        rqu_res = "ok";
        -:  409:    }
        -:  410:
        -:  411:    total = snprintf(scratch, LOGGER_PARSE_SCRATCH,
        -:  412:            "ts=%lld.%d gid=%llu type=proxy_req elapsed=%lu type=%d code=%d status=%d res=%s cfd=%d be=%.*s:%.*s detail=%.*s req=%.*s\n",
        -:  413:            (long long int) e->tv.tv_sec, (int) e->tv.tv_usec, (unsigned long long) e->gid,
        -:  414:            le->elapsed, le->type, le->code, le->status, rqu_res, le->conn_fd,
        -:  415:            (int)le->be_namelen, le->data+le->reqlen+le->dlen,
        -:  416:            (int)le->be_portlen, le->data+le->reqlen+le->dlen+le->be_namelen, // fml.
        -:  417:            (int)le->dlen, le->data+le->reqlen, (int)le->reqlen, le->data
        -:  418:            );
        -:  419:    return total;
        -:  420:}
        -:  421:
        -:  422:#define MAX_RBUF_READ 100
        -:  423:static void _logger_log_proxy_errbe(logentry *e, const entry_details *d, const void *entry, va_list ap) {
        -:  424:    char *errmsg = va_arg(ap, char *);
        -:  425:    char *be_name = va_arg(ap, char *);
        -:  426:    char *be_port = va_arg(ap, char *);
        -:  427:    char *be_label = va_arg(ap, char *);
        -:  428:    int be_depth = va_arg(ap, int);
        -:  429:    char *be_rbuf = va_arg(ap, char *);
        -:  430:    int be_rbuflen = va_arg(ap, int);
        -:  431:    int be_retry = va_arg(ap, int);
        -:  432:
        -:  433:    struct logentry_proxy_errbe *le = (void *)e->data;
        -:  434:    le->be_depth = be_depth;
        -:  435:    le->retry = be_retry;
        -:  436:    le->errlen = strlen(errmsg);
        -:  437:    if (be_name && be_port) {
        -:  438:        le->be_namelen = strlen(be_name);
        -:  439:        le->be_portlen = strlen(be_port);
        -:  440:    }
        -:  441:
        -:  442:    if (be_label) {
        -:  443:        le->be_labellen = strlen(be_label);
        -:  444:    }
        -:  445:
        -:  446:    le->be_rbuflen = be_rbuflen;
        -:  447:    if (be_rbuflen > MAX_RBUF_READ) {
        -:  448:        le->be_rbuflen = MAX_RBUF_READ;
        -:  449:    }
        -:  450:
        -:  451:    char *data = le->data;
        -:  452:    memcpy(data, errmsg, le->errlen);
        -:  453:    data += le->errlen;
        -:  454:    memcpy(data, be_name, le->be_namelen);
        -:  455:    data += le->be_namelen;
        -:  456:    memcpy(data, be_port, le->be_portlen);
        -:  457:    data += le->be_portlen;
        -:  458:    memcpy(data, be_label, le->be_labellen);
        -:  459:    data += le->be_labellen;
        -:  460:    memcpy(data, be_rbuf, le->be_rbuflen);
        -:  461:    data += le->be_rbuflen;
        -:  462:
        -:  463:    e->size = sizeof(struct logentry_proxy_errbe) + (data - le->data);
        -:  464:}
        -:  465:
        -:  466:static int _logger_parse_prx_errbe(logentry *e, char *scratch) {
        -:  467:    int total;
        -:  468:    char rbuf[MAX_RBUF_READ * 3]; // x 3 for worst case URI encoding.
        -:  469:    struct logentry_proxy_errbe *le = (void *)e->data;
        -:  470:    char *data = le->data;
        -:  471:    char *errmsg = data;
        -:  472:    data += le->errlen;
        -:  473:    char *be_name = data;
        -:  474:    data += le->be_namelen;
        -:  475:    char *be_port = data;
        -:  476:    data += le->be_portlen;
        -:  477:    char *be_label = data;
        -:  478:    data += le->be_labellen;
        -:  479:    char *be_rbuf = data;
        -:  480:
        -:  481:    uriencode(be_rbuf, rbuf, le->be_rbuflen, MAX_RBUF_READ * 3);
        -:  482:    if (le->retry) {
        -:  483:        total = snprintf(scratch, LOGGER_PARSE_SCRATCH,
        -:  484:                "ts=%lld.%d gid=%llu type=proxy_backend error=%.*s name=%.*s port=%.*s label=%.*s retry=%d\n",
        -:  485:                (long long int)e->tv.tv_sec, (int)e->tv.tv_usec, (unsigned long long) e->gid,
        -:  486:                (int)le->errlen, errmsg, (int)le->be_namelen, be_name,
        -:  487:                (int)le->be_portlen, be_port, (int)le->be_labellen, be_label, le->retry);
        -:  488:    } else {
        -:  489:        total = snprintf(scratch, LOGGER_PARSE_SCRATCH,
        -:  490:                "ts=%lld.%d gid=%llu type=proxy_backend error=%.*s name=%.*s port=%.*s label=%.*s depth=%d rbuf=%s\n",
        -:  491:                (long long int)e->tv.tv_sec, (int)e->tv.tv_usec, (unsigned long long) e->gid,
        -:  492:                (int)le->errlen, errmsg, (int)le->be_namelen, be_name,
        -:  493:                (int)le->be_portlen, be_port, (int)le->be_labellen, be_label, le->be_depth, rbuf);
        -:  494:    }
        -:  495:
        -:  496:    return total;
        -:  497:}
        -:  498:#endif
        -:  499:
        -:  500:/* Should this go somewhere else? */
        -:  501:static const entry_details default_entries[] = {
        -:  502:    [LOGGER_ASCII_CMD] = {512, LOG_RAWCMDS, _logger_log_text, _logger_parse_text, "<%d %s"},
        -:  503:    [LOGGER_EVICTION] = {512, LOG_EVICTIONS, _logger_log_evictions, _logger_parse_ee, NULL},
        -:  504:    [LOGGER_ITEM_GET] = {512, LOG_FETCHERS, _logger_log_item_get, _logger_parse_ige, NULL},
        -:  505:    [LOGGER_ITEM_STORE] = {512, LOG_MUTATIONS, _logger_log_item_store, _logger_parse_ise, NULL},
        -:  506:    [LOGGER_CRAWLER_STATUS] = {512, LOG_SYSEVENTS, _logger_log_text, _logger_parse_text,
        -:  507:        "type=lru_crawler crawler=%d lru=%s low_mark=%llu next_reclaims=%llu since_run=%u next_run=%d elapsed=%u examined=%llu reclaimed=%llu"
        -:  508:    },
        -:  509:    [LOGGER_SLAB_MOVE] = {512, LOG_SYSEVENTS, _logger_log_text, _logger_parse_text,
        -:  510:        "type=slab_move src=%d dst=%d state=%s"
        -:  511:    },
        -:  512:    [LOGGER_CONNECTION_NEW] = {512, LOG_CONNEVENTS, _logger_log_conn_event, _logger_parse_cne, NULL},
        -:  513:    [LOGGER_CONNECTION_CLOSE] = {512, LOG_CONNEVENTS, _logger_log_conn_event, _logger_parse_cce, NULL},
        -:  514:    [LOGGER_CONNECTION_ERROR] = {512, LOG_CONNEVENTS, _logger_log_text, _logger_parse_text,
        -:  515:        "type=connerr fd=%d msg=%s"
        -:  516:    },
        -:  517:    [LOGGER_CONNECTION_TLSERROR] = {512, LOG_CONNEVENTS, _logger_log_text, _logger_parse_text,
        -:  518:        "type=conntlserr fd=%d msg=%s"
        -:  519:    },
        -:  520:    [LOGGER_DELETIONS] = {512, LOG_DELETIONS, _logger_log_item_deleted, _logger_parse_ide, NULL},
        -:  521:#ifdef EXTSTORE
        -:  522:    [LOGGER_EXTSTORE_WRITE] = {512, LOG_EVICTIONS, _logger_log_ext_write, _logger_parse_extw, NULL},
        -:  523:    [LOGGER_COMPACT_START] = {512, LOG_SYSEVENTS, _logger_log_text, _logger_parse_text,
        -:  524:        "type=compact_start id=%lu version=%llu"
        -:  525:    },
        -:  526:    [LOGGER_COMPACT_ABORT] = {512, LOG_SYSEVENTS, _logger_log_text, _logger_parse_text,
        -:  527:        "type=compact_abort id=%lu"
        -:  528:    },
        -:  529:    [LOGGER_COMPACT_READ_START] = {512, LOG_SYSEVENTS, _logger_log_text, _logger_parse_text,
        -:  530:        "type=compact_read_start id=%lu offset=%llu"
        -:  531:    },
        -:  532:    [LOGGER_COMPACT_READ_END] = {512, LOG_SYSEVENTS, _logger_log_text, _logger_parse_text,
        -:  533:        "type=compact_read_end id=%lu offset=%llu rescues=%lu lost=%lu skipped=%lu"
        -:  534:    },
        -:  535:    [LOGGER_COMPACT_END] = {512, LOG_SYSEVENTS, _logger_log_text, _logger_parse_text,
        -:  536:        "type=compact_end id=%lu"
        -:  537:    },
        -:  538:    [LOGGER_COMPACT_FRAGINFO] = {512, LOG_SYSEVENTS, _logger_log_text, _logger_parse_text,
        -:  539:        "type=compact_fraginfo ratio=%.2f bytes=%lu"
        -:  540:    },
        -:  541:#endif
        -:  542:#ifdef PROXY
        -:  543:    [LOGGER_PROXY_CONFIG] = {512, LOG_PROXYEVENTS, _logger_log_text, _logger_parse_text,
        -:  544:        "type=proxy_conf status=%s"
        -:  545:    },
        -:  546:    [LOGGER_PROXY_REQ] = {1024, LOG_PROXYREQS, _logger_log_proxy_req, _logger_parse_prx_req, NULL},
        -:  547:    [LOGGER_PROXY_ERROR] = {512, LOG_PROXYEVENTS, _logger_log_text, _logger_parse_text,
        -:  548:        "type=proxy_error msg=%s"
        -:  549:    },
        -:  550:    [LOGGER_PROXY_USER] = {512, LOG_PROXYUSER, _logger_log_text, _logger_parse_text,
        -:  551:        "type=proxy_user msg=%s"
        -:  552:    },
        -:  553:    [LOGGER_PROXY_BE_ERROR] = {512, LOG_PROXYEVENTS, _logger_log_proxy_errbe, _logger_parse_prx_errbe,
        -:  554:        NULL
        -:  555:    },
        -:  556:
        -:  557:#endif
        -:  558:};
        -:  559:
        -:  560:/*************************
        -:  561: * Util functions shared between bg thread and workers
        -:  562: *************************/
        -:  563:
        -:  564:/* Logger GID's can be used by watchers to put logs back into strict order
        -:  565: */
        -:  566:static uint64_t logger_gid = 0;
    81129:  567:uint64_t logger_get_gid(void) {
        -:  568:#ifdef HAVE_GCC_64ATOMICS
    81129:  569:    return __sync_add_and_fetch(&logger_gid, 1);
        -:  570:#elif defined(__sun)
        -:  571:    return atomic_inc_64_nv(&logger_gid);
        -:  572:#else
        -:  573:    mutex_lock(&logger_atomics_mutex);
        -:  574:    uint64_t res = ++logger_gid;
        -:  575:    mutex_unlock(&logger_atomics_mutex);
        -:  576:    return res;
        -:  577:#endif
        -:  578:}
        -:  579:
        1:  580:void logger_set_gid(uint64_t gid) {
        -:  581:#ifdef HAVE_GCC_64ATOMICS
        1:  582:    __sync_add_and_fetch(&logger_gid, gid);
        -:  583:#elif defined(__sun)
        -:  584:    atomic_add_64(&logger_gid);
        -:  585:#else
        -:  586:    mutex_lock(&logger_atomics_mutex);
        -:  587:    logger_gid = gid;
        -:  588:    mutex_unlock(&logger_atomics_mutex);
        -:  589:#endif
        1:  590:}
        -:  591:
        -:  592:/* TODO: genericize lists. would be nice to import queue.h if the impact is
        -:  593: * studied... otherwise can just write a local one.
        -:  594: */
        -:  595:/* Add to the list of threads with a logger object */
      892:  596:static void logger_link_q(logger *l) {
      892:  597:    pthread_mutex_lock(&logger_stack_lock);
     892*:  598:    assert(l != logger_stack_head);
        -:  599:
      892:  600:    l->prev = 0;
      892:  601:    l->next = logger_stack_head;
      892:  602:    if (l->next) l->next->prev = l;
      892:  603:    logger_stack_head = l;
      892:  604:    if (logger_stack_tail == 0) logger_stack_tail = l;
      892:  605:    logger_count++;
      892:  606:    pthread_mutex_unlock(&logger_stack_lock);
      892:  607:    return;
        -:  608:}
        -:  609:
        -:  610:/* Remove from the list of threads with a logger object */
        -:  611:/*static void logger_unlink_q(logger *l) {
        -:  612:    pthread_mutex_lock(&logger_stack_lock);
        -:  613:    if (logger_stack_head == l) {
        -:  614:        assert(l->prev == 0);
        -:  615:        logger_stack_head = l->next;
        -:  616:    }
        -:  617:    if (logger_stack_tail == l) {
        -:  618:        assert(l->next == 0);
        -:  619:        logger_stack_tail = l->prev;
        -:  620:    }
        -:  621:    assert(l->next != l);
        -:  622:    assert(l->prev != l);
        -:  623:
        -:  624:    if (l->next) l->next->prev = l->prev;
        -:  625:    if (l->prev) l->prev->next = l->next;
        -:  626:    logger_count--;
        -:  627:    pthread_mutex_unlock(&logger_stack_lock);
        -:  628:    return;
        -:  629:}*/
        -:  630:
        -:  631:/* Called with logger stack locked.
        -:  632: * Iterates over every watcher collecting enabled flags.
        -:  633: */
       22:  634:static void logger_set_flags(void) {
       22:  635:    logger *l = NULL;
       22:  636:    int x = 0;
       22:  637:    uint16_t f = 0; /* logger eflags */
        -:  638:
      462:  639:    for (x = 0; x < WATCHER_LIMIT; x++) {
      440:  640:        logger_watcher *w = watchers[x];
      440:  641:        if (w == NULL)
      411:  642:            continue;
        -:  643:
       29:  644:        f |= w->eflags;
        -:  645:    }
      176:  646:    for (l = logger_stack_head; l != NULL; l=l->next) {
      154:  647:        pthread_mutex_lock(&l->mutex);
      154:  648:        l->eflags = f;
      154:  649:        pthread_mutex_unlock(&l->mutex);
        -:  650:    }
       22:  651:    return;
        -:  652:}
        -:  653:
        -:  654:/* Completes rendering of log line. */
    81116:  655:static enum logger_parse_entry_ret logger_thread_parse_entry(logentry *e, struct logger_stats *ls,
        -:  656:        char *scratch, int *scratch_len) {
    81116:  657:    int total = 0;
    81116:  658:    const entry_details *d = &default_entries[e->event];
   81116*:  659:    assert(d->parse_cb != NULL);
    81116:  660:    total = d->parse_cb(e, scratch);
        -:  661:
    81116:  662:    if (total >= LOGGER_PARSE_SCRATCH || total <= 0) {
        -:  663:        L_DEBUG("LOGGER: Failed to flatten log entry!\n");
        -:  664:        return LOGGER_PARSE_ENTRY_FAILED;
        -:  665:    } else {
    81116:  666:        *scratch_len = total;
        -:  667:    }
        -:  668:
    81116:  669:    return LOGGER_PARSE_ENTRY_OK;
        -:  670:}
        -:  671:
        -:  672:/* Writes flattened entry to available watchers */
    81116:  673:static void logger_thread_write_entry(logentry *e, struct logger_stats *ls,
        -:  674:        char *scratch, int scratch_len) {
    81116:  675:    int x, total;
        -:  676:    /* Write the line into available watchers with matching flags */
  1703436:  677:    for (x = 0; x < WATCHER_LIMIT; x++) {
  1622320:  678:        logger_watcher *w = watchers[x];
  1622320:  679:        char *skip_scr = NULL;
  1622320:  680:        if (w == NULL || (e->eflags & w->eflags) == 0 || (e->gid < w->min_gid))
  1541201:  681:            continue;
        -:  682:
        -:  683:         /* Avoid poll()'ing constantly when buffer is full by resetting a
        -:  684:         * flag periodically.
        -:  685:         */
    84289:  686:        while (!w->failed_flush &&
     3946:  687:                (skip_scr = (char *) bipbuf_request(w->buf, scratch_len + 128)) == NULL) {
     3170:  688:            if (logger_thread_poll_watchers(0, x) <= 0) {
     3159:  689:                L_DEBUG("LOGGER: Watcher had no free space for line of size (%d)\n", scratch_len + 128);
     3159:  690:                w->failed_flush = true;
        -:  691:            }
        -:  692:        }
        -:  693:
    81119:  694:        if (w->failed_flush) {
    80343:  695:            L_DEBUG("LOGGER: Fast skipped for watcher [%d] due to failed_flush\n", w->sfd);
    80343:  696:            w->skipped++;
    80343:  697:            ls->watcher_skipped++;
    80343:  698:            continue;
        -:  699:        }
        -:  700:
      776:  701:        if (w->skipped > 0) {
        1:  702:            total = snprintf(skip_scr, 128, "skipped=%llu\n", (unsigned long long) w->skipped);
       1*:  703:            if (total >= 128 || total <= 0) {
    #####:  704:                L_DEBUG("LOGGER: Failed to flatten skipped message into watcher [%d]\n", w->sfd);
    #####:  705:                w->skipped++;
    #####:  706:                ls->watcher_skipped++;
    #####:  707:                continue;
        -:  708:            }
        1:  709:            bipbuf_push(w->buf, total);
        1:  710:            w->skipped = 0;
        -:  711:        }
        -:  712:        /* Can't fail because bipbuf_request succeeded. */
      776:  713:        bipbuf_offer(w->buf, (unsigned char *) scratch, scratch_len);
      776:  714:        ls->watcher_sent++;
        -:  715:    }
    81116:  716:}
        -:  717:
        -:  718:/* Called with logger stack locked.
        -:  719: * Releases every chunk associated with a watcher and closes the connection.
        -:  720: * We can't presently send a connection back to the worker for further
        -:  721: * processing.
        -:  722: */
       11:  723:static void logger_thread_close_watcher(logger_watcher *w) {
       11:  724:    L_DEBUG("LOGGER: Closing dead watcher\n");
       11:  725:    watchers[w->id] = NULL;
       11:  726:    sidethread_conn_close(w->c);
       11:  727:    watcher_count--;
       11:  728:    bipbuf_free(w->buf);
       11:  729:    free(w);
       11:  730:    logger_set_flags();
       11:  731:}
        -:  732:
        -:  733:/* Reads a particular worker thread's available bipbuf bytes. Parses each log
        -:  734: * entry into the watcher buffers.
        -:  735: */
    29890:  736:static int logger_thread_read(logger *l, struct logger_stats *ls) {
    29890:  737:    unsigned int size;
    29890:  738:    unsigned int pos = 0;
    29890:  739:    unsigned char *data;
    29890:  740:    char scratch[LOGGER_PARSE_SCRATCH];
    29890:  741:    logentry *e;
    29890:  742:    pthread_mutex_lock(&l->mutex);
    29890:  743:    data = bipbuf_peek_all(l->buf, &size);
    29890:  744:    pthread_mutex_unlock(&l->mutex);
        -:  745:
    29890:  746:    if (data == NULL) {
        -:  747:        return 0;
        -:  748:    }
        -:  749:    L_DEBUG("LOGGER: Got %d bytes from bipbuffer\n", size);
        -:  750:
        -:  751:    /* parse buffer */
    84292:  752:    while (pos < size && watcher_count > 0) {
    81116:  753:        enum logger_parse_entry_ret ret;
    81116:  754:        int scratch_len = 0;
    81116:  755:        e = (logentry *) (data + pos);
    81116:  756:        ret = logger_thread_parse_entry(e, ls, scratch, &scratch_len);
    81116:  757:        if (ret != LOGGER_PARSE_ENTRY_OK) {
        -:  758:            /* TODO: stats counter */
    #####:  759:            fprintf(stderr, "LOGGER: Failed to parse log entry\n");
        -:  760:        } else {
    81116:  761:            logger_thread_write_entry(e, ls, scratch, scratch_len);
        -:  762:        }
    81116:  763:        pos += sizeof(logentry) + e->size + e->pad;
        -:  764:    }
    3176*:  765:    assert(pos <= size);
        -:  766:
     3176:  767:    pthread_mutex_lock(&l->mutex);
     3176:  768:    data = bipbuf_poll(l->buf, size);
     3176:  769:    ls->worker_written += l->written;
     3176:  770:    ls->worker_dropped += l->dropped;
     3176:  771:    l->written = 0;
     3176:  772:    l->dropped = 0;
     3176:  773:    pthread_mutex_unlock(&l->mutex);
     3176:  774:    if (data == NULL) {
    #####:  775:        fprintf(stderr, "LOGGER: unexpectedly couldn't advance buf pointer\n");
    #####:  776:        assert(0);
        -:  777:    }
     3176:  778:    return size; /* maybe the count of objects iterated? */
        -:  779:}
        -:  780:
        -:  781:/* Since the event loop code isn't reusable without a refactor, and we have a
        -:  782: * limited number of potential watchers, we run our own poll loop.
        -:  783: * This calls poll() unnecessarily during write flushes, should be possible to
        -:  784: * micro-optimize later.
        -:  785: *
        -:  786: * This flushes buffers attached to watchers, iterating through the bytes set
        -:  787: * to each worker. Also checks for readability in case client connection was
        -:  788: * closed.
        -:  789: *
        -:  790: * Allows a specific watcher to be flushed (if buf full)
        -:  791: */
     7440:  792:static int logger_thread_poll_watchers(int force_poll, int watcher) {
     7440:  793:    int x;
     7440:  794:    int nfd = 0;
     7440:  795:    unsigned char *data;
     7440:  796:    unsigned int data_size = 0;
     7440:  797:    int flushed = 0;
        -:  798:
   156240:  799:    for (x = 0; x < WATCHER_LIMIT; x++) {
   148800:  800:        logger_watcher *w = watchers[x];
   148800:  801:        if (w == NULL || (watcher != WATCHER_ALL && x != watcher))
   141323:  802:            continue;
        -:  803:
     7477:  804:        data = bipbuf_peek_all(w->buf, &data_size);
     7477:  805:        if (data != NULL) {
     7375:  806:            watchers_pollfds[nfd].fd = w->sfd;
     7375:  807:            watchers_pollfds[nfd].events = POLLOUT;
     7375:  808:            nfd++;
      102:  809:        } else if (force_poll) {
      102:  810:            watchers_pollfds[nfd].fd = w->sfd;
      102:  811:            watchers_pollfds[nfd].events = POLLIN;
      102:  812:            nfd++;
        -:  813:        }
        -:  814:        /* This gets set after a call to poll, and should be used to gate on
        -:  815:         * calling poll again.
        -:  816:         */
     7477:  817:        w->failed_flush = false;
        -:  818:    }
        -:  819:
     7440:  820:    if (nfd == 0)
        -:  821:        return 0;
        -:  822:
        -:  823:    //L_DEBUG("LOGGER: calling poll() [data_size: %d]\n", data_size);
     7438:  824:    int ret = poll(watchers_pollfds, nfd, 0);
        -:  825:
     7438:  826:    if (ret < 0) {
    #####:  827:        perror("something failed with logger thread watcher fd polling");
    #####:  828:        return -1;
        -:  829:    }
        -:  830:
        -:  831:    nfd = 0;
   156198:  832:    for (x = 0; x < WATCHER_LIMIT; x++) {
   148760:  833:        logger_watcher *w = watchers[x];
   148760:  834:        if (w == NULL || (watcher != WATCHER_ALL && x != watcher))
   141283:  835:            continue;
        -:  836:
     7477:  837:        data_size = 0;
        -:  838:        /* Early detection of a disconnect. Otherwise we have to wait until
        -:  839:         * the next write
        -:  840:         */
     7477:  841:        if (watchers_pollfds[nfd].revents & POLLIN) {
        9:  842:            char buf[1];
        9:  843:            int res = ((conn*)w->c)->read(w->c, buf, 1);
        9:  844:            if (res == 0 || (res == -1 && (errno != EAGAIN && errno != EWOULDBLOCK))) {
        9:  845:                L_DEBUG("LOGGER: watcher closed remotely\n");
        9:  846:                logger_thread_close_watcher(w);
        9:  847:                nfd++;
        9:  848:                continue;
        -:  849:            }
        -:  850:        }
     7468:  851:        if ((data = bipbuf_peek_all(w->buf, &data_size)) != NULL) {
     7375:  852:            if (watchers_pollfds[nfd].revents & (POLLHUP|POLLERR)) {
        2:  853:                L_DEBUG("LOGGER: watcher closed during poll() call\n");
        2:  854:                logger_thread_close_watcher(w);
     7373:  855:            } else if (watchers_pollfds[nfd].revents & POLLOUT) {
       42:  856:                int total = 0;
        -:  857:
        -:  858:                /* We can write a bit. */
       42:  859:                switch (w->t) {
    #####:  860:                    case LOGGER_WATCHER_STDERR:
    #####:  861:                        total = fwrite(data, 1, data_size, stderr);
    #####:  862:                        break;
       42:  863:                    case LOGGER_WATCHER_CLIENT:
       42:  864:                        total = ((conn*)w->c)->write(w->c, data, data_size);
       42:  865:                        break;
        -:  866:                }
        -:  867:
        -:  868:                L_DEBUG("LOGGER: poll() wrote %d to %d (data_size: %d) (bipbuf_used: %d)\n", total, w->sfd,
       42:  869:                        data_size, bipbuf_used(w->buf));
       42:  870:                if (total == -1) {
    #####:  871:                    if (errno != EAGAIN && errno != EWOULDBLOCK) {
    #####:  872:                        logger_thread_close_watcher(w);
        -:  873:                    }
        -:  874:                    L_DEBUG("LOGGER: watcher hit EAGAIN\n");
       42:  875:                } else if (total == 0) {
    #####:  876:                    logger_thread_close_watcher(w);
        -:  877:                } else {
       42:  878:                    bipbuf_poll(w->buf, total);
       42:  879:                    flushed += total;
        -:  880:                }
        -:  881:            }
        -:  882:        }
     7468:  883:        nfd++;
        -:  884:    }
        -:  885:    return flushed;
        -:  886:}
        -:  887:
     4270:  888:static void logger_thread_flush_stats(struct logger_stats *ls) {
     4270:  889:    STATS_LOCK();
     4270:  890:    stats.log_worker_dropped  += ls->worker_dropped;
     4270:  891:    stats.log_worker_written  += ls->worker_written;
     4270:  892:    stats.log_watcher_skipped += ls->watcher_skipped;
     4270:  893:    stats.log_watcher_sent    += ls->watcher_sent;
     4270:  894:    stats_state.log_watchers   = ls->watcher_count;
     4270:  895:    STATS_UNLOCK();
     4270:  896:}
        -:  897:
        -:  898:#define MAX_LOGGER_SLEEP 1000000
        -:  899:#define MIN_LOGGER_SLEEP 1000
        -:  900:
        -:  901:/* Primary logger thread routine */
      123:  902:static void *logger_thread(void *arg) {
      123:  903:    useconds_t to_sleep = MIN_LOGGER_SLEEP;
      123:  904:    L_DEBUG("LOGGER: Starting logger thread\n");
        -:  905:    // TODO: If we ever have item references in the logger code, will need to
        -:  906:    // ensure everything is dequeued before stopping the thread.
     4393:  907:    while (do_run_logger_thread) {
     4391:  908:        int found_logs = 0;
     4391:  909:        logger *l;
     4391:  910:        struct logger_stats ls;
     4391:  911:        memset(&ls, 0, sizeof(struct logger_stats));
        -:  912:
        -:  913:        /* only sleep if we're *above* the minimum */
     4391:  914:        if (to_sleep > MIN_LOGGER_SLEEP)
     1101:  915:            usleep(to_sleep);
        -:  916:
        -:  917:        /* Call function to iterate each logger. */
     4391:  918:        pthread_mutex_lock(&logger_stack_lock);
     4391:  919:        if (watcher_count == 0) {
        -:  920:            // Not bothering to loop on the condition here since it's fine to
        -:  921:            // walk through with zero watchers.
      128:  922:            pthread_cond_wait(&logger_stack_cond, &logger_stack_lock);
        -:  923:        }
    34160:  924:        for (l = logger_stack_head; l != NULL; l=l->next) {
        -:  925:            /* lock logger, call function to manipulate it */
    29890:  926:            found_logs += logger_thread_read(l, &ls);
        -:  927:        }
        -:  928:
     4270:  929:        logger_thread_poll_watchers(1, WATCHER_ALL);
        -:  930:
        -:  931:        /* capture the current count within mutual exclusion of the lock */
     4270:  932:        ls.watcher_count = watcher_count;
        -:  933:
     4270:  934:        pthread_mutex_unlock(&logger_stack_lock);
        -:  935:
        -:  936:        /* TODO: abstract into a function and share with lru_crawler */
     4270:  937:        if (!found_logs) {
     1094:  938:            if (to_sleep < MAX_LOGGER_SLEEP)
     1094:  939:                to_sleep += to_sleep / 8;
     1094:  940:            if (to_sleep > MAX_LOGGER_SLEEP)
        -:  941:                to_sleep = MAX_LOGGER_SLEEP;
        -:  942:        } else {
     3176:  943:            to_sleep /= 2;
     3176:  944:            if (to_sleep < MIN_LOGGER_SLEEP)
     3167:  945:                to_sleep = MIN_LOGGER_SLEEP;
        -:  946:        }
     4270:  947:        logger_thread_flush_stats(&ls);
        -:  948:    }
        -:  949:
        2:  950:    return NULL;
        -:  951:}
        -:  952:
      123:  953:static int start_logger_thread(void) {
      123:  954:    int ret;
      123:  955:    do_run_logger_thread = 1;
      123:  956:    if ((ret = pthread_create(&logger_tid, NULL,
        -:  957:                              logger_thread, NULL)) != 0) {
    #####:  958:        fprintf(stderr, "Can't start logger thread: %s\n", strerror(ret));
    #####:  959:        return -1;
        -:  960:    }
      123:  961:    thread_setname(logger_tid, "mc-log");
      123:  962:    return 0;
        -:  963:}
        -:  964:
        2:  965:static int stop_logger_thread(void) {
        -:  966:    // Guarantees that the logger thread is waiting on 'logger_stack_cond'
        -:  967:    // before we signal it.
        2:  968:    pthread_mutex_lock(&logger_stack_lock);
        2:  969:    do_run_logger_thread = 0;
        2:  970:    pthread_cond_signal(&logger_stack_cond);
        2:  971:    pthread_mutex_unlock(&logger_stack_lock);
        2:  972:    pthread_join(logger_tid, NULL);
        2:  973:    return 0;
        -:  974:}
        -:  975:
        -:  976:/*************************
        -:  977: * Public functions for submitting logs and starting loggers from workers.
        -:  978: *************************/
        -:  979:
        -:  980:/* Global logger thread start/init */
      123:  981:void logger_init(void) {
        -:  982:    /* TODO: auto destructor when threads exit */
        -:  983:    /* TODO: error handling */
        -:  984:
        -:  985:    /* init stack for iterating loggers */
      123:  986:    logger_stack_head = 0;
      123:  987:    logger_stack_tail = 0;
      123:  988:    pthread_key_create(&logger_key, NULL);
        -:  989:
      123:  990:    if (start_logger_thread() != 0) {
    #####:  991:        abort();
        -:  992:    }
        -:  993:
        -:  994:    /* This is what adding a STDERR watcher looks like. should replace old
        -:  995:     * "verbose" settings. */
        -:  996:    //logger_add_watcher(NULL, 0);
      123:  997:    return;
        -:  998:}
        -:  999:
        2: 1000:void logger_stop(void) {
        2: 1001:    stop_logger_thread();
        2: 1002:}
        -: 1003:
        -: 1004:/* called *from* the thread using a logger.
        -: 1005: * initializes the per-thread bipbuf, links it into the list of loggers
        -: 1006: */
      892: 1007:logger *logger_create(void) {
      892: 1008:    L_DEBUG("LOGGER: Creating and linking new logger instance\n");
      892: 1009:    logger *l = calloc(1, sizeof(logger));
      892: 1010:    if (l == NULL) {
        -: 1011:        return NULL;
        -: 1012:    }
        -: 1013:
      892: 1014:    l->buf = bipbuf_new(settings.logger_buf_size);
      892: 1015:    if (l->buf == NULL) {
    #####: 1016:        free(l);
    #####: 1017:        return NULL;
        -: 1018:    }
        -: 1019:
      892: 1020:    l->entry_map = default_entries;
        -: 1021:
      892: 1022:    pthread_mutex_init(&l->mutex, NULL);
      892: 1023:    pthread_setspecific(logger_key, l);
        -: 1024:
        -: 1025:    /* add to list of loggers */
      892: 1026:    logger_link_q(l);
      892: 1027:    return l;
        -: 1028:}
        -: 1029:
        -: 1030:/* Public function for logging an entry.
        -: 1031: * Tries to encapsulate as much of the formatting as possible to simplify the
        -: 1032: * caller's code.
        -: 1033: */
    88033: 1034:enum logger_ret_type logger_log(logger *l, const enum log_entry_type event, const void *entry, ...) {
    88033: 1035:    bipbuf_t *buf = l->buf;
    88033: 1036:    bool nospace = false;
    88033: 1037:    va_list ap;
    88033: 1038:    logentry *e;
        -: 1039:
    88033: 1040:    const entry_details *d = &l->entry_map[event];
    88033: 1041:    int reqlen = d->reqlen;
        -: 1042:
    88033: 1043:    pthread_mutex_lock(&l->mutex);
        -: 1044:    /* Request a maximum length of data to write to */
    88033: 1045:    e = (logentry *) bipbuf_request(buf, (sizeof(logentry) + reqlen));
    88033: 1046:    if (e == NULL) {
     6916: 1047:        l->dropped++;
     6916: 1048:        pthread_mutex_unlock(&l->mutex);
     6916: 1049:        return LOGGER_RET_NOSPACE;
        -: 1050:    }
    81117: 1051:    e->event = event;
    81117: 1052:    e->pad = 0;
    81117: 1053:    e->gid = logger_get_gid();
        -: 1054:    /* TODO: Could pass this down as an argument now that we're using
        -: 1055:     * LOGGER_LOG() macro.
        -: 1056:     */
    81117: 1057:    e->eflags = d->eflags;
        -: 1058:    /* Noting time isn't optional. A feature may be added to avoid rendering
        -: 1059:     * time and/or gid to a logger.
        -: 1060:     */
    81117: 1061:    gettimeofday(&e->tv, NULL);
        -: 1062:
    81117: 1063:    va_start(ap, entry);
    81117: 1064:    d->log_cb(e, d, entry, ap);
    81117: 1065:    va_end(ap);
        -: 1066:
        -: 1067:#ifdef NEED_ALIGN
        -: 1068:    /* Need to ensure *next* request is aligned. */
        -: 1069:    if (sizeof(logentry) + e->size % 8 != 0) {
        -: 1070:        e->pad = 8 - (sizeof(logentry) + e->size % 8);
        -: 1071:    }
        -: 1072:#endif
        -: 1073:
        -: 1074:    /* Push pointer forward by the actual amount required */
    81117: 1075:    if (bipbuf_push(buf, (sizeof(logentry) + e->size + e->pad)) == 0) {
    #####: 1076:        fprintf(stderr, "LOGGER: Failed to bipbuf push a text entry\n");
    #####: 1077:        pthread_mutex_unlock(&l->mutex);
    #####: 1078:        return LOGGER_RET_ERR;
        -: 1079:    }
    81117: 1080:    l->written++;
        -: 1081:    L_DEBUG("LOGGER: Requested %d bytes, wrote %lu bytes\n", reqlen,
    81117: 1082:            (sizeof(logentry) + e->size));
        -: 1083:
    81117: 1084:    pthread_mutex_unlock(&l->mutex);
        -: 1085:
    81117: 1086:    if (nospace) {
        -: 1087:        return LOGGER_RET_NOSPACE;
        -: 1088:    } else {
    81117: 1089:        return LOGGER_RET_OK;
        -: 1090:    }
        -: 1091:}
        -: 1092:
        -: 1093:/* Passes a client connection socket from a primary worker thread to the
        -: 1094: * logger thread. Caller *must* event_del() the client before handing it over.
        -: 1095: * Presently there's no way to hand the client back to the worker thread.
        -: 1096: */
       11: 1097:enum logger_add_watcher_ret logger_add_watcher(void *c, const int sfd, uint16_t f) {
       11: 1098:    int x;
       11: 1099:    logger_watcher *w = NULL;
       11: 1100:    pthread_mutex_lock(&logger_stack_lock);
       11: 1101:    if (watcher_count >= WATCHER_LIMIT) {
    #####: 1102:        pthread_mutex_unlock(&logger_stack_lock);
    #####: 1103:        return LOGGER_ADD_WATCHER_TOO_MANY;
        -: 1104:    }
        -: 1105:
       20: 1106:    for (x = 0; x < WATCHER_LIMIT-1; x++) {
       20: 1107:        if (watchers[x] == NULL)
        -: 1108:            break;
        -: 1109:    }
        -: 1110:
       11: 1111:    w = calloc(1, sizeof(logger_watcher));
       11: 1112:    if (w == NULL) {
    #####: 1113:        pthread_mutex_unlock(&logger_stack_lock);
    #####: 1114:        return LOGGER_ADD_WATCHER_FAILED;
        -: 1115:    }
       11: 1116:    w->c = c;
       11: 1117:    w->sfd = sfd;
       11: 1118:    if (sfd == 0 && c == NULL) {
    #####: 1119:        w->t = LOGGER_WATCHER_STDERR;
        -: 1120:    } else {
       11: 1121:        w->t = LOGGER_WATCHER_CLIENT;
        -: 1122:    }
       11: 1123:    w->id = x;
       11: 1124:    w->eflags = f;
       11: 1125:    w->min_gid = logger_get_gid();
       11: 1126:    w->buf = bipbuf_new(settings.logger_watcher_buf_size);
       11: 1127:    if (w->buf == NULL) {
    #####: 1128:        free(w);
    #####: 1129:        pthread_mutex_unlock(&logger_stack_lock);
    #####: 1130:        return LOGGER_ADD_WATCHER_FAILED;
        -: 1131:    }
       11: 1132:    bipbuf_offer(w->buf, (unsigned char *) "OK\r\n", 4);
        -: 1133:
       11: 1134:    watchers[x] = w;
       11: 1135:    watcher_count++;
        -: 1136:    /* Update what flags the global logs will watch */
       11: 1137:    logger_set_flags();
       11: 1138:    pthread_cond_signal(&logger_stack_cond);
        -: 1139:
       11: 1140:    pthread_mutex_unlock(&logger_stack_lock);
       11: 1141:    return LOGGER_ADD_WATCHER_OK;
        -: 1142:}
